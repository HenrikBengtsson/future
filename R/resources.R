#' Check If Future Strategy Supports Specified Resources
#'
#' @param strategy A future strategy class `future`.
#'
#' @param resources A resources formula or NULL.
#'
#' @param \ldots For internal use only.
#'
#' @return (logical) TRUE if `resources` are supported, otherwise FALSE.
#'
#' @details
#' This function is intended for internal use and developing additional
#' future backends.
#'
#' @export
supportsResources <- function(strategy, resources, ...) {
  UseMethod("supportsResources")
}

#' @export
supportsResources.future <- function(strategy, resources, localhost = NA, fork = NA, ...) {
  if (is.null(resources)) return(TRUE)
  stop_if_not(
    inherits(resources, "formula"),
    length(resources) == 2L
  )

  res <- eval(resources[[2]])
  stop_if_not(is.logical(res), length(res) == 1L)

  ## BACKWARD COMPATIBILITY: If unknown, assume strategy supports resources
  if (is.na(res)) {
    res <- TRUE
  }

  res
}

#' @export
supportsResources.sequential <- function(strategy, resources, localhost = TRUE, fork = FALSE, ...) {
  NextMethod(localhost = localhost, fork = fork)
}

#' @export
supportsResources.cluster <- function(strategy, resources, localhost = NA, fork = NA, ...) {
  ## Infer 'localhost' or 'fork' from cluster inspection?
  if (is.na(localhost) || is.na(fork)) {
    ## Get the 'cluster' object
    workers <- formals(strategy)$workers
    workers <- eval(workers)
    future <- as_ClusterFuture(list(), workers = workers)
    workers <- future$workers

    if (packageVersion("parallelly") >= "1.23.0-9000") {
      .localhost <- parallelly::isLocalhostNode(workers)
      .fork <- parallelly::isForkedNode(workers)
    } else {
      ## Attempt to infer (localhost, fork) from cluster nodes
      n <- length(workers)
      .localhost <- logical(length = n)
      .fork <- logical(length = n)
      for (kk in seq_len(n)) {
        node <- workers[[kk]]
  
        ## Localhost processing?
        host <- node$host
        if (inherits(node, "RichSOCKnode")) {
          value <- attr(host, "localhost", exact = TRUE)
          if (is.logical(value)) .localhost[kk] <- value
        } else if (inherits(node, "forknode")) {
          .localhost[kk] <- TRUE
        } else {
          .localhost[kk] <- parallelly:::is_localhost(host)
        }
        
        ## Forked processing?
        if (inherits(node, "forknode")) {
          .fork[kk] <- TRUE
        }
      } ## for (kk ...)
    }
    
    ## Update 'localhost'?
    if (is.na(localhost)) localhost <- all(.localhost, na.rm = TRUE)
    
    ## Update 'fork'?
    if (is.na(fork)) fork <- any(.fork, na.rm = TRUE)
  }

  NextMethod(localhost = localhost, fork = fork)
}

#' @export
supportsResources.multisession <- function(strategy, resources, localhost = TRUE, ...) {
  NextMethod(localhost = localhost)
}

#' @export
supportsResources.multicore <- function(strategy, resources, localhost = TRUE, fork = TRUE, ...) {
  NextMethod(localhost = localhost, fork = fork)
}
