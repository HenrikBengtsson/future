% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/future_lapply.R
\name{future_lapply}
\alias{future_lapply}
\title{Apply a Function over a List or Vector via Futures}
\usage{
future_lapply(x, FUN, ..., future.args = NULL, future.seed = TRUE,
  future.scheduling = 1)
}
\arguments{
\item{x}{A vector-like object to iterate over.}

\item{FUN}{A function taking at least one argument.}

\item{...}{(optional) Additional arguments pass to \code{FUN()}.}

\item{future.args}{(optional) Additional arguments passed to
\code{\link{future}()}.}

\item{future.seed}{L'Ecuyer-CMRG RNG seed used to generate the stream
of seeds for all elements in \code{x}.  If \code{TRUE}, a
random initial seed is used.}

\item{future.scheduling}{Average number of futures per worker.
If \code{1.0} or \code{TRUE}, then one future per worker is used.
If \code{Inf} or \code{FALSE}, then one future per element of
\code{x} is used.
If \code{0.0}, then a single future is used to process all elements
of \code{x}.}
}
\value{
A list with same length and names as \code{x}.
}
\description{
Apply a Function over a List or Vector via Futures
}
\examples{
## Regardless of the future plan, the number of workers,
## and where they are, the random numbers will be identical
plan(sequential)
y1 <- future_lapply(1:5, FUN = rnorm, future.seed = 0xBEEF)
str(y1)

plan(multiprocess)
y2 <- future_lapply(1:5, FUN = rnorm, future.seed = 0xBEEF)
str(y2)

stopifnot(all.equal(y1, y2))
}
