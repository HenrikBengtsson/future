<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Back trace the expressions evaluated when an error was caught — backtrace • future</title>

<!-- favicons -->
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png" />
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png" />

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>


<!-- docsearch -->
<script src="../docsearch.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.3/docsearch.min.css" integrity="sha256-QOSRU/ra9ActyXkIBbiIB144aDBdtvXBcNc3OTNuX/Q=" crossorigin="anonymous" />
<link href="../docsearch.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>



<meta property="og:title" content="Back trace the expressions evaluated when an error was caught — backtrace" />
<meta property="og:description" content="Back trace the expressions evaluated when an error was caught" />
<meta property="og:image" content="https://future.futureverse.org/logo.png" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SB3EQSD9FR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SB3EQSD9FR');
</script>


  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">future</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.21.0-9005</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/future-1-overview.html">A Future for R: A Comprehensive Overview</a>
    </li>
    <li>
      <a href="../articles/future-2-output.html">A Future for R: Text and Message Output</a>
    </li>
    <li>
      <a href="../articles/future-3-topologies.html">A Future for R: Future Topologies</a>
    </li>
    <li>
      <a href="../articles/future-4-issues.html">A Future for R: Common Issues with Solutions</a>
    </li>
    <li>
      <a href="../articles/future-4-non-exportable-objects.html">A Future for R: Non-Exportable Objects</a>
    </li>
    <li>
      <a href="../articles/future-5-startup.html">A Future for R: Controlling Default Future Strategy</a>
    </li>
    <li>
      <a href="../articles/future-6-future-api-backend-specification.html">A Future for R: Future API Backend Specification</a>
    </li>
    <li>
      <a href="../articles/future-7-for-package-developers.html">A Future for R: Best Practices for Package Developers</a>
    </li>
    <li>
      <a href="../articles/future-8-how-future-is-validated.html">A Future for R: How the Future Framework is Validated</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://www.futureverse.org/">
    <span class="fas fa-fast-backward"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="https://BiocParallel.FutureParam.futureverse.org">BiocParallel.FutureParam</a>
    </li>
    <li>
      <a href="https://doFuture.futureverse.org">doFuture</a>
    </li>
    <li>
      <a href="https://furrr.futureverse.org">furrr</a>
    </li>
    <li>
      <a href="https://future.futureverse.org">future</a>
    </li>
    <li>
      <a href="https://future.apply.futureverse.org">future.apply</a>
    </li>
    <li>
      <a href="https://future.batchtools.futureverse.org">future.batchtools</a>
    </li>
    <li>
      <a href="https://future.callr.futureverse.org">future.callr</a>
    </li>
    <li>
      <a href="https://future.tests.futureverse.org">future.tests</a>
    </li>
    <li>
      <a href="https://globals.futureverse.org">globals</a>
    </li>
    <li>
      <a href="https://listenv.futureverse.org">listenv</a>
    </li>
    <li>
      <a href="https://parallelly.futureverse.org">parallelly</a>
    </li>
    <li>
      <a href="https://progressr.futureverse.org">progressr</a>
    </li>
    <li>
      <a href="https://future.mapreduce.futureverse.org">future.mapreduce (experimental)</a>
    </li>
    <li>
      <a href="https://marshal.futureverse.org">marshal (experimental)</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://cloud.r-project.org/package=future">
    <span class="fab fa-r-project"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/HenrikBengtsson/future/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
      <form class="navbar-form navbar-right hidden-xs hidden-sm" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off">
        </div>
      </form>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Back trace the expressions evaluated when an error was caught</h1>
    <small class="dont-index">Source: <a href='https://github.com/HenrikBengtsson/future/blob/master/R/backtrace.R'><code>R/backtrace.R</code></a></small>
    <div class="hidden name"><code>backtrace.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Back trace the expressions evaluated when an error was caught</p>
    </div>

    <pre class="usage"><span class='fu'>backtrace</span><span class='op'>(</span><span class='va'>future</span>, envir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>parent.frame</a></span><span class='op'>(</span><span class='op'>)</span>, <span class='va'>...</span><span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>future</th>
      <td><p>A future with a caught error.</p></td>
    </tr>
    <tr>
      <th>envir</th>
      <td><p>the environment where to locate the future.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Not used.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A list with the future's call stack that led up to the error.</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='va'>my_log</span> <span class='op'>&lt;-</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span> <span class='fu'><a href='https://rdrr.io/r/base/Log.html'>log</a></span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span>
<span class='va'>foo</span> <span class='op'>&lt;-</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>...</span><span class='op'>)</span> <span class='fu'>my_log</span><span class='op'>(</span><span class='va'>...</span><span class='op'>)</span>

<span class='va'>f</span> <span class='op'>&lt;-</span> <span class='fu'><a href='future.html'>future</a></span><span class='op'>(</span><span class='op'>{</span> <span class='fu'>foo</span><span class='op'>(</span><span class='st'>"a"</span><span class='op'>)</span> <span class='op'>}</span><span class='op'>)</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='kw'><a href='https://rdrr.io/r/base/conditions.html'>tryCatch</a></span><span class='op'>(</span><span class='op'>{</span>
  <span class='va'>v</span> <span class='op'>&lt;-</span> <span class='fu'><a href='value.html'>value</a></span><span class='op'>(</span><span class='va'>f</span><span class='op'>)</span>
<span class='op'>}</span>, error <span class='op'>=</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>ex</span><span class='op'>)</span> <span class='op'>{</span>
  <span class='va'>t</span> <span class='op'>&lt;-</span> <span class='fu'>backtrace</span><span class='op'>(</span><span class='va'>f</span><span class='op'>)</span>
  <span class='fu'><a href='https://rdrr.io/r/base/print.html'>print</a></span><span class='op'>(</span><span class='va'>t</span><span class='op'>)</span>
<span class='op'>}</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [[1]]
#&gt; tryCatch(withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/tmp/hb/Rtmpbw1A1Z/callr-fun-48a3b3b91f2"), 
#&gt;         list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, 
#&gt;         quote = TRUE), file = "/tmp/hb/Rtmpbw1A1Z/callr-res-48a3738ea0fe")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         assign(".Traceback", .traceback(4), envir = callr_data)
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e$call &lt;- deparse(conditionCall(e), nlines = 6)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error_2_0")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2, embed = FALSE)
#&gt;         saveRDS(list("error", e2), file = paste0("/tmp/hb/Rtmpbw1A1Z/callr-res-48a3738ea0fe", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         assign(".Traceback", .traceback(4), envir = callr_data)
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e$call &lt;- deparse(conditionCall(e), nlines = 6)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error_2_0")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2, embed = FALSE)
#&gt;         saveRDS(list("error", e2), file = paste0("/tmp/hb/Rtmpbw1A1Z/callr-res-48a3738ea0fe", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try(signalCondition(e))
#&gt; }), error = function(e) {
#&gt;     NULL
#&gt;     try(stop(e))
#&gt; }, interrupt = function(e) {
#&gt;     NULL
#&gt;     e
#&gt; })
#&gt; 
#&gt; [[2]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[3]]
#&gt; tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
#&gt;     names[nh], parentenv, handlers[[nh]])
#&gt; 
#&gt; [[4]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[5]]
#&gt; tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
#&gt; 
#&gt; [[6]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[7]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[8]]
#&gt; withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/tmp/hb/Rtmpbw1A1Z/callr-fun-48a3b3b91f2"), 
#&gt;         list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, 
#&gt;         quote = TRUE), file = "/tmp/hb/Rtmpbw1A1Z/callr-res-48a3738ea0fe")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         assign(".Traceback", .traceback(4), envir = callr_data)
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e$call &lt;- deparse(conditionCall(e), nlines = 6)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error_2_0")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2, embed = FALSE)
#&gt;         saveRDS(list("error", e2), file = paste0("/tmp/hb/Rtmpbw1A1Z/callr-res-48a3738ea0fe", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         assign(".Traceback", .traceback(4), envir = callr_data)
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e$call &lt;- deparse(conditionCall(e), nlines = 6)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error_2_0")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2, embed = FALSE)
#&gt;         saveRDS(list("error", e2), file = paste0("/tmp/hb/Rtmpbw1A1Z/callr-res-48a3738ea0fe", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try(signalCondition(e))
#&gt; })
#&gt; 
#&gt; [[9]]
#&gt; saveRDS(do.call(do.call, c(readRDS("/tmp/hb/Rtmpbw1A1Z/callr-fun-48a3b3b91f2"), 
#&gt;     list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, 
#&gt;     quote = TRUE), file = "/tmp/hb/Rtmpbw1A1Z/callr-res-48a3738ea0fe")
#&gt; 
#&gt; [[10]]
#&gt; do.call(do.call, c(readRDS("/tmp/hb/Rtmpbw1A1Z/callr-fun-48a3b3b91f2"), 
#&gt;     list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, 
#&gt;     quote = TRUE)
#&gt; 
#&gt; [[11]]
#&gt; (function (what, args, quote = FALSE, envir = parent.frame()) 
#&gt; {
#&gt;     if (!is.list(args)) 
#&gt;         stop("second argument must be a list")
#&gt;     if (quote) 
#&gt;         args &lt;- lapply(args, enquote)
#&gt;     .Internal(do.call(what, args, envir))
#&gt; })(base::quote(function (..., crayon_enabled, crayon_colors, 
#&gt;     pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; }), base::quote(list(pkg = list(package = "future", version = "1.21.0-9005", 
#&gt;     src_path = "/tmp/hb/Rtmpbw1A1Z/future", dst_path = "/tmp/hb/Rtmpbw1A1Z/future/docs", 
#&gt;     install_metadata = FALSE, desc = &lt;environment&gt;, meta = list(
#&gt;         url = "https://future.futureverse.org", home = list(links = list(
#&gt;             list(text = "Roadmap/Milestones", href = "https://github.com/HenrikBengtsson/future/milestones"), 
#&gt;             list(text = "The Futureverse Project", href = "https://www.futureverse.org/"), 
#&gt;             list(text = "Futureverse User Forum (new!)", href = "https://github.com/HenrikBengtsson/future/discussions"))), 
#&gt;         navbar = list(structure = list(right = c("futureverse", 
#&gt;         "pkgs", "cran", "github")), components = list(futureverse = list(
#&gt;             icon = "fas fa-fast-backward", href = "https://www.futureverse.org/"), 
#&gt;             pkgs = list(text = "Packages", menu = list(list(text = "BiocParallel.FutureParam", 
#&gt;                 href = "https://BiocParallel.FutureParam.futureverse.org"), 
#&gt;                 list(text = "doFuture", href = "https://doFuture.futureverse.org"), 
#&gt;                 list(text = "furrr", href = "https://furrr.futureverse.org"), 
#&gt;                 list(text = "future", href = "https://future.futureverse.org"), 
#&gt;                 list(text = "future.apply", href = "https://future.apply.futureverse.org"), 
#&gt;                 list(text = "future.batchtools", href = "https://future.batchtools.futureverse.org"), 
#&gt;                 list(text = "future.callr", href = "https://future.callr.futureverse.org"), 
#&gt;                 list(text = "future.tests", href = "https://future.tests.futureverse.org"), 
#&gt;                 list(text = "globals", href = "https://globals.futureverse.org"), 
#&gt;                 list(text = "listenv", href = "https://listenv.futureverse.org"), 
#&gt;                 list(text = "parallelly", href = "https://parallelly.futureverse.org"), 
#&gt;                 list(text = "progressr", href = "https://progressr.futureverse.org"), 
#&gt;                 list(text = "future.mapreduce (experimental)", 
#&gt;                   href = "https://future.mapreduce.futureverse.org"), 
#&gt;                 list(text = "marshal (experimental)", href = "https://marshal.futureverse.org"))), 
#&gt;             cran = list(icon = "fab fa-r-project", href = "https://cloud.r-project.org/package=future"))), 
#&gt;         template = list(params = list(docsearch = list(api_key = "aa6e02fc501886fb0f7c91ac4e300456", 
#&gt;             index_name = "futureverse", algoliaOptions = list(
#&gt;                 facetFilters = "project:future")), ganalytics = "G-SB3EQSD9FR"))), 
#&gt;     figures = list(dev = "ragg::agg_png", dpi = 96L, dev.args = list(), 
#&gt;         fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, 
#&gt;         fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL), 
#&gt;     repo = list(url = list(home = "https://github.com/HenrikBengtsson/future/", 
#&gt;         source = "https://github.com/HenrikBengtsson/future/blob/master/", 
#&gt;         issue = "https://github.com/HenrikBengtsson/future/issues/", 
#&gt;         user = "https://github.com/")), development = list(destination = "dev", 
#&gt;         mode = "release", version_label = "default", version_tooltip = "Released version", 
#&gt;         in_dev = FALSE), topics = list(name = c(`ClusterFuture-class.Rd` = "ClusterFuture-class", 
#&gt;     `ConstantFuture-class.Rd` = "ConstantFuture-class", `Future-class.Rd` = "Future-class", 
#&gt;     FutureCondition.Rd = "FutureCondition", FutureGlobals.Rd = "FutureGlobals", 
#&gt;     FutureResult.Rd = "FutureResult", `MulticoreFuture-class.Rd` = "MulticoreFuture-class", 
#&gt;     `MultiprocessFuture-class.Rd` = "MultiprocessFuture-class", 
#&gt;     `UniprocessFuture-class.Rd` = "UniprocessFuture-class", as_lecyer_cmrg_seed.Rd = "as_lecyer_cmrg_seed", 
#&gt;     backtrace.Rd = "backtrace", cluster.Rd = "cluster", clusterExportSticky.Rd = "clusterExportSticky", 
#&gt;     find_references.Rd = "find_references", future.Rd = "future", 
#&gt;     future.options.Rd = "future.options", futureOf.Rd = "futureOf", 
#&gt;     futureSessionInfo.Rd = "futureSessionInfo", futures.Rd = "futures", 
#&gt;     getExpression.Rd = "getExpression", getGlobalsAndPackages.Rd = "getGlobalsAndPackages", 
#&gt;     `grapes-conditions-grapes.Rd` = "%conditions%", `grapes-globals-grapes.Rd` = "%globals%", 
#&gt;     `grapes-label-grapes.Rd` = "%label%", `grapes-lazy-grapes.Rd` = "%lazy%", 
#&gt;     `grapes-plan-grapes.Rd` = "%plan%", `grapes-seed-grapes.Rd` = "%seed%", 
#&gt;     `grapes-stdout-grapes.Rd` = "%stdout%", `grapes-tweak-grapes.Rd` = "%tweak%", 
#&gt;     make_rng_seeds.Rd = "make_rng_seeds", mandelbrot.Rd = "mandelbrot", 
#&gt;     multicore.Rd = "multicore", multiprocess.Rd = "multiprocess", 
#&gt;     multisession.Rd = "multisession", nbrOfWorkers.Rd = "nbrOfWorkers", 
#&gt;     nullcon.Rd = "nullcon", pid_exists.Rd = "pid_exists", plan.Rd = "plan", 
#&gt;     private_length.Rd = ".length", `re-exports.Rd` = "re-exports", 
#&gt;     readImmediateConditions.Rd = "readImmediateConditions", remote.Rd = "remote", 
#&gt;     requestCore.Rd = "requestCore", resetWorkers.Rd = "resetWorkers", 
#&gt;     resolve.Rd = "resolve", resolved.Rd = "resolved", result.Rd = "result.Future", 
#&gt;     run.Rd = "run.Future", save_rds.Rd = "save_rds", sequential.Rd = "sequential", 
#&gt;     sessionDetails.Rd = "sessionDetails", signalConditions.Rd = "signalConditions", 
#&gt;     sticky_globals.Rd = "sticky_globals", tweak.Rd = "tweak", 
#&gt;     usedCores.Rd = "usedCores", value.Rd = "value"), file_in = c("ClusterFuture-class.Rd", 
#&gt;     "ConstantFuture-class.Rd", "Future-class.Rd", "FutureCondition.Rd", 
#&gt;     "FutureGlobals.Rd", "FutureResult.Rd", "MulticoreFuture-class.Rd", 
#&gt;     "MultiprocessFuture-class.Rd", "UniprocessFuture-class.Rd", 
#&gt;     "as_lecyer_cmrg_seed.Rd", "backtrace.Rd", "cluster.Rd", "clusterExportSticky.Rd", 
#&gt;     "find_references.Rd", "future.Rd", "future.options.Rd", "futureOf.Rd", 
#&gt;     "futureSessionInfo.Rd", "futures.Rd", "getExpression.Rd", 
#&gt;     "getGlobalsAndPackages.Rd", "grapes-conditions-grapes.Rd", 
#&gt;     "grapes-globals-grapes.Rd", "grapes-label-grapes.Rd", "grapes-lazy-grapes.Rd", 
#&gt;     "grapes-plan-grapes.Rd", "grapes-seed-grapes.Rd", "grapes-stdout-grapes.Rd", 
#&gt;     "grapes-tweak-grapes.Rd", "make_rng_seeds.Rd", "mandelbrot.Rd", 
#&gt;     "multicore.Rd", "multiprocess.Rd", "multisession.Rd", "nbrOfWorkers.Rd", 
#&gt;     "nullcon.Rd", "pid_exists.Rd", "plan.Rd", "private_length.Rd", 
#&gt;     "re-exports.Rd", "readImmediateConditions.Rd", "remote.Rd", 
#&gt;     "requestCore.Rd", "resetWorkers.Rd", "resolve.Rd", "resolved.Rd", 
#&gt;     "result.Rd", "run.Rd", "save_rds.Rd", "sequential.Rd", "sessionDetails.Rd", 
#&gt;     "signalConditions.Rd", "sticky_globals.Rd", "tweak.Rd", "usedCores.Rd", 
#&gt;     "value.Rd"), file_out = c("ClusterFuture-class.html", "ConstantFuture-class.html", 
#&gt;     "Future-class.html", "FutureCondition.html", "FutureGlobals.html", 
#&gt;     "FutureResult.html", "MulticoreFuture-class.html", "MultiprocessFuture-class.html", 
#&gt;     "UniprocessFuture-class.html", "as_lecyer_cmrg_seed.html", 
#&gt;     "backtrace.html", "cluster.html", "clusterExportSticky.html", 
#&gt;     "find_references.html", "future.html", "future.options.html", 
#&gt;     "futureOf.html", "futureSessionInfo.html", "futures.html", 
#&gt;     "getExpression.html", "getGlobalsAndPackages.html", "grapes-conditions-grapes.html", 
#&gt;     "grapes-globals-grapes.html", "grapes-label-grapes.html", 
#&gt;     "grapes-lazy-grapes.html", "grapes-plan-grapes.html", "grapes-seed-grapes.html", 
#&gt;     "grapes-stdout-grapes.html", "grapes-tweak-grapes.html", 
#&gt;     "make_rng_seeds.html", "mandelbrot.html", "multicore.html", 
#&gt;     "multiprocess.html", "multisession.html", "nbrOfWorkers.html", 
#&gt;     "nullcon.html", "pid_exists.html", "plan.html", "private_length.html", 
#&gt;     "re-exports.html", "readImmediateConditions.html", "remote.html", 
#&gt;     "requestCore.html", "resetWorkers.html", "resolve.html", 
#&gt;     "resolved.html", "result.html", "run.html", "save_rds.html", 
#&gt;     "sequential.html", "sessionDetails.html", "signalConditions.html", 
#&gt;     "sticky_globals.html", "tweak.html", "usedCores.html", "value.html"
#&gt;     ), alias = list(`ClusterFuture-class.Rd` = c("ClusterFuture-class", 
#&gt;     "ClusterFuture", "MultisessionFuture", "MultisessionFuture-class"
#&gt;     ), `ConstantFuture-class.Rd` = c("ConstantFuture-class", 
#&gt;     "ConstantFuture"), `Future-class.Rd` = c("Future-class", 
#&gt;     "Future"), FutureCondition.Rd = c("FutureCondition", "FutureMessage", 
#&gt;     "FutureWarning", "FutureError", "RngFutureCondition", "RngFutureWarning", 
#&gt;     "RngFutureError", "UnexpectedFutureResultError"), FutureGlobals.Rd = c("FutureGlobals", 
#&gt;     "as.FutureGlobals", "as.FutureGlobals.FutureGlobals", "as.FutureGlobals.Globals", 
#&gt;     "as.FutureGlobals.list", "[.FutureGlobals", "c.FutureGlobals", 
#&gt;     "unique.FutureGlobals"), FutureResult.Rd = c("FutureResult", 
#&gt;     "as.character.FutureResult", "print.FutureResult"), `MulticoreFuture-class.Rd` = c("MulticoreFuture-class", 
#&gt;     "MulticoreFuture"), `MultiprocessFuture-class.Rd` = c("MultiprocessFuture-class", 
#&gt;     "MultiprocessFuture"), `UniprocessFuture-class.Rd` = c("UniprocessFuture-class", 
#&gt;     "UniprocessFuture", "SequentialFuture", "TransparentFuture"
#&gt;     ), as_lecyer_cmrg_seed.Rd = c("as_lecyer_cmrg_seed", "is_lecyer_cmrg_seed"
#&gt;     ), backtrace.Rd = "backtrace", cluster.Rd = "cluster", clusterExportSticky.Rd = "clusterExportSticky", 
#&gt;         find_references.Rd = c("find_references", "assert_no_references"
#&gt;         ), future.Rd = c("future", "futureCall", "futureAssign", 
#&gt;         "%&lt;-%", "%-&gt;%"), future.options.Rd = c("future.options", 
#&gt;         "future.cmdargs", ".future.R", "future.startup.script", 
#&gt;         "R_FUTURE_STARTUP_SCRIPT", "future.debug", "R_FUTURE_DEBUG", 
#&gt;         "future.demo.mandelbrot.region", "R_FUTURE_DEMO_MANDELBROT_REGION", 
#&gt;         "future.demo.mandelbrot.nrow", "R_FUTURE_DEMO_MANDELBROT_NROW", 
#&gt;         "future.fork.multithreading.enable", "R_FUTURE_FORK_MULTITHREADING_ENABLE", 
#&gt;         "future.globals.maxSize", "R_FUTURE_GLOBALS_MAXSIZE", 
#&gt;         "future.globals.method", "R_FUTURE_GLOBALS_METHOD", "future.globals.onMissing", 
#&gt;         "R_FUTURE_GLOBALS_ONMISSING", "future.globals.resolve", 
#&gt;         "R_FUTURE_GLOBALS_RESOLVE", "future.globals.onReference", 
#&gt;         "R_FUTURE_GLOBALS_ONREFERENCE", "future.plan", "R_FUTURE_PLAN", 
#&gt;         "future.resolve.recursive", "R_FUTURE_RNG_ONMISUSE", 
#&gt;         "future.wait.alpha", "R_FUTURE_WAIT_ALPHA", "future.wait.interval", 
#&gt;         "R_FUTURE_WAIT_INTERVAL", "future.wait.timeout", "R_FUTURE_WAIT_TIMEOUT", 
#&gt;         "R_FUTURE_RESOLVED_TIMEOUT"), futureOf.Rd = "futureOf", 
#&gt;         futureSessionInfo.Rd = "futureSessionInfo", futures.Rd = "futures", 
#&gt;         getExpression.Rd = c("getExpression", "getExpression.Future"
#&gt;         ), getGlobalsAndPackages.Rd = "getGlobalsAndPackages", 
#&gt;         `grapes-conditions-grapes.Rd` = "%conditions%", `grapes-globals-grapes.Rd` = c("%globals%", 
#&gt;         "%packages%"), `grapes-label-grapes.Rd` = "%label%", 
#&gt;         `grapes-lazy-grapes.Rd` = "%lazy%", `grapes-plan-grapes.Rd` = "%plan%", 
#&gt;         `grapes-seed-grapes.Rd` = "%seed%", `grapes-stdout-grapes.Rd` = "%stdout%", 
#&gt;         `grapes-tweak-grapes.Rd` = "%tweak%", make_rng_seeds.Rd = "make_rng_seeds", 
#&gt;         mandelbrot.Rd = c("mandelbrot", "as.raster.Mandelbrot", 
#&gt;         "plot.Mandelbrot", "mandelbrot_tiles"), multicore.Rd = "multicore", 
#&gt;         multiprocess.Rd = "multiprocess", multisession.Rd = "multisession", 
#&gt;         nbrOfWorkers.Rd = c("nbrOfWorkers", "nbrOfFreeWorkers"
#&gt;         ), nullcon.Rd = "nullcon", pid_exists.Rd = "pid_exists", 
#&gt;         plan.Rd = "plan", private_length.Rd = ".length", `re-exports.Rd` = c("re-exports", 
#&gt;         "as.cluster", "autoStopCluster", "availableCores", "availableWorkers", 
#&gt;         "makeClusterMPI", "makeClusterPSOCK", "makeNodePSOCK", 
#&gt;         "supportsMulticore"), readImmediateConditions.Rd = "readImmediateConditions", 
#&gt;         remote.Rd = "remote", requestCore.Rd = "requestCore", 
#&gt;         resetWorkers.Rd = "resetWorkers", resolve.Rd = "resolve", 
#&gt;         resolved.Rd = "resolved", result.Rd = c("result.Future", 
#&gt;         "result"), run.Rd = c("run.Future", "run"), save_rds.Rd = "save_rds", 
#&gt;         sequential.Rd = c("sequential", "uniprocess", "transparent"
#&gt;         ), sessionDetails.Rd = "sessionDetails", signalConditions.Rd = "signalConditions", 
#&gt;         sticky_globals.Rd = "sticky_globals", tweak.Rd = "tweak", 
#&gt;         usedCores.Rd = "usedCores", value.Rd = c("value", "values", 
#&gt;         "value.Future", "value.list", "value.listenv", "value.environment"
#&gt;         )), funs = list(`ClusterFuture-class.Rd` = c("ClusterFuture()", 
#&gt;     "MultisessionFuture()"), `ConstantFuture-class.Rd` = "ConstantFuture()", 
#&gt;         `Future-class.Rd` = "Future()", FutureCondition.Rd = c("FutureCondition()", 
#&gt;         "FutureMessage()", "FutureWarning()", "FutureError()", 
#&gt;         "RngFutureCondition()", "RngFutureWarning()", "RngFutureError()", 
#&gt;         "UnexpectedFutureResultError()"), FutureGlobals.Rd = "FutureGlobals()", 
#&gt;         FutureResult.Rd = c("FutureResult()", "as.character(&lt;i&gt;&amp;lt;FutureResult&amp;gt;&lt;/i&gt;)", 
#&gt;         "print(&lt;i&gt;&amp;lt;FutureResult&amp;gt;&lt;/i&gt;)"), `MulticoreFuture-class.Rd` = "MulticoreFuture()", 
#&gt;         `MultiprocessFuture-class.Rd` = "MultiprocessFuture()", 
#&gt;         `UniprocessFuture-class.Rd` = c("UniprocessFuture()", 
#&gt;         "SequentialFuture()", "TransparentFuture()"), as_lecyer_cmrg_seed.Rd = c("as_lecyer_cmrg_seed()", 
#&gt;         "is_lecyer_cmrg_seed()"), backtrace.Rd = "backtrace()", 
#&gt;         cluster.Rd = "cluster()", clusterExportSticky.Rd = "clusterExportSticky()", 
#&gt;         find_references.Rd = c("find_references()", "assert_no_references()"
#&gt;         ), future.Rd = c("future()", "futureAssign()", "`%&amp;lt;-%`", 
#&gt;         "futureCall()"), future.options.Rd = character(0), futureOf.Rd = "futureOf()", 
#&gt;         futureSessionInfo.Rd = "futureSessionInfo()", futures.Rd = "futures()", 
#&gt;         getExpression.Rd = "getExpression()", getGlobalsAndPackages.Rd = "getGlobalsAndPackages()", 
#&gt;         `grapes-conditions-grapes.Rd` = "`%conditions%`", `grapes-globals-grapes.Rd` = c("`%globals%`", 
#&gt;         "`%packages%`"), `grapes-label-grapes.Rd` = "`%label%`", 
#&gt;         `grapes-lazy-grapes.Rd` = "`%lazy%`", `grapes-plan-grapes.Rd` = "`%plan%`", 
#&gt;         `grapes-seed-grapes.Rd` = "`%seed%`", `grapes-stdout-grapes.Rd` = "`%stdout%`", 
#&gt;         `grapes-tweak-grapes.Rd` = "`%tweak%`", make_rng_seeds.Rd = "make_rng_seeds()", 
#&gt;         mandelbrot.Rd = "mandelbrot()", multicore.Rd = "multicore()", 
#&gt;         multiprocess.Rd = "multiprocess()", multisession.Rd = "multisession()", 
#&gt;         nbrOfWorkers.Rd = c("nbrOfWorkers()", "nbrOfFreeWorkers()"
#&gt;         ), nullcon.Rd = "nullcon()", pid_exists.Rd = "pid_exists()", 
#&gt;         plan.Rd = "plan()", private_length.Rd = ".length()", 
#&gt;         `re-exports.Rd` = character(0), readImmediateConditions.Rd = "readImmediateConditions()", 
#&gt;         remote.Rd = "remote()", requestCore.Rd = "requestCore()", 
#&gt;         resetWorkers.Rd = "resetWorkers()", resolve.Rd = "resolve()", 
#&gt;         resolved.Rd = "resolved()", result.Rd = "result(&lt;i&gt;&amp;lt;Future&amp;gt;&lt;/i&gt;)", 
#&gt;         run.Rd = "run(&lt;i&gt;&amp;lt;Future&amp;gt;&lt;/i&gt;)", save_rds.Rd = "save_rds()", 
#&gt;         sequential.Rd = c("sequential()", "transparent()"), sessionDetails.Rd = "sessionDetails()", 
#&gt;         signalConditions.Rd = "signalConditions()", sticky_globals.Rd = "sticky_globals()", 
#&gt;         tweak.Rd = "tweak()", usedCores.Rd = "usedCores()", value.Rd = "value()"), 
#&gt;         title = c(`ClusterFuture-class.Rd` = "A cluster future is a future whose value will be resolved asynchronously in a parallel process", 
#&gt;         `ConstantFuture-class.Rd` = "A future with a constant value", 
#&gt;         `Future-class.Rd` = "A future represents a value that will be available at some point in the future", 
#&gt;         FutureCondition.Rd = "A condition (message, warning, or error) that occurred while orchestrating a future", 
#&gt;         FutureGlobals.Rd = "A representation of a set of globals used with futures", 
#&gt;         FutureResult.Rd = "Results from resolving a future", 
#&gt;         `MulticoreFuture-class.Rd` = "A multicore future is a future whose value will be resolved asynchronously in a parallel process", 
#&gt;         `MultiprocessFuture-class.Rd` = "A multiprocess future is a future whose value will be resolved asynchronously in a parallel process", 
#&gt;         `UniprocessFuture-class.Rd` = "An uniprocess future is a future whose value will be resolved synchronously in the current process", 
#&gt;         as_lecyer_cmrg_seed.Rd = "Get a L'Ecuyer-CMRG seed either from an input seed or the current RNG state", 
#&gt;         backtrace.Rd = "Back trace the expressions evaluated when an error was caught", 
#&gt;         cluster.Rd = "Create a cluster future whose value will be resolved asynchronously in a parallel process", 
#&gt;         clusterExportSticky.Rd = "Export globals to the sticky-globals environment of the cluster nodes", 
#&gt;         find_references.Rd = "Get the first or all references of an &lt;span style=\"R\"&gt;R&lt;/span&gt; object", 
#&gt;         future.Rd = "Create a future", future.options.Rd = "Options used for futures", 
#&gt;         futureOf.Rd = "Get the future of a future variable", 
#&gt;         futureSessionInfo.Rd = "Get session information specific to the future framework", 
#&gt;         futures.Rd = "Get all futures in a container", getExpression.Rd = "Inject code for the next type of future to use for nested futures", 
#&gt;         getGlobalsAndPackages.Rd = "Retrieves global variables of an expression and their associated packages", 
#&gt;         `grapes-conditions-grapes.Rd` = "Control whether standard output should be captured or not", 
#&gt;         `grapes-globals-grapes.Rd` = "Specify globals and packages for a future assignment", 
#&gt;         `grapes-label-grapes.Rd` = "Specify label for a future assignment", 
#&gt;         `grapes-lazy-grapes.Rd` = "Control lazy / eager evaluation for a future assignment", 
#&gt;         `grapes-plan-grapes.Rd` = "Use a specific plan for a future assignment", 
#&gt;         `grapes-seed-grapes.Rd` = "Set random seed for future assignment", 
#&gt;         `grapes-stdout-grapes.Rd` = "Control whether standard output should be captured or not", 
#&gt;         `grapes-tweak-grapes.Rd` = "Temporarily tweaks the arguments of the current strategy", 
#&gt;         make_rng_seeds.Rd = "Produce Reproducible Seeds for Parallel Random Number Generation", 
#&gt;         mandelbrot.Rd = "Mandelbrot convergence counts", multicore.Rd = "Create a multicore future whose value will be resolved asynchronously in a forked parallel process", 
#&gt;         multiprocess.Rd = "Create a multiprocess future whose value will be resolved asynchronously using multicore or a multisession evaluation", 
#&gt;         multisession.Rd = "Create a multisession future whose value will be resolved asynchronously in a parallel &lt;span style=\"R\"&gt;R&lt;/span&gt; session", 
#&gt;         nbrOfWorkers.Rd = "Get the number of workers available", 
#&gt;         nullcon.Rd = "Creates a connection to the system null device", 
#&gt;         pid_exists.Rd = "Check whether a process PID exists or not", 
#&gt;         plan.Rd = "Plan how to resolve a future", private_length.Rd = "Gets the length of an object without dispatching", 
#&gt;         `re-exports.Rd` = "Functions Moved to 'parallelly'", 
#&gt;         readImmediateConditions.Rd = "Read All 'immediateCondition' RDS Files", 
#&gt;         remote.Rd = "Create a remote future whose value will be resolved asynchronously in a remote process", 
#&gt;         requestCore.Rd = "Request a core for multicore processing", 
#&gt;         resetWorkers.Rd = "Free up active background workers", 
#&gt;         resolve.Rd = "Resolve one or more futures synchronously", 
#&gt;         resolved.Rd = "Check whether a future is resolved or not", 
#&gt;         result.Rd = "Get the results of a resolved future", run.Rd = "Run a future", 
#&gt;         save_rds.Rd = "Robustly Saves an Object to RDS File Atomically", 
#&gt;         sequential.Rd = "Create a sequential future whose value will be in the current &lt;span style=\"R\"&gt;R&lt;/span&gt; session", 
#&gt;         sessionDetails.Rd = "Outputs details on the current &lt;span style=\"R\"&gt;R&lt;/span&gt; session", 
#&gt;         signalConditions.Rd = "Signals Captured Conditions", 
#&gt;         sticky_globals.Rd = "Place a sticky-globals environment immediately after the global environment", 
#&gt;         tweak.Rd = "Tweak a future function by adjusting its default arguments", 
#&gt;         usedCores.Rd = "Get number of cores currently used", 
#&gt;         value.Rd = "The value of a future or the values of all elements in a container"
#&gt;         ), rd = list(`ClusterFuture-class.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/ClusterFuture-class.R,", 
#&gt;             "\n", "%   R/MultisessionFuture-class.R", "\n", list(
#&gt;                 "ClusterFuture-class"), "\n", list("ClusterFuture-class"), 
#&gt;             "\n", list("ClusterFuture"), "\n", list("MultisessionFuture"), 
#&gt;             "\n", list("MultisessionFuture-class"), "\n", list(
#&gt;                 "A cluster future is a future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "ClusterFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  substitute = TRUE,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  globals = TRUE,\n", "  packages = NULL,\n", 
#&gt;                 "  local = !persistent,\n", "  persistent = FALSE,\n", 
#&gt;                 "  workers = NULL,\n", "  user = NULL,\n", "  master = NULL,\n", 
#&gt;                 "  revtunnel = TRUE,\n", "  homogeneous = NULL,\n", 
#&gt;                 "  ...\n", ")\n", "\n", "MultisessionFuture(\n", 
#&gt;                 "  expr = NULL,\n", "  substitute = TRUE,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  persistent = FALSE,\n", 
#&gt;                 "  workers = NULL,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An ", list(), 
#&gt;                 " ", list("expression"), ".")), "\n", "\n", list(
#&gt;                 list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("packages"), list(
#&gt;                   "(optional) a character vector specifying packages\n", 
#&gt;                   "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("local"), list("If TRUE, the expression is evaluated such that\n", 
#&gt;                   "all assignments are done to local temporary environment, otherwise\n", 
#&gt;                   "the assignments are done to the global environment of the ", 
#&gt;                   list(), " process\n", "evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("persistent"), list("If FALSE, the evaluation environment is cleared\n", 
#&gt;                   "from objects prior to the evaluation of the future.")), 
#&gt;                 "\n", "\n", list(list("workers"), list("A ", 
#&gt;                   list(list("cluster")), " object,\n", "a character vector of host names, a positive numeric scalar,\n", 
#&gt;                   "or a function.\n", "If a character vector or a numeric scalar, a ", 
#&gt;                   list("cluster"), " object\n", "is created using ", 
#&gt;                   list(list("makeClusterPSOCK"), "(workers)"), 
#&gt;                   ".\n", "If a function, it is called without arguments ", 
#&gt;                   list("when the future\n", "is created"), " and its value is used to configure the workers.\n", 
#&gt;                   "The function should return any of the above types.")), 
#&gt;                 "\n", "\n", list(list("user"), list("(optional) The user name to be used when communicating\n", 
#&gt;                   "with another host.")), "\n", "\n", list(list(
#&gt;                   "master"), list("(optional) The hostname or IP address of the master\n", 
#&gt;                   "machine running this node.")), "\n", "\n", 
#&gt;                 list(list("revtunnel"), list("If TRUE, reverse SSH tunneling is used for the\n", 
#&gt;                   "PSOCK cluster nodes to connect back to the master ", 
#&gt;                   list(), " process.  This\n", "avoids the hassle of firewalls, port forwarding and having to know\n", 
#&gt;                   "the internal / public IP address of the master ", 
#&gt;                   list(), " session.")), "\n", "\n", list(list(
#&gt;                   "homogeneous"), list("If TRUE, all cluster nodes is assumed to use the\n", 
#&gt;                   "same path to ", list("Rscript"), " as the main ", 
#&gt;                   list(), " session.  If FALSE, the\n", "it is assumed to be on the PATH for each node.\n", 
#&gt;                   "If NULL, then ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                   " will decide on TRUE\n", "or FALSE depending on ", 
#&gt;                   list("workers"), ".")), "\n", "\n", list(list(
#&gt;                   "..."), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", list("ClusterFuture()"), " returns an object of class ", 
#&gt;                 list("ClusterFuture"), ".\n", "\n", list("MultisessionFuture()"), 
#&gt;                 " returns an object of class\n", list("MultisessionFuture"), 
#&gt;                 ", which inherits from ", list("ClusterFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "A cluster future is a future whose value will be resolved asynchronously in a parallel process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"cluster future\", see function\n", 
#&gt;                 list(list("cluster()")), ".\n"), "\n", list("internal"), 
#&gt;             "\n"), `ConstantFuture-class.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/ConstantFuture-class.R", 
#&gt;             "\n", list("ConstantFuture-class"), "\n", list("ConstantFuture-class"), 
#&gt;             "\n", list("ConstantFuture"), "\n", list("A future with a constant value"), 
#&gt;             "\n", list("\n", "ConstantFuture(..., globals = TRUE, envir = emptyenv())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Additional named elements of the future.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("envir"), list(
#&gt;                   "The ", list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n"), "\n", list("\n", "An object of class ", 
#&gt;                 list("ConstantFuture"), ".\n"), "\n", list("\n", 
#&gt;                 "A constant future is a future whose expression is a constant\n", 
#&gt;                 "and therefore by definition is already resolved upon creation.\n"), 
#&gt;             "\n", list("internal"), "\n"), `Future-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/Future-class.R", 
#&gt;             "\n", list("Future-class"), "\n", list("Future-class"), 
#&gt;             "\n", list("Future"), "\n", list("A future represents a value that will be available at some point in the future"), 
#&gt;             "\n", list("\n", "Future(\n", "  expr = NULL,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  substitute = TRUE,\n", 
#&gt;                 "  stdout = TRUE,\n", "  conditions = \"condition\",\n", 
#&gt;                 "  globals = NULL,\n", "  packages = NULL,\n", 
#&gt;                 "  seed = FALSE,\n", "  lazy = FALSE,\n", "  local = TRUE,\n", 
#&gt;                 "  gc = FALSE,\n", "  earlySignal = FALSE,\n", 
#&gt;                 "  label = NULL,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An ", list(), 
#&gt;                 " ", list("expression"), ".")), "\n", "\n", list(
#&gt;                 list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("stdout"), list("If TRUE (default), then the standard output is captured,\n", 
#&gt;                   "and re-outputted when ", list("value()"), 
#&gt;                   " is called.\n", "If FALSE, any output is silenced (by sinking it to the null device as\n", 
#&gt;                   "it is outputted).\n", "If NA (not recommended), output is ", 
#&gt;                   list("not"), " intercepted.")), "\n", "\n", 
#&gt;                 list(list("conditions"), list("A character string of conditions classes to be captured\n", 
#&gt;                   "and relayed.  The default is to relay messages and warnings.\n", 
#&gt;                   "To not intercept any types of conditions, use ", 
#&gt;                   list("conditions = NULL"), ".\n", "Attribute ", 
#&gt;                   list("exclude"), " can be used to ignore specific classes, e.g.\n", 
#&gt;                   list("conditions = structure(\"condition\", exclude = \"message\")"), 
#&gt;                   " will capture\n", "all ", list("condition"), 
#&gt;                   " classes except those that inherits from the ", 
#&gt;                   list("message"), " class.\n", "Errors are always relayed.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("packages"), list(
#&gt;                   "(optional) a character vector specifying packages\n", 
#&gt;                   "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("seed"), list("(optional) If TRUE, the random seed, that is, the state of the\n", 
#&gt;                   "random number generator (RNG) will be set such that statistically sound\n", 
#&gt;                   "random numbers are produced (also during parallelization).\n", 
#&gt;                   "If FALSE (default), it is assumed that the future expression does neither\n", 
#&gt;                   "need nor use random numbers generation.\n", 
#&gt;                   "To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\n", 
#&gt;                   "or a regular RNG seed (a single integer).  If the latter, then a\n", 
#&gt;                   "L'Ecuyer-CMRG seed will be automatically created based on the given seed.\n", 
#&gt;                   "Furthermore, if FALSE, then the future will be monitored to make sure it\n", 
#&gt;                   "does not use random numbers.  If it does and depending on the value of\n", 
#&gt;                   "option ", list(list("future.rng.onMisuse")), 
#&gt;                   ", the check is\n", "ignored, an informative warning, or error will be produced.\n", 
#&gt;                   "If ", list("seed"), " is NULL, then the effect is as with ", 
#&gt;                   list("seed = FALSE"), "\n", "but without the RNG check being performed.")), 
#&gt;                 "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                 "\n", "\n", list(list("local"), list("If TRUE, the expression is evaluated such that\n", 
#&gt;                   "all assignments are done to local temporary environment, otherwise\n", 
#&gt;                   "the assignments are done to the global environment of the ", 
#&gt;                   list(), " process\n", "evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("gc"), list("If TRUE, the garbage collector run (in the process that\n", 
#&gt;                   "evaluated the future) only after the value of the future is collected.\n", 
#&gt;                   "Exactly when the values are collected may depend on various factors such\n", 
#&gt;                   "as number of free workers and whether ", list(
#&gt;                     "earlySignal"), " is TRUE (more\n", "frequently) or FALSE (less frequently).\n", 
#&gt;                   list("Some types of futures ignore this argument."))), 
#&gt;                 "\n", "\n", list(list("earlySignal"), list("Specified whether conditions should be signaled as soon\n", 
#&gt;                   "as possible or not.")), "\n", "\n", list(list(
#&gt;                   "label"), list("An optional character string label attached to the future.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Additional named elements of the future.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class ", 
#&gt;                 list("Future"), ".\n"), "\n", list("\n", "A ", 
#&gt;                 list("future"), " is an abstraction for a ", 
#&gt;                 list("value"), " that may\n", "available at some point in the future.  A future can either be\n", 
#&gt;                 list("unresolved"), " or ", list("resolved"), 
#&gt;                 ", a state which can be checked\n", "with ", 
#&gt;                 list(list("resolved()")), ".  As long as it is ", 
#&gt;                 list("unresolved"), ", the\n", "value is not available.  As soon as it is ", 
#&gt;                 list("resolved"), ", the value\n", "is available via ", 
#&gt;                 list(list("value"), "()"), ".\n"), "\n", list(
#&gt;                 "\n", "A Future object is itself an ", list("environment"), 
#&gt;                 ".\n"), "\n", list("\n", "One function that creates a Future is ", 
#&gt;                 list(list("future()")), ".\n", "It returns a Future that evaluates an ", 
#&gt;                 list(), " expression in the future.\n", "An alternative approach is to use the ", 
#&gt;                 list(list("%&lt;-%")), " infix\n", "assignment operator, which creates a future from the\n", 
#&gt;                 "right-hand-side (RHS) ", list(), " expression and assigns its future value\n", 
#&gt;                 "to a variable as a ", list(list("promise")), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), FutureCondition.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/FutureCondition-class.R", 
#&gt;             "\n", list("FutureCondition"), "\n", list("FutureCondition"), 
#&gt;             "\n", list("FutureMessage"), "\n", list("FutureWarning"), 
#&gt;             "\n", list("FutureError"), "\n", list("RngFutureCondition"), 
#&gt;             "\n", list("RngFutureWarning"), "\n", list("RngFutureError"), 
#&gt;             "\n", list("UnexpectedFutureResultError"), "\n", 
#&gt;             list("A condition (message, warning, or error) that occurred while orchestrating a future"), 
#&gt;             "\n", list("\n", "FutureCondition(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "FutureMessage(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "FutureWarning(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "FutureError(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "RngFutureCondition(\n", "  message = NULL,\n", 
#&gt;                 "  call = NULL,\n", "  uuid = future$uuid,\n", 
#&gt;                 "  future = NULL\n", ")\n", "\n", "RngFutureWarning(...)\n", 
#&gt;                 "\n", "RngFutureError(...)\n", "\n", "UnexpectedFutureResultError(future, hint = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("message"), list("A message condition.")), 
#&gt;                 "\n", "\n", list(list("call"), list("The call stack that led up to the condition.")), 
#&gt;                 "\n", "\n", list(list("uuid"), list("A universally unique identifier for the future associated with\n", 
#&gt;                   "this FutureCondition.")), "\n", "\n", list(
#&gt;                   list("future"), list("The ", list("Future"), 
#&gt;                     " involved.")), "\n", "\n", list(list("hint"), 
#&gt;                   list("(optional) A string with a suggestion on what might be wrong.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class FutureCondition which inherits from class\n", 
#&gt;                 list("condition"), " and FutureMessage, FutureWarning,\n", 
#&gt;                 "and FutureError all inherits from FutureCondition.\n", 
#&gt;                 "Moreover, a FutureError inherits from ", list(
#&gt;                   "error"), ",\n", "a FutureWarning from ", list(
#&gt;                   "warning"), ", and\n", "a FutureMessage from ", 
#&gt;                 list("message"), ".\n"), "\n", list("\n", "While ", 
#&gt;                 list("orchestrating"), " (creating, launching, querying, collection)\n", 
#&gt;                 "futures, unexpected run-time errors (and other types of conditions) may\n", 
#&gt;                 "occur.  Such conditions are coerced to a corresponding FutureCondition\n", 
#&gt;                 "class to help distinguish them from conditions that occur due to the\n", 
#&gt;                 list("evaluation"), " of the future.\n"), "\n", 
#&gt;             list("internal"), "\n"), FutureGlobals.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/FutureGlobals-class.R", 
#&gt;             "\n", list("FutureGlobals"), "\n", list("FutureGlobals"), 
#&gt;             "\n", list("as.FutureGlobals"), "\n", list("as.FutureGlobals.FutureGlobals"), 
#&gt;             "\n", list("as.FutureGlobals.Globals"), "\n", list(
#&gt;                 "as.FutureGlobals.list"), "\n", list("[.FutureGlobals"), 
#&gt;             "\n", list("c.FutureGlobals"), "\n", list("unique.FutureGlobals"), 
#&gt;             "\n", list("A representation of a set of globals used with futures"), 
#&gt;             "\n", list("\n", "FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)\n"), 
#&gt;             "\n", list("\n", list(list("object"), list("A named list.")), 
#&gt;                 "\n", "\n", list(list("resolved"), list("A logical indicating whether these globals\n", 
#&gt;                   "have been scanned for and resolved futures or not.")), 
#&gt;                 "\n", "\n", list(list("total_size"), list("The total size of all globals, if known.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class ", 
#&gt;                 list("FutureGlobals"), ".\n"), "\n", list("\n", 
#&gt;                 "A representation of a set of globals used with futures\n"), 
#&gt;             "\n", list("\n", "This class extends the ", list(
#&gt;                 "Globals"), " class by adding\n", "attributes ", 
#&gt;                 list("resolved"), " and ", list("total_size"), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), FutureResult.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/FutureResult-class.R", 
#&gt;             "\n", list("FutureResult"), "\n", list("FutureResult"), 
#&gt;             "\n", list("as.character.FutureResult"), "\n", list(
#&gt;                 "print.FutureResult"), "\n", list("Results from resolving a future"), 
#&gt;             "\n", list("\n", "FutureResult(\n", "  value = NULL,\n", 
#&gt;                 "  visible = TRUE,\n", "  stdout = NULL,\n", 
#&gt;                 "  conditions = NULL,\n", "  rng = FALSE,\n", 
#&gt;                 "  ...,\n", "  started = .POSIXct(NA_real_),\n", 
#&gt;                 "  finished = Sys.time(),\n", "  version = \"1.8\"\n", 
#&gt;                 ")\n", "\n", list(list("as.character"), list(
#&gt;                   "FutureResult")), "(x, ...)\n", "\n", list(
#&gt;                   list("print"), list("FutureResult")), "(x, ...)\n"), 
#&gt;             "\n", list("\n", list(list("value"), list("The value of the future expression.\n", 
#&gt;                 "If the expression was not fully resolved (e.g. an error) occurred,\n", 
#&gt;                 "the the value is ", list("NULL"), ".")), "\n", 
#&gt;                 "\n", list(list("visible"), list("If TRUE, the value was visible, otherwise invisible.")), 
#&gt;                 "\n", "\n", list(list("conditions"), list("A list of zero or more list elements each containing\n", 
#&gt;                   "a captured ", list("condition"), " and possibly more meta data such as the\n", 
#&gt;                   "call stack and a timestamp.")), "\n", "\n", 
#&gt;                 list(list("rng"), list("If TRUE, the ", list(
#&gt;                   ".Random.seed"), " was updated from resolving the\n", 
#&gt;                   "future, otherwise not.")), "\n", "\n", list(
#&gt;                   list(list()), list("(optional) Additional named results to be returned.")), 
#&gt;                 "\n", "\n", list(list("started, finished"), list(
#&gt;                   list("POSIXct"), " timestamps\n", "when the evaluation of the future expression was started and finished.")), 
#&gt;                 "\n", "\n", list(list("version"), list("The version format of the results.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class FutureResult.\n"), 
#&gt;             "\n", list("\n", "Results from resolving a future\n"), 
#&gt;             "\n", list("\n", "This function is only part of the ", 
#&gt;                 list("backend"), " Future API.\n", "This function is ", 
#&gt;                 list("not"), " part of the frontend Future API.\n"), 
#&gt;             "\n", list(list("Note to developers"), list("\n", 
#&gt;                 "\n", "The FutureResult structure is ", list(
#&gt;                   "under development"), " and may change at anytime,\n", 
#&gt;                 "e.g. elements may be renamed or removed.  Because of this, please avoid\n", 
#&gt;                 "accessing the elements directly in code.  Feel free to reach out if you need\n", 
#&gt;                 "to do so in your code.\n")), "\n", "\n", list(
#&gt;                 "internal"), "\n"), `MulticoreFuture-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/MulticoreFuture-class.R", 
#&gt;             "\n", list("MulticoreFuture-class"), "\n", list("MulticoreFuture-class"), 
#&gt;             "\n", list("MulticoreFuture"), "\n", list("A multicore future is a future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "MulticoreFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  substitute = TRUE,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  globals = TRUE,\n", "  lazy = FALSE,\n", "  ...\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("expr"), list(
#&gt;                 "An ", list(), " ", list("expression"), ".")), 
#&gt;                 "\n", "\n", list(list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("lazy"), list(
#&gt;                   "If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "An object of class ", list("MulticoreFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "A multicore future is a future whose value will be resolved asynchronously in a parallel process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"multicore future\", see function\n", 
#&gt;                 list(list("multicore()")), ".\n"), "\n", list(
#&gt;                 "internal"), "\n"), `MultiprocessFuture-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/MultiprocessFuture-class.R", 
#&gt;             "\n", list("MultiprocessFuture-class"), "\n", list(
#&gt;                 "MultiprocessFuture-class"), "\n", list("MultiprocessFuture"), 
#&gt;             "\n", list("A multiprocess future is a future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An ", list(), 
#&gt;                 " ", list("expression"), ".")), "\n", "\n", list(
#&gt;                 list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "An object of class ", list("MultiprocessFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"multiprocess future\", see function\n", 
#&gt;                 list(list("multiprocess()")), ".\n"), "\n", list(
#&gt;                 "internal"), "\n"), `UniprocessFuture-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/UniprocessFuture-class.R", 
#&gt;             "\n", list("UniprocessFuture-class"), "\n", list(
#&gt;                 "UniprocessFuture-class"), "\n", list("UniprocessFuture"), 
#&gt;             "\n", list("SequentialFuture"), "\n", list("TransparentFuture"), 
#&gt;             "\n", list("An uniprocess future is a future whose value will be resolved synchronously in the current process"), 
#&gt;             "\n", list("\n", "UniprocessFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  substitute = TRUE,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  globals = TRUE,\n", "  packages = NULL,\n", 
#&gt;                 "  lazy = FALSE,\n", "  local = TRUE,\n", "  ...\n", 
#&gt;                 ")\n", "\n", "SequentialFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  substitute = TRUE,\n", 
#&gt;                 "  lazy = FALSE,\n", "  globals = TRUE,\n", "  local = TRUE,\n", 
#&gt;                 "  ...\n", ")\n", "\n", "TransparentFuture(\n", 
#&gt;                 "  expr = NULL,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  substitute = TRUE,\n", "  lazy = FALSE,\n", 
#&gt;                 "  globals = TRUE,\n", "  local = FALSE,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "expr"), list("An ", list(), " ", list("expression"), 
#&gt;                 ".")), "\n", "\n", list(list("substitute"), list(
#&gt;                 "If TRUE, argument ", list("expr"), " is\n", 
#&gt;                 list(list("substitute"), "()"), ":ed, otherwise not.")), 
#&gt;                 "\n", "\n", list(list("envir"), list("The ", 
#&gt;                   list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n", "\n", list(list("globals"), 
#&gt;                   list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                     "to control how globals are handled.\n", 
#&gt;                     "For details, see section 'Globals used by future expressions'\n", 
#&gt;                     "in the help for ", list(list("future()")), 
#&gt;                     ".")), "\n", "\n", list(list("packages"), 
#&gt;                   list("(optional) a character vector specifying packages\n", 
#&gt;                     "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                 "\n", "\n", list(list("local"), list("If TRUE, the expression is evaluated such that\n", 
#&gt;                   "all assignments are done to local temporary environment, otherwise\n", 
#&gt;                   "the assignments are done to the global environment of the ", 
#&gt;                   list(), " process\n", "evaluating the future.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "An object of class ", list("UniprocessFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "An uniprocess future is a future whose value will be resolved synchronously in the current process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"uniprocess future\", see functions\n", 
#&gt;                 list(list("uniprocess()")), ".\n"), "\n", list(
#&gt;                 "internal"), "\n"), as_lecyer_cmrg_seed.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/rng.R", "\n", list(
#&gt;                 "as_lecyer_cmrg_seed"), "\n", list("as_lecyer_cmrg_seed"), 
#&gt;             "\n", list("is_lecyer_cmrg_seed"), "\n", list("Get a L'Ecuyer-CMRG seed either from an input seed or the current RNG state"), 
#&gt;             "\n", list("\n", "as_lecyer_cmrg_seed(seed)\n", "\n", 
#&gt;                 "is_lecyer_cmrg_seed(seed)\n"), "\n", list("\n", 
#&gt;                 list(list("seed"), list("TRUE or NA, or a numeric vector of length one or seven.")), 
#&gt;                 "\n"), "\n", list("\n", list("as_lecyer_cmrg_seed(seed)"), 
#&gt;                 " returns a L'Ecuyer-CMRG seed, which is a\n", 
#&gt;                 "7-digit integer vector, based on the input ", 
#&gt;                 list("seed"), ".\n", "If already a L'Ecuyer-CMRG seed, then ", 
#&gt;                 list("seed"), " is return as-is.\n", "If a scalar integer, then a random L'Ecuyer-CMRG seed is created based\n", 
#&gt;                 "on this seed as the current RNG state.\n", "If ", 
#&gt;                 list("seed = TRUE"), " and the current seed is already a L'Ecuyer-CMRG seed,\n", 
#&gt;                 "then then current seed (", list(".Random.seed"), 
#&gt;                 ") is return as-is.\n", "If ", list("seed = TRUE"), 
#&gt;                 " and the current seed is ", list("not"), " of the 'L'Ecuyer-CMRG' kind,\n", 
#&gt;                 "or ", list("seed = NA"), ", then a random one is created (based on the current RNG\n", 
#&gt;                 "state).\n", "Any other values, including FALSE, is an error.\n", 
#&gt;                 "\n", list("is_lecyer_cmrg_seed(seed)"), " returns TRUE if ", 
#&gt;                 list("seed"), " is L'Ecuyer-CMRG seed,\n", "otherwise FALSE.\n"), 
#&gt;             "\n", list("\n", "Get a L'Ecuyer-CMRG seed either from an input seed or the current RNG state\n"), 
#&gt;             "\n", list("\n", "The ", list("as_lecyer_cmrg_seed()"), 
#&gt;                 " function preserves the current RNG state, that\n", 
#&gt;                 "is, it leaves ", list("globalenv()$.Random.seed"), 
#&gt;                 " intact, which means it also leaved\n", "the RNG kind (", 
#&gt;                 list("RNGkind()"), ") intact.\n", "\n", "Per ", 
#&gt;                 list(list("base::RNGkind()")), ", a L'Ecuyer-CMRG seed comprise a length-seven integer\n", 
#&gt;                 "vector of format ", list(".Random.seed &lt;- c(rng.kind, n)"), 
#&gt;                 " where ", list("length(n) == 6L"), " and ", 
#&gt;                 list("rng.kind"), " fulfills ", list("rng.kind %% 10000L == 407L"), 
#&gt;                 ".\n"), "\n", list("\n", "# The current RNG kind\n", 
#&gt;                 "okind &lt;- RNGkind()\n", "oseed &lt;- globalenv()$.Random.seed\n", 
#&gt;                 "\n", "# (a) A L'Ecuyer-CMRG seed based on a numeric-scalar seed\n", 
#&gt;                 "seed1 &lt;- future:::as_lecyer_cmrg_seed(42)\n", 
#&gt;                 "str(seed1)\n", "## int [1:7] 10407 -2133391687 507561766 1260545903 1362917092 -1772566379 -1344458670\n", 
#&gt;                 "# The RNG kind and the RNG state is preserved\n", 
#&gt;                 "stopifnot(\n", "  future:::is_lecyer_cmrg_seed(seed1),\n", 
#&gt;                 "  identical(RNGkind(), okind),\n", "  identical(globalenv()$.Random.seed, oseed)\n", 
#&gt;                 ")\n", "\n", "# (b) A L'Ecuyer-CMRG seed based on a L'Ecuyer-CMRG seed\n", 
#&gt;                 "seed2 &lt;- future:::as_lecyer_cmrg_seed(seed1)\n", 
#&gt;                 "str(seed2)\n", "## int [1:7] 10407 -2133391687 507561766 1260545903 1362917092 -1772566379 -1344458670\n", 
#&gt;                 "# The input L'Ecuyer-CMRG seed is returned as-is\n", 
#&gt;                 "stopifnot(identical(seed2, seed1))\n", "# The RNG kind and the RNG state is preserved\n", 
#&gt;                 "stopifnot(\n", "  future:::is_lecyer_cmrg_seed(seed2),\n", 
#&gt;                 "  identical(RNGkind(), okind),\n", "  identical(globalenv()$.Random.seed, oseed)\n", 
#&gt;                 ")\n", "\n", "# (c) A L'Ecuyer-CMRG seed based on the current RNG state\n", 
#&gt;                 "seed3 &lt;- future:::as_lecyer_cmrg_seed(TRUE)\n", 
#&gt;                 "str(seed3)\n", "## int [1:7] 10407 495333909 -1491719214 416071979 49340016 1956499377 899435966\n", 
#&gt;                 "stopifnot(future:::is_lecyer_cmrg_seed(seed3))\n", 
#&gt;                 "\n", "\n", "# All of the above calls preserve the RNG state including the RNG kind\n", 
#&gt;                 "stopifnot(\n", "  identical(RNGkind(), okind),\n", 
#&gt;                 "  identical(globalenv()$.Random.seed, oseed)\n", 
#&gt;                 ")\n"), "\n", list("internal"), "\n"), backtrace.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/backtrace.R", "\n", 
#&gt;             list("backtrace"), "\n", list("backtrace"), "\n", 
#&gt;             list("Back trace the expressions evaluated when an error was caught"), 
#&gt;             "\n", list("\n", "backtrace(future, envir = parent.frame(), ...)\n"), 
#&gt;             "\n", list("\n", list(list("future"), list("A future with a caught error.")), 
#&gt;                 "\n", "\n", list(list("envir"), list("the environment where to locate the future.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                 "\n"), "\n", list("\n", "A list with the future's call stack that led up to the error.\n"), 
#&gt;             "\n", list("\n", "Back trace the expressions evaluated when an error was caught\n"), 
#&gt;             "\n", list("\n", "my_log &lt;- function(x) log(x)\n", 
#&gt;                 "foo &lt;- function(...) my_log(...)\n", "\n", "f &lt;- future({ foo(\"a\") })\n", 
#&gt;                 "res &lt;- tryCatch({\n", "  v &lt;- value(f)\n", "}, error = function(ex) {\n", 
#&gt;                 "  t &lt;- backtrace(f)\n", "  print(t)\n", "})\n", 
#&gt;                 list("\n", "## R CMD check: make sure any open connections are closed afterward\n", 
#&gt;                   "if (!inherits(plan(\"next\"), \"sequential\")) plan(sequential)\n"), 
#&gt;                 "\n", "\n"), "\n"), cluster.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cluster.R", 
#&gt;             "\n", list("cluster"), "\n", list("cluster"), "\n", 
#&gt;             list("Create a cluster future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "cluster(..., workers = availableWorkers(), envir = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list(list()), list("Additional named elements passed to ", 
#&gt;                 list(list("ClusterFuture()")), ".")), "\n", "\n", 
#&gt;                 list(list("workers"), list("A ", list(list("cluster")), 
#&gt;                   " object,\n", "a character vector of host names, a positive numeric scalar,\n", 
#&gt;                   "or a function.\n", "If a character vector or a numeric scalar, a ", 
#&gt;                   list("cluster"), " object\n", "is created using ", 
#&gt;                   list(list("makeClusterPSOCK"), "(workers)"), 
#&gt;                   ".\n", "If a function, it is called without arguments ", 
#&gt;                   list("when the future\n", "is created"), " and its value is used to configure the workers.\n", 
#&gt;                   "The function should return any of the above types.")), 
#&gt;                 "\n", "\n", list(list("envir"), list("The ", 
#&gt;                   list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n"), "\n", list("\n", "A ", 
#&gt;                 list("ClusterFuture"), ".\n"), "\n", list("\n", 
#&gt;                 "A cluster future is a future that uses cluster evaluation,\n", 
#&gt;                 "which means that its ", list("value is computed and resolved in\n", 
#&gt;                   "parallel in another process"), ".\n"), "\n", 
#&gt;             list("\n", "This function is ", list("not"), " meant to be called directly.  Instead, the\n", 
#&gt;                 "typical usages are:", list(list("html"), list(
#&gt;                   list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures via a single background R process on the local machine\n", 
#&gt;                   "plan(cluster, workers = 1)\n", "\n", "# Evaluate futures via two background R processes on the local machine\n", 
#&gt;                   "plan(cluster, workers = 2)\n", "\n", "# Evaluate futures via a single R process on another machine on on the\n", 
#&gt;                   "# local area network (LAN)\n", "plan(cluster, workers = \"raspberry-pi\")\n", 
#&gt;                   "\n", "# Evaluate futures via a single R process running on a remote machine\n", 
#&gt;                   "plan(cluster, workers = \"pi.example.org\")\n", 
#&gt;                   "\n", "# Evaluate futures via four R processes, one running on the local machine,\n", 
#&gt;                   "# two running on LAN machine 'n1' and one on a remote machine\n", 
#&gt;                   "plan(cluster, workers = c(\"localhost\", \"n1\", \"n1\", \"pi.example.org\")\n"), 
#&gt;                 list(list("html"), list(list("&lt;/div&gt;"))), "\n"), 
#&gt;             "\n", list("\n", list("\n", "\n", "## Use cluster futures\n", 
#&gt;                 "cl &lt;- parallel::makeCluster(2, timeout = 60)\n", 
#&gt;                 "plan(cluster, workers = cl)\n", "\n", "## A global variable\n", 
#&gt;                 "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                 "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                 "  a * b * c\n", "})\n", "\n", "## A cluster future is evaluated in a separate process.\n", 
#&gt;                 "## Regardless, changing the value of a global variable will\n", 
#&gt;                 "## not affect the result of the future.\n", 
#&gt;                 "a &lt;- 7\n", "print(a)\n", "\n", "v &lt;- value(f)\n", 
#&gt;                 "print(v)\n", "stopifnot(v == 0)\n", "\n", "## CLEANUP\n", 
#&gt;                 "parallel::stopCluster(cl)\n", "\n"), "\n"), 
#&gt;             "\n"), clusterExportSticky.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sticky_globals.R", 
#&gt;             "\n", list("clusterExportSticky"), "\n", list("clusterExportSticky"), 
#&gt;             "\n", list("Export globals to the sticky-globals environment of the cluster nodes"), 
#&gt;             "\n", list("\n", "clusterExportSticky(cl, globals)\n"), 
#&gt;             "\n", list("\n", list(list("cl"), list("(cluster) A cluster object as returned by\n", 
#&gt;                 list(list("parallel::makeCluster()")), ".")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(list) A named list of sticky globals to be exported.")), 
#&gt;                 "\n"), "\n", list("\n", "(invisible; cluster) The cluster object.\n"), 
#&gt;             "\n", list("\n", "Export globals to the sticky-globals environment of the cluster nodes\n"), 
#&gt;             "\n", list("\n", "This requires that the ", list(
#&gt;                 "future"), " package is installed on the cluster\n", 
#&gt;                 "nodes.\n"), "\n", list("internals"), "\n"), 
#&gt;             find_references.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils-marshalling.R", 
#&gt;                 "\n", list("find_references"), "\n", list("find_references"), 
#&gt;                 "\n", list("assert_no_references"), "\n", list(
#&gt;                   "Get the first or all references of an ", list(), 
#&gt;                   " object"), "\n", list("\n", "find_references(x, first_only = FALSE)\n", 
#&gt;                   "\n", "assert_no_references(\n", "  x,\n", 
#&gt;                   "  action = c(\"error\", \"warning\", \"message\", \"string\"),\n", 
#&gt;                   "  source = c(\"globals\", \"value\")\n", ")\n"), 
#&gt;                 "\n", list("\n", list(list("x"), list("The ", 
#&gt;                   list(), " object to be checked.")), "\n", "\n", 
#&gt;                   list(list("first_only"), list("If ", list("TRUE"), 
#&gt;                     ", only the first reference is returned,\n", 
#&gt;                     "otherwise all references.")), "\n", "\n", 
#&gt;                   list(list("action"), list("Type of action to take if a reference is found.")), 
#&gt;                   "\n", "\n", list(list("source"), list("Is the source of ", 
#&gt;                     list("x"), " the globals or the value of the future?")), 
#&gt;                   "\n"), "\n", list("\n", list("find_references()"), 
#&gt;                   " returns a list of zero or more references\n", 
#&gt;                   "identified.\n", "\n", "If a reference is detected, an informative error, warning, message,\n", 
#&gt;                   "or a character string is produced, otherwise ", 
#&gt;                   list("NULL"), " is returned\n", "invisibly.\n"), 
#&gt;                 "\n", list("\n", "Get the first or all references of an ", 
#&gt;                   list(), " object\n", "\n", "Assert that there are no references among the identified globals\n"), 
#&gt;                 "\n", list("internal"), "\n"), future.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/future.R, R/futureAssign.R,", 
#&gt;                 "\n", "%   R/futureAssign_OP.R, R/futureCall.R", 
#&gt;                 "\n", list("future"), "\n", list("future"), "\n", 
#&gt;                 list("futureCall"), "\n", list("futureAssign"), 
#&gt;                 "\n", list("%&lt;-%"), "\n", list("%-&gt;%"), "\n", 
#&gt;                 list("Create a future"), "\n", list("\n", "future(\n", 
#&gt;                   "  expr,\n", "  envir = parent.frame(),\n", 
#&gt;                   "  substitute = TRUE,\n", "  lazy = FALSE,\n", 
#&gt;                   "  seed = FALSE,\n", "  globals = TRUE,\n", 
#&gt;                   "  packages = NULL,\n", "  stdout = TRUE,\n", 
#&gt;                   "  conditions = \"condition\",\n", "  earlySignal = FALSE,\n", 
#&gt;                   "  label = NULL,\n", "  gc = FALSE,\n", "  ...\n", 
#&gt;                   ")\n", "\n", "futureAssign(\n", "  x,\n", "  value,\n", 
#&gt;                   "  envir = parent.frame(),\n", "  substitute = TRUE,\n", 
#&gt;                   "  lazy = FALSE,\n", "  seed = FALSE,\n", "  globals = TRUE,\n", 
#&gt;                   "  packages = NULL,\n", "  stdout = TRUE,\n", 
#&gt;                   "  conditions = \"condition\",\n", "  earlySignal = FALSE,\n", 
#&gt;                   "  label = NULL,\n", "  gc = FALSE,\n", "  ...,\n", 
#&gt;                   "  assign.env = envir\n", ")\n", "\n", "x %&lt;-% value\n", 
#&gt;                   "\n", "futureCall(\n", "  FUN,\n", "  args = list(),\n", 
#&gt;                   "  envir = parent.frame(),\n", "  lazy = FALSE,\n", 
#&gt;                   "  seed = FALSE,\n", "  globals = TRUE,\n", 
#&gt;                   "  packages = NULL,\n", "  stdout = TRUE,\n", 
#&gt;                   "  conditions = \"condition\",\n", "  earlySignal = FALSE,\n", 
#&gt;                   "  label = NULL,\n", "  gc = FALSE,\n", "  ...\n", 
#&gt;                   ")\n"), "\n", list("\n", list(list("expr, value"), 
#&gt;                   list("An ", list(), " ", list("expression"), 
#&gt;                     ".")), "\n", "\n", list(list("envir"), list(
#&gt;                   "The ", list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n", "\n", list(list("substitute"), 
#&gt;                   list("If TRUE, argument ", list("expr"), " is\n", 
#&gt;                     list(list("substitute"), "()"), ":ed, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                     "eagerly (starting immediately), otherwise not.")), 
#&gt;                   "\n", "\n", list(list("seed"), list("(optional) If TRUE, the random seed, that is, the state of the\n", 
#&gt;                     "random number generator (RNG) will be set such that statistically sound\n", 
#&gt;                     "random numbers are produced (also during parallelization).\n", 
#&gt;                     "If FALSE (default), it is assumed that the future expression does neither\n", 
#&gt;                     "need nor use random numbers generation.\n", 
#&gt;                     "To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\n", 
#&gt;                     "or a regular RNG seed (a single integer).  If the latter, then a\n", 
#&gt;                     "L'Ecuyer-CMRG seed will be automatically created based on the given seed.\n", 
#&gt;                     "Furthermore, if FALSE, then the future will be monitored to make sure it\n", 
#&gt;                     "does not use random numbers.  If it does and depending on the value of\n", 
#&gt;                     "option ", list(list("future.rng.onMisuse")), 
#&gt;                     ", the check is\n", "ignored, an informative warning, or error will be produced.\n", 
#&gt;                     "If ", list("seed"), " is NULL, then the effect is as with ", 
#&gt;                     list("seed = FALSE"), "\n", "but without the RNG check being performed.")), 
#&gt;                   "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                     "to control how globals are handled.\n", 
#&gt;                     "For details, see section 'Globals used by future expressions'\n", 
#&gt;                     "in the help for ", list(list("future()")), 
#&gt;                     ".")), "\n", "\n", list(list("packages"), 
#&gt;                     list("(optional) a character vector specifying packages\n", 
#&gt;                       "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                   "\n", "\n", list(list("stdout"), list("If TRUE (default), then the standard output is captured,\n", 
#&gt;                     "and re-outputted when ", list("value()"), 
#&gt;                     " is called.\n", "If FALSE, any output is silenced (by sinking it to the null device as\n", 
#&gt;                     "it is outputted).\n", "If NA (not recommended), output is ", 
#&gt;                     list("not"), " intercepted.")), "\n", "\n", 
#&gt;                   list(list("conditions"), list("A character string of conditions classes to be captured\n", 
#&gt;                     "and relayed.  The default is to relay messages and warnings.\n", 
#&gt;                     "To not intercept any types of conditions, use ", 
#&gt;                     list("conditions = NULL"), ".\n", "Attribute ", 
#&gt;                     list("exclude"), " can be used to ignore specific classes, e.g.\n", 
#&gt;                     list("conditions = structure(\"condition\", exclude = \"message\")"), 
#&gt;                     " will capture\n", "all ", list("condition"), 
#&gt;                     " classes except those that inherits from the ", 
#&gt;                     list("message"), " class.\n", "Errors are always relayed.")), 
#&gt;                   "\n", "\n", list(list("earlySignal"), list(
#&gt;                     "Specified whether conditions should be signaled as soon\n", 
#&gt;                     "as possible or not.")), "\n", "\n", list(
#&gt;                     list("label"), list("An optional character string label attached to the future.")), 
#&gt;                   "\n", "\n", list(list("gc"), list("If TRUE, the garbage collector run (in the process that\n", 
#&gt;                     "evaluated the future) only after the value of the future is collected.\n", 
#&gt;                     "Exactly when the values are collected may depend on various factors such\n", 
#&gt;                     "as number of free workers and whether ", 
#&gt;                     list("earlySignal"), " is TRUE (more\n", 
#&gt;                     "frequently) or FALSE (less frequently).\n", 
#&gt;                     list("Some types of futures ignore this argument."))), 
#&gt;                   "\n", "\n", list(list(list()), list("Additional arguments passed to ", 
#&gt;                     list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("x"), list("the name of a future variable, which will hold the value\n", 
#&gt;                     "of the future expression (as a promise).")), 
#&gt;                   "\n", "\n", list(list("assign.env"), list("The ", 
#&gt;                     list("environment"), " to which the variable\n", 
#&gt;                     "should be assigned.")), "\n", "\n", list(
#&gt;                     list("FUN"), list("A ", list("function"), 
#&gt;                       " to be evaluated.")), "\n", "\n", list(
#&gt;                     list("args"), list("A ", list("list"), " of arguments passed to function ", 
#&gt;                       list("FUN"), ".")), "\n"), "\n", list("\n", 
#&gt;                   list("f &lt;- future(expr)"), " creates a ", list(
#&gt;                     "Future"), " ", list("f"), " that evaluates expression ", 
#&gt;                   list("expr"), ", the value of the future is retrieved using ", 
#&gt;                   list("v &lt;- value(f)"), ".\n", "\n", list("x %&lt;-% value"), 
#&gt;                   " (a future assignment) and\n", list("futureAssign(\"x\", value)"), 
#&gt;                   " create a ", list("Future"), " that evaluates\n", 
#&gt;                   "expression ", list("expr"), " and binds its value (as a\n", 
#&gt;                   list("promise"), ") to\n", "a variable ", list(
#&gt;                     "x"), ".  The value of the future is automatically retrieved\n", 
#&gt;                   "when the assigned variable (promise) is queried.\n", 
#&gt;                   "The future itself is returned invisibly, e.g.\n", 
#&gt;                   list("f &lt;- futureAssign(\"x\", expr)"), " and ", 
#&gt;                   list("f &lt;- (x %&lt;-% expr)"), ".\n", "Alternatively, the future of a future variable ", 
#&gt;                   list("x"), " can be retrieved\n", "without blocking using ", 
#&gt;                   list("f &lt;- ", list("futureOf"), "(x)"), ".\n", 
#&gt;                   "Both the future and the variable (promise) are assigned to environment\n", 
#&gt;                   list("assign.env"), " where the name of the future is ", 
#&gt;                   list(".future_&lt;name&gt;"), ".\n", "\n", list("f &lt;- futureCall(FUN, args)"), 
#&gt;                   " creates a ", list("Future"), " ", list("f"), 
#&gt;                   " that calls function ", list("FUN"), " with arguments ", 
#&gt;                   list("args"), ", where the value of the future is retrieved using ", 
#&gt;                   list("x &lt;- value(f)"), ".\n"), "\n", list("\n", 
#&gt;                   list(list("html"), list(list(list("logo.png"), 
#&gt;                     list("options: align='right' alt='logo' width='120'")))), 
#&gt;                   "\n", "Creates a future that evaluates an ", 
#&gt;                   list(), " expression or\n", "a future that calls an ", 
#&gt;                   list(), " function with a set of arguments.\n", 
#&gt;                   "How, when, and where these futures are evaluated can be configured\n", 
#&gt;                   "using ", list(list("plan()")), " such that it is evaluated in parallel on,\n", 
#&gt;                   "for instance, the current machine, on a remote machine, or via a\n", 
#&gt;                   "job queue on a compute cluster.\n", "Importantly, any ", 
#&gt;                   list(), " code using futures remains the same regardless\n", 
#&gt;                   "on these settings and there is no need to modify the code when\n", 
#&gt;                   "switching from, say, sequential to parallel processing.\n"), 
#&gt;                 "\n", list("\n", "The state of a future is either unresolved or resolved.\n", 
#&gt;                   "The value of a future can be retrieved using ", 
#&gt;                   list("v &lt;- ", list("value"), "(f)"), ".\n", 
#&gt;                   "Querying the value of a non-resolved future will ", 
#&gt;                   list("block"), " the call\n", "until the future is resolved.\n", 
#&gt;                   "It is possible to check whether a future is resolved or not\n", 
#&gt;                   "without blocking by using ", list(list("resolved"), 
#&gt;                     "(f)"), ".\n", "\n", "For a future created via a future assignment\n", 
#&gt;                   "(", list("x %&lt;-% value"), " or ", list("futureAssign(\"x\", value)"), 
#&gt;                   "), the value\n", "is bound to a promise, which when queried will internally call\n", 
#&gt;                   list(list("value()")), "  on the future and which will then be resolved\n", 
#&gt;                   "into a regular variable bound to that value.  For example, with future\n", 
#&gt;                   "assignment ", list("x %&lt;-% value"), ", the first time variable ", 
#&gt;                   list("x"), " is\n", "queried the call blocks if (and only if) the future is not yet resolved.\n", 
#&gt;                   "As soon as it is resolved, and any succeeding queries, querying ", 
#&gt;                   list("x"), "\n", "will immediately give the value.\n", 
#&gt;                   "\n", "The future assignment construct ", list(
#&gt;                     "x %&lt;-% value"), " is not a formal\n", "assignment per se, but a binary infix operator on objects ", 
#&gt;                   list("x"), "\n", "and expression ", list("value"), 
#&gt;                   ".  However, by using non-standard evaluation,\n", 
#&gt;                   "this constructs can emulate an assignment operator similar to\n", 
#&gt;                   list("x &lt;- value"), ". Due to ", list(), "'s precedence rules of operators,\n", 
#&gt;                   "future expressions often need to be explicitly bracketed, e.g.\n", 
#&gt;                   list("x %&lt;-% { a + b }"), ".\n", "\n", "The ", 
#&gt;                   list("futureCall()"), " function works analogously to\n", 
#&gt;                   list(list("do.call"), "()"), ", which calls a function with a set of\n", 
#&gt;                   "arguments.  The difference is that ", list(
#&gt;                     "do.call()"), " returns the value of\n", 
#&gt;                   "the call whereas ", list("futureCall()"), 
#&gt;                   " returns a future.\n"), "\n", list(list("Eager or lazy evaluation"), 
#&gt;                   list("\n", "\n", "By default, a future is resolved using ", 
#&gt;                     list("eager"), " evaluation\n", "(", list(
#&gt;                       "lazy = FALSE"), ").  This means that the expression starts to\n", 
#&gt;                     "be evaluated as soon as the future is created.\n", 
#&gt;                     "\n", "As an alternative, the future can be resolved using ", 
#&gt;                     list("lazy"), "\n", "evaluation (", list(
#&gt;                       "lazy = TRUE"), ").  This means that the expression\n", 
#&gt;                     "will only be evaluated when the value of the future is requested.\n", 
#&gt;                     list("Note that this means that the expression may not be evaluated\n", 
#&gt;                       "at all - it is guaranteed to be evaluated if the value is requested"), 
#&gt;                     ".\n", "\n", "For future assignments, lazy evaluation can be controlled via the\n", 
#&gt;                     list("%lazy%"), " operator, e.g. ", list(
#&gt;                       "x %&lt;-% { expr } %lazy% TRUE"), ".\n")), 
#&gt;                 "\n", "\n", list(list("Globals used by future expressions"), 
#&gt;                   list("\n", "\n", "Global objects (short ", 
#&gt;                     list("globals"), ") are objects (e.g. variables and\n", 
#&gt;                     "functions) that are needed in order for the future expression to be\n", 
#&gt;                     "evaluated while not being local objects that are defined by the future\n", 
#&gt;                     "expression. For example, in\n", list("\n", 
#&gt;                       "  a &lt;- 42\n", "  f &lt;- future({ b &lt;- 2; a * b })\n"), 
#&gt;                     "\n", "variable ", list("a"), " is a global of future assignment ", 
#&gt;                     list("f"), " whereas\n", list("b"), " is a local variable.\n", 
#&gt;                     "In order for the future to be resolved successfully (and correctly),\n", 
#&gt;                     "all globals need to be gathered when the future is created such that\n", 
#&gt;                     "they are available whenever and wherever the future is resolved.\n", 
#&gt;                     "\n", "The default behavior (", list("globals = TRUE"), 
#&gt;                     "),\n", "is that globals are automatically identified and gathered.\n", 
#&gt;                     "More precisely, globals are identified via code inspection of the\n", 
#&gt;                     "future expression ", list("expr"), " and their values are retrieved with\n", 
#&gt;                     "environment ", list("envir"), " as the starting point (basically via\n", 
#&gt;                     list("get(global, envir = envir, inherits = TRUE)"), 
#&gt;                     ").\n", list("In most cases, such automatic collection of globals is sufficient\n", 
#&gt;                       "and less tedious and error prone than if they are manually specified"), 
#&gt;                     ".\n", "\n", "However, for full control, it is also possible to explicitly specify\n", 
#&gt;                     "exactly which the globals are by providing their names as a character\n", 
#&gt;                     "vector.\n", "In the above example, we could use\n", 
#&gt;                     list("\n", "  a &lt;- 42\n", "  f &lt;- future({ b &lt;- 2; a * b }, globals = \"a\")\n"), 
#&gt;                     "\n", "\n", "Yet another alternative is to explicitly specify also their values\n", 
#&gt;                     "using a named list as in\n", list("\n", 
#&gt;                       "  a &lt;- 42\n", "  f &lt;- future({ b &lt;- 2; a * b }, globals = list(a = a))\n"), 
#&gt;                     "\n", "or\n", list("\n", "  f &lt;- future({ b &lt;- 2; a * b }, globals = list(a = 42))\n"), 
#&gt;                     "\n", "\n", "Specifying globals explicitly avoids the overhead added from\n", 
#&gt;                     "automatically identifying the globals and gathering their values.\n", 
#&gt;                     "Furthermore, if we know that the future expression does not make use\n", 
#&gt;                     "of any global variables, we can disable the automatic search for\n", 
#&gt;                     "globals by using\n", list("\n", "  f &lt;- future({ a &lt;- 42; b &lt;- 2; a * b }, globals = FALSE)\n"), 
#&gt;                     "\n", "\n", "Future expressions often make use of functions from one or more packages.\n", 
#&gt;                     "As long as these functions are part of the set of globals, the future\n", 
#&gt;                     "package will make sure that those packages are attached when the future\n", 
#&gt;                     "is resolved.  Because there is no need for such globals to be frozen\n", 
#&gt;                     "or exported, the future package will not export them, which reduces\n", 
#&gt;                     "the amount of transferred objects.\n", "For example, in\n", 
#&gt;                     list("\n", "  x &lt;- rnorm(1000)\n", "  f &lt;- future({ median(x) })\n"), 
#&gt;                     "\n", "variable ", list("x"), " and ", list(
#&gt;                       "median()"), " are globals, but only ", 
#&gt;                     list("x"), "\n", "is exported whereas ", 
#&gt;                     list("median()"), ", which is part of the ", 
#&gt;                     list("stats"), "\n", "package, is not exported.  Instead it is made sure that the ", 
#&gt;                     list("stats"), "\n", "package is on the search path when the future expression is evaluated.\n", 
#&gt;                     "Effectively, the above becomes\n", list(
#&gt;                       "\n", "  x &lt;- rnorm(1000)\n", "  f &lt;- future({\n", 
#&gt;                       "    library(\"stats\")\n", "    median(x)\n", 
#&gt;                       "  })\n"), "\n", "To manually specify this, one can either do\n", 
#&gt;                     list("\n", "  x &lt;- rnorm(1000)\n", "  f &lt;- future({\n", 
#&gt;                       "    median(x)\n", "  }, globals = list(x = x, median = stats::median)\n"), 
#&gt;                     "\n", "or\n", list("\n", "  x &lt;- rnorm(1000)\n", 
#&gt;                       "  f &lt;- future({\n", "    library(\"stats\")\n", 
#&gt;                       "    median(x)\n", "  }, globals = list(x = x))\n"), 
#&gt;                     "\n", "Both are effectively the same.\n", 
#&gt;                     "\n", "Although rarely needed, a combination of automatic identification and manual\n", 
#&gt;                     "specification of globals is supported via attributes ", 
#&gt;                     list("add"), " (to add\n", "false negatives) and ", 
#&gt;                     list("ignore"), " (to ignore false positives) on value\n", 
#&gt;                     list("TRUE"), ".  For example, with\n", list(
#&gt;                       "globals = structure(TRUE, ignore = \"b\", add = \"a\")"), 
#&gt;                     " any globals\n", "automatically identified except ", 
#&gt;                     list("b"), " will be used in addition to\n", 
#&gt;                     "global ", list("a"), ".\n", "\n", "When using future assignments, globals can be specified analogously\n", 
#&gt;                     "using the ", list(list("%globals%")), " operator, e.g.\n", 
#&gt;                     list("\n", "  x &lt;- rnorm(1000)\n", "  y %&lt;-% { median(x) } %globals% list(x = x, median = stats::median)\n"), 
#&gt;                     "\n")), "\n", "\n", list("\n", "## Evaluate futures in parallel\n", 
#&gt;                   "plan(multisession)\n", "\n", "## Data\n", 
#&gt;                   "x &lt;- rnorm(100)\n", "y &lt;- 2 * x + 0.2 + rnorm(100)\n", 
#&gt;                   "w &lt;- 1 + x ^ 2\n", "\n", "\n", "## EXAMPLE: Regular assignments (evaluated sequentially)\n", 
#&gt;                   "fitA &lt;- lm(y ~ x, weights = w)      ## with offset\n", 
#&gt;                   "fitB &lt;- lm(y ~ x - 1, weights = w)  ## without offset\n", 
#&gt;                   "fitC &lt;- {\n", "  w &lt;- 1 + abs(x)  ## Different weights\n", 
#&gt;                   "  lm(y ~ x, weights = w)\n", "}\n", "print(fitA)\n", 
#&gt;                   "print(fitB)\n", "print(fitC)\n", "\n", "\n", 
#&gt;                   "## EXAMPLE: Future assignments (evaluated in parallel)\n", 
#&gt;                   "fitA %&lt;-% lm(y ~ x, weights = w)      ## with offset\n", 
#&gt;                   "fitB %&lt;-% lm(y ~ x - 1, weights = w)  ## without offset\n", 
#&gt;                   "fitC %&lt;-% {\n", "  w &lt;- 1 + abs(x)\n", "  lm(y ~ x, weights = w)\n", 
#&gt;                   "}\n", "print(fitA)\n", "print(fitB)\n", "print(fitC)\n", 
#&gt;                   "\n", "\n", "## EXAMPLE: Explicitly create futures (evaluated in parallel)\n", 
#&gt;                   "## and retrieve their values\n", "fA &lt;- future( lm(y ~ x, weights = w) )\n", 
#&gt;                   "fB &lt;- future( lm(y ~ x - 1, weights = w) )\n", 
#&gt;                   "fC &lt;- future({\n", "  w &lt;- 1 + abs(x)\n", 
#&gt;                   "  lm(y ~ x, weights = w)\n", "})\n", "fitA &lt;- value(fA)\n", 
#&gt;                   "fitB &lt;- value(fB)\n", "fitC &lt;- value(fC)\n", 
#&gt;                   "print(fitA)\n", "print(fitB)\n", "print(fitC)\n", 
#&gt;                   "\n", list("\n", "## Make sure to \"close\" an multisession workers on Windows\n", 
#&gt;                     "plan(sequential)\n"), "\n", "## EXAMPLE: futureCall() and do.call()\n", 
#&gt;                   "x &lt;- 1:100\n", "y0 &lt;- do.call(sum, args = list(x))\n", 
#&gt;                   "print(y0)\n", "\n", "f1 &lt;- futureCall(sum, args = list(x))\n", 
#&gt;                   "y1 &lt;- value(f1)\n", "print(y1)\n"), "\n", 
#&gt;                 list("\n", "How, when and where futures are resolved is given by the\n", 
#&gt;                   list("future strategy"), ", which can be set by the end user using the\n", 
#&gt;                   list(list("plan()")), " function.  The future strategy must not be\n", 
#&gt;                   "set by the developer, e.g. it must not be called within a package.\n"), 
#&gt;                 "\n", list("\n", "The future logo was designed by Dan LaBar and tweaked by Henrik Bengtsson.\n"), 
#&gt;                 "\n"), future.options.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/options.R", 
#&gt;                 "\n", list("future.options"), "\n", list("future.options"), 
#&gt;                 "\n", list("future.cmdargs"), "\n", list(".future.R"), 
#&gt;                 "\n", list("future.startup.script"), "\n", list(
#&gt;                   "R_FUTURE_STARTUP_SCRIPT"), "\n", list("future.debug"), 
#&gt;                 "\n", list("R_FUTURE_DEBUG"), "\n", list("future.demo.mandelbrot.region"), 
#&gt;                 "\n", list("R_FUTURE_DEMO_MANDELBROT_REGION"), 
#&gt;                 "\n", list("future.demo.mandelbrot.nrow"), "\n", 
#&gt;                 list("R_FUTURE_DEMO_MANDELBROT_NROW"), "\n", 
#&gt;                 list("future.fork.multithreading.enable"), "\n", 
#&gt;                 list("R_FUTURE_FORK_MULTITHREADING_ENABLE"), 
#&gt;                 "\n", list("future.globals.maxSize"), "\n", list(
#&gt;                   "R_FUTURE_GLOBALS_MAXSIZE"), "\n", list("future.globals.method"), 
#&gt;                 "\n", list("R_FUTURE_GLOBALS_METHOD"), "\n", 
#&gt;                 list("future.globals.onMissing"), "\n", list(
#&gt;                   "R_FUTURE_GLOBALS_ONMISSING"), "\n", list("future.globals.resolve"), 
#&gt;                 "\n", list("R_FUTURE_GLOBALS_RESOLVE"), "\n", 
#&gt;                 list("future.globals.onReference"), "\n", list(
#&gt;                   "R_FUTURE_GLOBALS_ONREFERENCE"), "\n", list(
#&gt;                   "future.plan"), "\n", list("R_FUTURE_PLAN"), 
#&gt;                 "\n", list("future.resolve.recursive"), "\n", 
#&gt;                 list("R_FUTURE_RNG_ONMISUSE"), "\n", list("future.wait.alpha"), 
#&gt;                 "\n", list("R_FUTURE_WAIT_ALPHA"), "\n", list(
#&gt;                   "future.wait.interval"), "\n", list("R_FUTURE_WAIT_INTERVAL"), 
#&gt;                 "\n", list("future.wait.timeout"), "\n", list(
#&gt;                   "R_FUTURE_WAIT_TIMEOUT"), "\n", list("R_FUTURE_RESOLVED_TIMEOUT"), 
#&gt;                 "\n", list("Options used for futures"), "\n", 
#&gt;                 list("\n", "Below are the ", list(), " options and environment variables that are used by the\n", 
#&gt;                   list("future"), " package and packages enhancing it.", 
#&gt;                   list(), "\n", list(), "\n", list("WARNING: Note that the names and the default values of these options may\n", 
#&gt;                     "change in future versions of the package.  Please use with care until\n", 
#&gt;                     "further notice."), "\n"), "\n", list(list(
#&gt;                   "Settings moved to the 'parallelly' package"), 
#&gt;                   list("\n", "\n", "Several functions have been moved to the ", 
#&gt;                     list("parallelly"), " package:\n", list("\n", 
#&gt;                       list(), " ", list(list("parallelly::availableCores()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::availableWorkers()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::makeClusterMPI()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::makeNodePSOCK()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::supportsMulticore()")), 
#&gt;                       "\n"), "\n", "\n", "The options and environment variables controlling those have been adjusted\n", 
#&gt;                     "accordingly to have different prefixes.\n", 
#&gt;                     "For example, option ", list("future.fork.enable"), 
#&gt;                     " has been renamed to\n", list("parallelly.fork.enable"), 
#&gt;                     " and the corresponding environment variable\n", 
#&gt;                     list("R_FUTURE_FORK_ENABLE"), " has been renamed to\n", 
#&gt;                     list("R_PARALLELLY_FORK_ENABLE"), ".\n", 
#&gt;                     "For backward compatibility reasons, the ", 
#&gt;                     list("parallelly"), " package will\n", "support both versions for a long foreseeable time.\n", 
#&gt;                     "See the ", list("parallelly::parallelly.options"), 
#&gt;                     " page for the settings.\n")), "\n", "\n", 
#&gt;                 list(list("Options for controlling futures"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.plan"), ":"), list("(character string or future function) Default future strategy plan used unless otherwise specified via ", 
#&gt;                     list(list("plan()")), ". This will also be the future plan set when calling ", 
#&gt;                     list("plan(\"default\")"), ".  If not specified, this option may be set when the ", 
#&gt;                     list("future"), " package is ", list("loaded"), 
#&gt;                     " if command-line option ", list("--parallel=ncores"), 
#&gt;                     " (short ", list("-p ncores"), ") is specified; if ", 
#&gt;                     list("ncores &gt; 1"), ", then option ", list(
#&gt;                       "future.plan"), " is set to ", list("multisession"), 
#&gt;                     " otherwise ", list("sequential"), " (in addition to option ", 
#&gt;                     list("mc.cores"), " being set to ", list(
#&gt;                       "ncores"), ", if ", list("ncores &gt;= 1"), 
#&gt;                     "). (Default: ", list("sequential"), ")")), 
#&gt;                     "\n", "\n", list(list(list("future.globals.maxSize"), 
#&gt;                       ":"), list("(numeric) Maximum allowed total size (in bytes) of global variables identified. Used to prevent too large exports. If set of ", 
#&gt;                       list("+Inf"), ", then the check for large globals is skipped. (Default: ", 
#&gt;                       list("500 * 1024 ^ 2"), " = 500 MiB)")), 
#&gt;                     "\n", "\n", list(list(list("future.globals.onReference"), 
#&gt;                       ": (", list("beta feature - may change"), 
#&gt;                       ")"), list("(character string) Controls whether the identified globals should be scanned for so called ", 
#&gt;                       list("references"), " (e.g. external pointers and connections) or not.  It is unlikely that another ", 
#&gt;                       list(), " process (\"worker\") can use a global that uses a internal reference of the master ", 
#&gt;                       list(), " process - we call such objects ", 
#&gt;                       list("non-exportable globals"), ".\n", 
#&gt;                       "If this option is ", list("\"error\""), 
#&gt;                       ", an informative error message is produced if a non-exportable global is detected.\n", 
#&gt;                       "If ", list("\"warning\""), ", a warning is produced, but the processing will continue; it is likely that the future will be resolved with a run-time error unless processed in the master ", 
#&gt;                       list(), " process (e.g. ", list("plan(sequential)"), 
#&gt;                       " and ", list("plan(multicore)"), ").\n", 
#&gt;                       "If ", list("\"ignore\""), ", no scan is performed.\n", 
#&gt;                       "(Default: ", list("\"ignore\""), " but may change)\n")), 
#&gt;                     "\n", "\n", list(list(list("future.resolve.recursive"), 
#&gt;                       ":"), list("(integer) An integer specifying the maximum recursive depth to which futures should be resolved. If negative, nothing is resolved.  If ", 
#&gt;                       list("0"), ", only the future itself is resolved.  If ", 
#&gt;                       list("1"), ", the future and any of its elements that are futures are resolved, and so on. If ", 
#&gt;                       list("+Inf"), ", infinite search depth is used. (Default: ", 
#&gt;                       list("0"), ")")), "\n", "\n", list(list(
#&gt;                       list("future.rng.onMisuse"), ": (", list(
#&gt;                         "beta feature - may change"), ")"), list(
#&gt;                       "(character string) If random numbers are used in futures, then parallel (L'Ecuyer-CMRG) RNG should be used in order to get statistical sound RNGs. The defaults in the future framework assume that ", 
#&gt;                       list("no"), " random number generation (RNG) is taken place in the future expression because L'Ecuyer-CMRG RNGs come with an unnecessary overhead if not needed.  To protect against mistakes, the future framework attempts to detect when random numbers are used despite L'Ecuyer-CMRG RNGs are not in place.  If this is detected, and ", 
#&gt;                       list("future.rng.onMisuse = \"error\""), 
#&gt;                       ", then an informative error message is produced.  If ", 
#&gt;                       list("\"warning\""), ", then a warning message is produced.  If ", 
#&gt;                       list("\"ignore\""), ", no check is performed. (Default: ", 
#&gt;                       list("\"warning\""), ")")), "\n", "\n", 
#&gt;                     list(list(list("future.wait.timeout"), ":"), 
#&gt;                       list("(numeric) Maximum waiting time (in seconds) for a free worker before a timeout error is generated. (Default: ", 
#&gt;                         list("30 * 24 * 60 * 60"), " (= 30 days))")), 
#&gt;                     "\n", "\n", list(list(list("future.wait.interval"), 
#&gt;                       ":"), list("(numeric) Initial interval (in seconds) between polls. (Default: ", 
#&gt;                       list("0.2"), " = 0.2 seconds)")), "\n", 
#&gt;                     "\n", list(list(list("future.wait.alpha"), 
#&gt;                       ":"), list("(numeric) Positive scale factor used to increase the interval after each poll. (Default: ", 
#&gt;                       list("1.01"), ")")), "\n"), "\n")), "\n", 
#&gt;                 "\n", list(list("Options for debugging futures"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.debug"), ":"), list("(logical) If ", 
#&gt;                     list("TRUE"), ", extensive debug messages are generated. (Default: ", 
#&gt;                     list("FALSE"), ")")), "\n"), "\n")), "\n", 
#&gt;                 "\n", list(list("Options for controlling package startup"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.startup.script"), ":"), list("(character vector or a logical) Specifies zero of more future startup scripts to be sourced when the ", 
#&gt;                     list("future"), " package is ", list("attached"), 
#&gt;                     ". It is only the first existing script that is sourced. If none of the specified files exist, nothing is sourced - there will be neither a warning nor an error.\n", 
#&gt;                     "If this option is not specified, environment variable ", 
#&gt;                     list("R_FUTURE_STARTUP_SCRIPT"), " is considered, where multiple scripts may be separated by either a colon (", 
#&gt;                     list(":"), ") or a semicolon (", list(";"), 
#&gt;                     "). If neither is set, or either is set to ", 
#&gt;                     list("TRUE"), ", the default is to look for a ", 
#&gt;                     list(".future.R"), " script in the current directory and then in the user's home directory.  To disable future startup scripts, set the option or the environment variable to ", 
#&gt;                     list("FALSE"), ".  ", list("Importantly"), 
#&gt;                     ", this option is ", list("always"), " set to ", 
#&gt;                     list("FALSE"), " if the ", list("future"), 
#&gt;                     " package is loaded as part of a future expression being evaluated, e.g. in a background process. In order words, they are sourced in the main ", 
#&gt;                     list(), " process but not in future processes. (Default: ", 
#&gt;                     list("TRUE"), " in main ", list(), " process and ", 
#&gt;                     list("FALSE"), " in future processes / during future evaluation)")), 
#&gt;                     "\n", "\n", list(list(list("future.cmdargs"), 
#&gt;                       ":"), list("(character vector) Overrides ", 
#&gt;                       list(list("commandArgs"), "()"), " when the ", 
#&gt;                       list("future"), " package is ", list("loaded"), 
#&gt;                       ".")), "\n"), "\n")), "\n", "\n", list(
#&gt;                   list("Options for configuring low-level system behaviors"), 
#&gt;                   list("\n", "\n", "\n", list("\n", list(list(
#&gt;                     list("future.fork.multithreading.enable"), 
#&gt;                     " (", list("beta feature - may change"), 
#&gt;                     "):"), list("(logical) Enable or disable ", 
#&gt;                     list("multi-threading"), " while using ", 
#&gt;                     list("forked"), " parallel processing.  If ", 
#&gt;                     list("FALSE"), ", different multi-thread library settings are overridden such that they run in single-thread mode. Specifically, multi-threading will be disabled for OpenMP (which requires the ", 
#&gt;                     list("RhpcBLASctl"), " package) and for ", 
#&gt;                     list("RcppParallel"), ". If ", list("TRUE"), 
#&gt;                     ", or not set (the default), multi-threading is allowed.  Parallelization via multi-threaded processing (done in native code by some packages and external libraries) while at the same time using forked (aka \"multicore\") parallel processing is known to unstable.  Note that this is not only true when using ", 
#&gt;                     list("plan(multicore)"), " but also when using, for instance, ", 
#&gt;                     list(list("mclapply"), "()"), " of the ", 
#&gt;                     list("parallel"), " package. (Default: not set)")), 
#&gt;                     "\n"), "\n", "\n", "See also ", list("parallelly::parallelly.options"), 
#&gt;                     ".\n")), "\n", "\n", list(list("Options for demos"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.demo.mandelbrot.region"), ":"), list(
#&gt;                     "(integer) Either a named list of ", list(
#&gt;                       list("mandelbrot()")), " arguments or an integer in {1, 2, 3} specifying a predefined Mandelbrot region. (Default: ", 
#&gt;                     list("1L"), ")")), "\n", "\n", list(list(
#&gt;                     list("future.demo.mandelbrot.nrow"), ":"), 
#&gt;                     list("(integer) Number of rows and columns of tiles. (Default: ", 
#&gt;                       list("3L"), ")")), "\n"), "\n")), "\n", 
#&gt;                 "\n", list(list("Deprecated or for internal prototyping"), 
#&gt;                   list("\n", "\n", "\n", "The following options exists only for troubleshooting purposes and must not\n", 
#&gt;                     "be used in production.  If used, there is a risk that the results are\n", 
#&gt;                     "non-reproducible if processed elsewhere.  To lower the risk of them being\n", 
#&gt;                     "used by mistake, they are marked as deprecated and will produce warnings\n", 
#&gt;                     "if set.\n", "\n", list("\n", list(list(list(
#&gt;                       "future.globals.onMissing"), ":"), list(
#&gt;                       "(character string) Action to take when non-existing global variables (\"globals\" or \"unknowns\") are identified when the future is created.  If ", 
#&gt;                       list("\"error\""), ", an error is generated immediately.  If ", 
#&gt;                       list("\"ignore\""), ", no action is taken and an attempt to evaluate the future expression will be made.  The latter is useful when there is a risk for false-positive globals being identified, e.g. when future expression contains non-standard evaluation (NSE).  (Default: ", 
#&gt;                       list("\"ignore\""), ")")), "\n", "\n", 
#&gt;                       list(list(list("future.globals.method"), 
#&gt;                         ":"), list("(character string) Method used to identify globals. For details, see ", 
#&gt;                         list(list("globalsOf"), "()"), ". (Default: ", 
#&gt;                         list("\"ordered\""), ")")), "\n", "\n", 
#&gt;                       list(list(list("future.globals.resolve"), 
#&gt;                         ":"), list("(logical) If ", list("TRUE"), 
#&gt;                         ", globals that are ", list(list("Future")), 
#&gt;                         " objects (typically created as ", list(
#&gt;                           "explicit"), " futures) will be resolved and have their values (using ", 
#&gt;                         list("value()"), ") collected.  Because searching for unresolved futures among globals (including their content) can be expensive, the default is not to do it and instead leave it to the run-time checks that assert proper ownership when resolving futures and collecting their values. (Default: ", 
#&gt;                         list("FALSE"), ")")), "\n"), "\n")), 
#&gt;                 "\n", "\n", list(list("Environment variables that set R options"), 
#&gt;                   list("\n", "\n", "All of the above ", list(), 
#&gt;                     " ", list("future.*"), " options can be set by corresponding\n", 
#&gt;                     "environment variable ", list("R_FUTURE_*"), 
#&gt;                     " ", list("when the ", list("future"), " package is\n", 
#&gt;                       "loaded"), ".\n", "For example, if ", list(
#&gt;                       "R_FUTURE_RNG_ONMISUSE = \"ignore\""), 
#&gt;                     ", then option\n", list("future.rng.onMisuse"), 
#&gt;                     " is set to ", list("\"ignore\""), " (character string).\n", 
#&gt;                     "Similarly, if ", list("R_FUTURE_GLOBALS_MAXSIZE = \"50000000\""), 
#&gt;                     ", then option\n", list("future.globals.maxSize"), 
#&gt;                     " is set to ", list("50000000"), " (numeric).\n")), 
#&gt;                 "\n", "\n", list("\n", "# Allow at most 5 MB globals per futures\n", 
#&gt;                   "options(future.globals.maxSize = 5e6)\n", 
#&gt;                   "\n", "# Be strict; catch all RNG mistakes\n", 
#&gt;                   "options(future.rng.onMisuse = \"error\")\n", 
#&gt;                   "\n", "\n"), "\n", list("\n", "To set ", list(), 
#&gt;                   " options or environment variables when ", 
#&gt;                   list(), " starts (even before the ", list("future"), 
#&gt;                   " package is loaded), see the ", list("Startup"), 
#&gt;                   " help page.  The ", list(list("https://cran.r-project.org/package=startup"), 
#&gt;                     list(list("startup"))), " package provides a friendly mechanism for configurating ", 
#&gt;                   list(), "'s startup process.\n"), "\n", list(
#&gt;                   "internal"), "\n"), futureOf.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/futureOf.R", 
#&gt;                 "\n", list("futureOf"), "\n", list("futureOf"), 
#&gt;                 "\n", list("Get the future of a future variable"), 
#&gt;                 "\n", list("\n", "futureOf(\n", "  var = NULL,\n", 
#&gt;                   "  envir = parent.frame(),\n", "  mustExist = TRUE,\n", 
#&gt;                   "  default = NA,\n", "  drop = FALSE\n", ")\n"), 
#&gt;                 "\n", list("\n", list(list("var"), list("the variable.  If NULL, all futures in the\n", 
#&gt;                   "environment are returned.")), "\n", "\n", 
#&gt;                   list(list("envir"), list("the environment where to search from.")), 
#&gt;                   "\n", "\n", list(list("mustExist"), list("If TRUE and the variable does not exists, then\n", 
#&gt;                     "an informative error is thrown, otherwise NA is returned.")), 
#&gt;                   "\n", "\n", list(list("default"), list("the default value if future was not found.")), 
#&gt;                   "\n", "\n", list(list("drop"), list("if TRUE and ", 
#&gt;                     list("var"), " is NULL, then returned list\n", 
#&gt;                     "only contains futures, otherwise also ", 
#&gt;                     list("default"), " values.")), "\n"), "\n", 
#&gt;                 list("\n", "A ", list("Future"), " (or ", list(
#&gt;                   "default"), ").\n", "If ", list("var"), " is NULL, then a named list of Future:s are returned.\n"), 
#&gt;                 "\n", list("\n", "Get the future of a future variable that has been created directly\n", 
#&gt;                   "or indirectly via ", list(list("future()")), 
#&gt;                   ".\n"), "\n", list("\n", "a %&lt;-% { 1 }\n", 
#&gt;                   "\n", "f &lt;- futureOf(a)\n", "print(f)\n", "\n", 
#&gt;                   "b %&lt;-% { 2 }\n", "\n", "f &lt;- futureOf(b)\n", 
#&gt;                   "print(f)\n", "\n", "## All futures\n", "fs &lt;- futureOf()\n", 
#&gt;                   "print(fs)\n", "\n", "\n", "## Futures part of environment\n", 
#&gt;                   "env &lt;- new.env()\n", "env$c %&lt;-% { 3 }\n", 
#&gt;                   "\n", "f &lt;- futureOf(env$c)\n", "print(f)\n", 
#&gt;                   "\n", "f2 &lt;- futureOf(c, envir = env)\n", "print(f2)\n", 
#&gt;                   "\n", "f3 &lt;- futureOf(\"c\", envir = env)\n", 
#&gt;                   "print(f3)\n", "\n", "fs &lt;- futureOf(envir = env)\n", 
#&gt;                   "print(fs)\n"), "\n"), futureSessionInfo.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/futureSessionInfo.R", 
#&gt;                 "\n", list("futureSessionInfo"), "\n", list("futureSessionInfo"), 
#&gt;                 "\n", list("Get session information specific to the future framework"), 
#&gt;                 "\n", list("\n", "futureSessionInfo(test = TRUE)\n"), 
#&gt;                 "\n", list("\n", list(list("test"), list("If TRUE, one or more futures are created to query workers\n", 
#&gt;                   "and validate their information.")), "\n"), 
#&gt;                 "\n", list("\n", "Nothing.\n"), "\n", list("\n", 
#&gt;                   "Get session information specific to the future framework\n"), 
#&gt;                 "\n"), futures.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/futures.R", 
#&gt;                 "\n", list("futures"), "\n", list("futures"), 
#&gt;                 "\n", list("Get all futures in a container"), 
#&gt;                 "\n", list("\n", "futures(x, ...)\n"), "\n", 
#&gt;                 list("\n", list(list("x"), list("An environment, a list, or a list environment.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "An object of same type as ", 
#&gt;                   list("x"), " and with the same names\n", "and/or dimensions, if set.\n"), 
#&gt;                 "\n", list("\n", "Gets all futures in an environment, a list, or a list environment\n", 
#&gt;                   "and returns an object of the same class (and dimensions).\n", 
#&gt;                   "Non-future elements are returned as is.\n"), 
#&gt;                 "\n", list("\n", "This function is useful for retrieve futures that were created via\n", 
#&gt;                   "future assignments (", list("%&lt;-%"), ") and therefore stored as promises.\n", 
#&gt;                   "This function turns such promises into standard ", 
#&gt;                   list("Future"), "\n", "objects.\n"), "\n"), 
#&gt;             getExpression.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/Future-class.R", 
#&gt;                 "\n", list("getExpression"), "\n", list("getExpression"), 
#&gt;                 "\n", list("getExpression.Future"), "\n", list(
#&gt;                   "Inject code for the next type of future to use for nested futures"), 
#&gt;                 "\n", list("\n", "getExpression(future, ...)\n"), 
#&gt;                 "\n", list("\n", list(list("future"), list("Current future.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "A future expression with code injected to set what\n", 
#&gt;                   "type of future to use for nested futures, iff any.\n"), 
#&gt;                 "\n", list("\n", "Inject code for the next type of future to use for nested futures\n"), 
#&gt;                 "\n", list("\n", "If no next future strategy is specified, the default is to\n", 
#&gt;                   "use ", list("sequential"), " futures.  This conservative approach protects\n", 
#&gt;                   "against spawning off recursive futures by mistake, especially\n", 
#&gt;                   list("multicore"), " and ", list("multisession"), 
#&gt;                   " ones.\n", "The default will also set ", list(
#&gt;                     "options(mc.cores = 1L)"), " (*) so that\n", 
#&gt;                   "no parallel ", list(), " processes are spawned off by functions such as\n", 
#&gt;                   list("parallel::mclapply()"), " and friends.\n", 
#&gt;                   "\n", "Currently it is not possible to specify what type of nested\n", 
#&gt;                   "futures to be used, meaning the above default will always be\n", 
#&gt;                   "used.\n", "See ", list(list("https://github.com/HenrikBengtsson/future/issues/37"), 
#&gt;                     list("Issue #37")), "\n", "for plans on adding support for custom nested future types.\n", 
#&gt;                   "\n", "(*) Ideally we would set ", list("mc.cores = 0"), 
#&gt;                   " but that will unfortunately\n", "cause ", 
#&gt;                   list("mclapply()"), " and friends to generate an error saying\n", 
#&gt;                   "\"'mc.cores' must be &gt;= 1\".  Ideally those functions should\n", 
#&gt;                   "fall back to using the non-multicore alternative in this\n", 
#&gt;                   "case, e.g. ", list("mclapply(...)"), " =&gt; ", 
#&gt;                   list("lapply(...)"), ".\n", "See ", list("https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7"), 
#&gt;                   "\n", "for a discussion on this.\n"), "\n", 
#&gt;                 list("internal"), "\n"), getGlobalsAndPackages.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/globals.R", 
#&gt;                 "\n", list("getGlobalsAndPackages"), "\n", list(
#&gt;                   "getGlobalsAndPackages"), "\n", list("Retrieves global variables of an expression and their associated packages"), 
#&gt;                 "\n", list("\n", "getGlobalsAndPackages(\n", 
#&gt;                   "  expr,\n", "  envir = parent.frame(),\n", 
#&gt;                   "  tweak = tweakExpression,\n", "  globals = TRUE,\n", 
#&gt;                   "  resolve = getOption(\"future.globals.resolve\", NULL),\n", 
#&gt;                   "  persistent = FALSE,\n", "  maxSize = getOption(\"future.globals.maxSize\", 500 * 1024^2),\n", 
#&gt;                   "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                   "expr"), list("An ", list(), " expression whose globals should be found.")), 
#&gt;                   "\n", "\n", list(list("envir"), list("The environment from which globals should be searched.")), 
#&gt;                   "\n", "\n", list(list("tweak"), list("(optional) A function that takes an expression and returned a modified one.")), 
#&gt;                   "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, a named list, or a ", 
#&gt;                     list("Globals"), " object.  If TRUE, globals are identified by code inspection based on ", 
#&gt;                     list("expr"), " and ", list("tweak"), " searching from environment ", 
#&gt;                     list("envir"), ".  If FALSE, no globals are used.  If a character vector, then globals are identified by lookup based their names ", 
#&gt;                     list("globals"), " searching from environment ", 
#&gt;                     list("envir"), ".  If a named list or a Globals object, the globals are used as is.")), 
#&gt;                   "\n", "\n", list(list("resolve"), list("If TRUE, any future that is a global variables (or part of one) is resolved and replaced by a \"constant\" future.")), 
#&gt;                   "\n", "\n", list(list("persistent"), list("If TRUE, non-existing globals (= identified in expression but not found in memory) are always silently ignored and assumed to be existing in the evaluation environment.  If FALSE, non-existing globals are by default ignore, but may also trigger an informative error if option ", 
#&gt;                     list("future.globals.onMissing"), " in ", 
#&gt;                     list("\"error\""), " (should only be used for troubleshooting).")), 
#&gt;                   "\n", "\n", list(list("maxSize"), list("The maximum allowed total size (in bytes) of globals - for\n", 
#&gt;                     "the purpose of preventing too large exports / transfers happening by\n", 
#&gt;                     "mistake.  If the total size of the global objects are greater than this\n", 
#&gt;                     "limit, an informative error message is produced. If\n", 
#&gt;                     list("maxSize = +Inf"), ", then this assertion is skipped. (Default: 500 MiB).")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "A named list with elements ", 
#&gt;                   list("expr"), " (the tweaked expression), ", 
#&gt;                   list("globals"), " (a named list of class ", 
#&gt;                   list("FutureGlobals"), ") and ", list("packages"), 
#&gt;                   " (a character string).\n"), "\n", list("\n", 
#&gt;                   "Retrieves global variables of an expression and their associated packages\n"), 
#&gt;                 "\n", list("\n", "Internally, ", list(list("globalsOf"), 
#&gt;                   "()"), " is used to identify globals and associated packages from the expression.\n"), 
#&gt;                 "\n", list("internal"), "\n"), `grapes-conditions-grapes.Rd` = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/conditions_OP.R", 
#&gt;                 "\n", list("%conditions%"), "\n", list("%conditions%"), 
#&gt;                 "\n", list("Control whether standard output should be captured or not"), 
#&gt;                 "\n", list("\n", "fassignment %conditions% capture\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("capture"), list(
#&gt;                   "If TRUE, the standard output will be captured, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Control whether standard output should be captured or not\n"), 
#&gt;                 "\n"), `grapes-globals-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/globals_OP.R", 
#&gt;                 "\n", list("%globals%"), "\n", list("%globals%"), 
#&gt;                 "\n", list("%packages%"), "\n", list("Specify globals and packages for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %globals% globals\n", 
#&gt;                   "fassignment %packages% packages\n"), "\n", 
#&gt;                 list("\n", list(list("fassignment"), list("The future assignment, e.g.\n", 
#&gt;                   list("x %&lt;-% { expr }"), ".")), "\n", "\n", 
#&gt;                   list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                     "to control how globals are handled.\n", 
#&gt;                     "For details, see section 'Globals used by future expressions'\n", 
#&gt;                     "in the help for ", list(list("future()")), 
#&gt;                     ".")), "\n", "\n", list(list("packages"), 
#&gt;                     list("(optional) a character vector specifying packages\n", 
#&gt;                       "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                   "\n"), "\n", list("\n", "Specify globals and packages for a future assignment\n"), 
#&gt;                 "\n"), `grapes-label-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/label_OP.R", 
#&gt;                 "\n", list("%label%"), "\n", list("%label%"), 
#&gt;                 "\n", list("Specify label for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %label% label\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("label"), list(
#&gt;                   "An optional character string label attached to the future.")), 
#&gt;                   "\n"), "\n", list("\n", "Specify label for a future assignment\n"), 
#&gt;                 "\n"), `grapes-lazy-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/lazy_OP.R", 
#&gt;                 "\n", list("%lazy%"), "\n", list("%lazy%"), "\n", 
#&gt;                 list("Control lazy / eager evaluation for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %lazy% lazy\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("lazy"), list(
#&gt;                   "If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Control lazy / eager evaluation for a future assignment\n"), 
#&gt;                 "\n"), `grapes-plan-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/plan_OP.R", 
#&gt;                 "\n", list("%plan%"), "\n", list("%plan%"), "\n", 
#&gt;                 list("Use a specific plan for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %plan% strategy\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("strategy"), list(
#&gt;                   "The mechanism for how the future should be\n", 
#&gt;                   "resolved. See ", list(list("plan()")), " for further details.")), 
#&gt;                   "\n"), "\n", list("\n", "Use a specific plan for a future assignment\n"), 
#&gt;                 "\n", list("\n", "The ", list(list("plan()")), 
#&gt;                   " function sets the default plan for all futures.\n"), 
#&gt;                 "\n"), `grapes-seed-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/seed_OP.R", 
#&gt;                 "\n", list("%seed%"), "\n", list("%seed%"), "\n", 
#&gt;                 list("Set random seed for future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %seed% seed\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("seed"), list(
#&gt;                   "(optional) If TRUE, the random seed, that is, the state of the\n", 
#&gt;                   "random number generator (RNG) will be set such that statistically sound\n", 
#&gt;                   "random numbers are produced (also during parallelization).\n", 
#&gt;                   "If FALSE (default), it is assumed that the future expression does neither\n", 
#&gt;                   "need nor use random numbers generation.\n", 
#&gt;                   "To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\n", 
#&gt;                   "or a regular RNG seed (a single integer).  If the latter, then a\n", 
#&gt;                   "L'Ecuyer-CMRG seed will be automatically created based on the given seed.\n", 
#&gt;                   "Furthermore, if FALSE, then the future will be monitored to make sure it\n", 
#&gt;                   "does not use random numbers.  If it does and depending on the value of\n", 
#&gt;                   "option ", list(list("future.rng.onMisuse")), 
#&gt;                   ", the check is\n", "ignored, an informative warning, or error will be produced.\n", 
#&gt;                   "If ", list("seed"), " is NULL, then the effect is as with ", 
#&gt;                   list("seed = FALSE"), "\n", "but without the RNG check being performed.")), 
#&gt;                   "\n"), "\n", list("\n", "Set random seed for future assignment\n"), 
#&gt;                 "\n"), `grapes-stdout-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/stdout_OP.R", 
#&gt;                 "\n", list("%stdout%"), "\n", list("%stdout%"), 
#&gt;                 "\n", list("Control whether standard output should be captured or not"), 
#&gt;                 "\n", list("\n", "fassignment %stdout% capture\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("capture"), list(
#&gt;                   "If TRUE, the standard output will be captured, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Control whether standard output should be captured or not\n"), 
#&gt;                 "\n"), `grapes-tweak-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/tweak_OP.R", 
#&gt;                 "\n", list("%tweak%"), "\n", list("%tweak%"), 
#&gt;                 "\n", list("Temporarily tweaks the arguments of the current strategy"), 
#&gt;                 "\n", list("\n", "fassignment %tweak% tweaks\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("tweaks"), list(
#&gt;                   "A named list (or vector) with arguments that\n", 
#&gt;                   "should be changed relative to the current strategy.")), 
#&gt;                   "\n"), "\n", list("\n", "Temporarily tweaks the arguments of the current strategy\n"), 
#&gt;                 "\n"), make_rng_seeds.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/rng.R", 
#&gt;                 "\n", list("make_rng_seeds"), "\n", list("make_rng_seeds"), 
#&gt;                 "\n", list("Produce Reproducible Seeds for Parallel Random Number Generation"), 
#&gt;                 "\n", list("\n", "make_rng_seeds(count, seed = FALSE, debug = getOption(\"future.debug\", FALSE))\n"), 
#&gt;                 "\n", list("\n", list(list("count"), list("The number of RNG seeds to produce.")), 
#&gt;                   "\n", "\n", list(list("seed"), list("A logical specifying whether RNG seeds should be generated\n", 
#&gt;                     "or not.  (", list("seed = NULL"), " corresponds to ", 
#&gt;                     list("seed = FALSE"), ").\n", "If a list, then it should be of length ", 
#&gt;                     list("count"), " and each element should\n", 
#&gt;                     "consist of a valid RNG seed.")), "\n", "\n", 
#&gt;                   list(list("debug"), list("If ", list("TRUE"), 
#&gt;                     ", debug output is produced, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Returns a non-named list of length ", 
#&gt;                   list("count"), ", or ", list("NULL"), ".\n", 
#&gt;                   "Any seed returned is a valid RNG seed.\n"), 
#&gt;                 "\n", list("\n", "Produce Reproducible Seeds for Parallel Random Number Generation\n"), 
#&gt;                 "\n", list("internal"), "\n"), mandelbrot.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/mandelbrot.R", 
#&gt;                 "\n", list("mandelbrot"), "\n", list("mandelbrot"), 
#&gt;                 "\n", list("as.raster.Mandelbrot"), "\n", list(
#&gt;                   "plot.Mandelbrot"), "\n", list("mandelbrot_tiles"), 
#&gt;                 "\n", list("Mandelbrot convergence counts"), 
#&gt;                 "\n", list("\n", "mandelbrot(...)\n"), "\n", 
#&gt;                 list("\n", list(list("Z"), list("A complex matrix for which convergence\n", 
#&gt;                   "counts should be calculated.")), "\n", "\n", 
#&gt;                   list(list("xmid, ymid, side, resolution"), 
#&gt;                     list("Alternative specification of\n", "the complex plane ", 
#&gt;                       list("Z"), ", where\n", list("mean(Re(Z)) == xmid"), 
#&gt;                       ",\n", list("mean(Im(Z)) == ymid"), ",\n", 
#&gt;                       list("diff(range(Re(Z))) == side"), ",\n", 
#&gt;                       list("diff(range(Im(Z))) == side"), ", and\n", 
#&gt;                       list("dim(Z) == c(resolution, resolution)"), 
#&gt;                       ".")), "\n", "\n", list(list("maxIter"), 
#&gt;                     list("Maximum number of iterations per bin.")), 
#&gt;                   "\n", "\n", list(list("tau"), list("A threshold; the radius when calling\n", 
#&gt;                     "divergence (Mod(z) &gt; tau).")), "\n"), "\n", 
#&gt;                 list("\n", "Returns an integer matrix (of class Mandelbrot) with\n", 
#&gt;                   "non-negative counts.\n"), "\n", list("\n", 
#&gt;                   "Mandelbrot convergence counts\n"), "\n", list(
#&gt;                   "\n", "counts &lt;- mandelbrot(xmid = -0.75, ymid = 0, side = 3)\n", 
#&gt;                   "str(counts)\n", list("\n", "plot(counts)\n"), 
#&gt;                   "\n", "\n", list("\n", "demo(\"mandelbrot\", package = \"future\", ask = FALSE)\n"), 
#&gt;                   "\n", "\n"), "\n", list("\n", "The internal Mandelbrot algorithm was inspired by and\n", 
#&gt;                   "adopted from similar GPL code of Martin Maechler available\n", 
#&gt;                   "from ftp://stat.ethz.ch/U/maechler/R/ on 2005-02-18 (sic!).\n"), 
#&gt;                 "\n", list("internal"), "\n"), multicore.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multicore.R", 
#&gt;                 "\n", list("multicore"), "\n", list("multicore"), 
#&gt;                 "\n", list("Create a multicore future whose value will be resolved asynchronously in a forked parallel process"), 
#&gt;                 "\n", list("\n", "multicore(\n", "  ...,\n", 
#&gt;                   "  workers = availableCores(constraints = \"multicore\"),\n", 
#&gt;                   "  envir = parent.frame()\n", ")\n"), "\n", 
#&gt;                 list("\n", list(list("..."), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A positive numeric scalar or a function specifying the\n", 
#&gt;                     "maximum number of parallel futures that can be active at the same time\n", 
#&gt;                     "before blocking.\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return a numeric scalar.")), 
#&gt;                   "\n", "\n", list(list("envir"), list("The ", 
#&gt;                     list("environment"), " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("MulticoreFuture"), "\n", "If ", 
#&gt;                   list("workers == 1"), ", then all processing using done in the\n", 
#&gt;                   "current/main ", list(), " session and we therefore fall back to using\n", 
#&gt;                   "an sequential future.  This is also the case whenever multicore\n", 
#&gt;                   "processing is not supported, e.g. on Windows.\n"), 
#&gt;                 "\n", list("\n", "A multicore future is a future that uses multicore evaluation,\n", 
#&gt;                   "which means that its ", list("value is computed and resolved in\n", 
#&gt;                     "parallel in another process"), ".\n"), "\n", 
#&gt;                 list("\n", "This function is ", list("not"), 
#&gt;                   " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures in parallel on the local machine via as many forked\n", 
#&gt;                     "# processes as available to the current R process\n", 
#&gt;                     "plan(multicore)\n", "\n", "# Evaluate futures in parallel on the local machine via two forked processes\n", 
#&gt;                     "plan(multicore, workers = 2)\n"), list(list(
#&gt;                     "html"), list(list("&lt;/div&gt;"))), "\n", "\n", 
#&gt;                   "For the total number of cores available including the current/main\n", 
#&gt;                   list(), " process, see ", list(list("parallelly::availableCores()")), 
#&gt;                   ".\n", "\n", "Not all operating systems support process forking and thereby not multicore\n", 
#&gt;                   "futures.  For instance, forking is not supported on Microsoft Windows.\n", 
#&gt;                   "Moreover, process forking may break some R environments such as RStudio.\n", 
#&gt;                   "Because of this, the future package disables process forking also in\n", 
#&gt;                   "such cases.  See ", list(list("supportsMulticore()")), 
#&gt;                   " for details.\n", "Trying to create multicore futures on non-supported systems or when\n", 
#&gt;                   "forking is disabled will result in multicore futures falling back to\n", 
#&gt;                   "becoming ", list("sequential"), " futures.\n"), 
#&gt;                 "\n", list("\n", "## Use multicore futures\n", 
#&gt;                   "plan(multicore)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## A multicore future is evaluated in a separate forked\n", 
#&gt;                   "## process.  Changing the value of a global variable\n", 
#&gt;                   "## will not affect the result of the future.\n", 
#&gt;                   "a &lt;- 7\n", "print(a)\n", "\n", "v &lt;- value(f)\n", 
#&gt;                   "print(v)\n", "stopifnot(v == 0)\n"), "\n", 
#&gt;                 list("\n", "For processing in multiple background ", 
#&gt;                   list(), " sessions, see\n", list("multisession"), 
#&gt;                   " futures.\n", "\n", "Use ", list(list("availableCores()")), 
#&gt;                   " to see the total number of\n", "cores that are available for the current ", 
#&gt;                   list(), " session.\n", "Use ", list(list("availableCores"), 
#&gt;                     "(\"multicore\") &gt; 1L"), " to check\n", "whether multicore futures are supported or not on the current\n", 
#&gt;                   "system.\n"), "\n"), multiprocess.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multiprocess.R", 
#&gt;                 "\n", list("multiprocess"), "\n", list("multiprocess"), 
#&gt;                 "\n", list("Create a multiprocess future whose value will be resolved asynchronously using multicore or a multisession evaluation"), 
#&gt;                 "\n", list("\n", "multiprocess(..., workers = availableCores(), envir = parent.frame())\n"), 
#&gt;                 "\n", list("\n", list(list(list()), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A positive numeric scalar or a function specifying the\n", 
#&gt;                     "maximum number of parallel futures that can be active at the same time\n", 
#&gt;                     "before blocking.\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return a numeric scalar.")), 
#&gt;                   "\n", "\n", list(list("envir"), list("The ", 
#&gt;                     list("environment"), " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("MultiprocessFuture"), " implemented as either a\n", 
#&gt;                   list("MulticoreFuture"), " or a ", list("MultisessionFuture"), 
#&gt;                   ".\n"), "\n", list("\n", "A multiprocess future is a future that uses ", 
#&gt;                   list("multicore"), " evaluation\n", "if supported, otherwise it uses ", 
#&gt;                   list("multisession"), " evaluation.\n", "Regardless, its ", 
#&gt;                   list("value is computed and resolved in\n", 
#&gt;                     "parallel in another process"), ".", list(), 
#&gt;                   "\n", list(), "\n", list("WARNING: Consider the 'multiprocess' future plan deprecated.\n", 
#&gt;                     "Instead, explicitly specify 'multisession' or 'multicore'.  The former works\n", 
#&gt;                     "everywhere and is the recommended one between the two. ", 
#&gt;                     list("Forked processing"), ",\n", "which 'multicore' uses, is unstable in various environment and setups.\n", 
#&gt;                     "The 'multiprocess' alias is therefore being phased out."), 
#&gt;                   "\n"), "\n", list("\n", list("\n", "\n", "## Use multiprocess futures\n", 
#&gt;                   "plan(multiprocess)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## A multiprocess future is evaluated in a separate R process.\n", 
#&gt;                   "## Changing the value of a global variable will not affect\n", 
#&gt;                   "## the result of the future.\n", "a &lt;- 7\n", 
#&gt;                   "print(a)\n", "\n", "v &lt;- value(f)\n", "print(v)\n", 
#&gt;                   "stopifnot(v == 0)\n", "\n", "## Explicitly close multisession workers, if they were used\n", 
#&gt;                   "plan(sequential)\n"), "\n"), "\n", list("\n", 
#&gt;                   "Internally ", list(list("multicore()")), " and ", 
#&gt;                   list(list("multisession()")), "\n", "are used.\n"), 
#&gt;                 "\n", list("internal"), "\n"), multisession.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multisession.R", 
#&gt;                 "\n", list("multisession"), "\n", list("multisession"), 
#&gt;                 "\n", list("Create a multisession future whose value will be resolved asynchronously in a parallel ", 
#&gt;                   list(), " session"), "\n", list("\n", "multisession(\n", 
#&gt;                   "  ...,\n", "  workers = availableCores(),\n", 
#&gt;                   "  lazy = FALSE,\n", "  rscript_libs = .libPaths(),\n", 
#&gt;                   "  envir = parent.frame()\n", ")\n"), "\n", 
#&gt;                 list("\n", list(list("..."), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A positive numeric scalar or a function specifying the\n", 
#&gt;                     "maximum number of parallel futures that can be active at the same time\n", 
#&gt;                     "before blocking.\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return a numeric scalar.")), 
#&gt;                   "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                     "eagerly (starting immediately), otherwise not.")), 
#&gt;                   "\n", "\n", list(list("rscript_libs"), list(
#&gt;                     "A character vector of ", list(), " package library folders that\n", 
#&gt;                     "the workers should use.  The default is ", 
#&gt;                     list(".libPaths()"), " so that multisession\n", 
#&gt;                     "workers inherits the same library path as the main ", 
#&gt;                     list(), " session.\n", "To avoid this, use ", 
#&gt;                     list("plan(multisession, ..., rscript_libs = NULL)"), 
#&gt;                     ".\n", list("Important: Note that the library path is set on the workers when they are\n", 
#&gt;                       "created, i.e. when ", list("plan(multisession)"), 
#&gt;                       " is called.  Any changes to\n", list(".libPaths()"), 
#&gt;                       " in the main R session after the workers have been created\n", 
#&gt;                       "will have no effect."), "\n", "This is passed down as-is to ", 
#&gt;                     list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                     ".")), "\n", "\n", list(list("envir"), list(
#&gt;                     "The ", list("environment"), " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("MultisessionFuture"), ".\n", "If ", 
#&gt;                   list("workers == 1"), ", then all processing using done in the\n", 
#&gt;                   "current/main ", list(), " session and we therefore fall back to using\n", 
#&gt;                   "a lazy future.\n"), "\n", list("\n", "A multisession future is a future that uses multisession evaluation,\n", 
#&gt;                   "which means that its ", list("value is computed and resolved in\n", 
#&gt;                     "parallel in another ", list(), " session"), 
#&gt;                   ".\n"), "\n", list("\n", "This function is ", 
#&gt;                   list("not"), " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures in parallel on the local machine via as many background\n", 
#&gt;                     "# processes as available to the current R process\n", 
#&gt;                     "plan(multisession)\n", "\n", "# Evaluate futures in parallel on the local machine via two background\n", 
#&gt;                     "# processes\n", "plan(multisession, workers = 2)\n"), 
#&gt;                   list(list("html"), list(list("&lt;/div&gt;"))), "\n", 
#&gt;                   "\n", "The background ", list(), " sessions (the \"workers\") are created using\n", 
#&gt;                   list(list("makeClusterPSOCK()")), ".\n", "\n", 
#&gt;                   "For the total number of\n", list(), " sessions available including the current/main ", 
#&gt;                   list(), " process, see\n", list(list("parallelly::availableCores()")), 
#&gt;                   ".\n", "\n", "A multisession future is a special type of cluster future.\n"), 
#&gt;                 "\n", list("\n", list("\n", "\n", "## Use multisession futures\n", 
#&gt;                   "plan(multisession)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## A multisession future is evaluated in a separate R session.\n", 
#&gt;                   "## Changing the value of a global variable will not affect\n", 
#&gt;                   "## the result of the future.\n", "a &lt;- 7\n", 
#&gt;                   "print(a)\n", "\n", "v &lt;- value(f)\n", "print(v)\n", 
#&gt;                   "stopifnot(v == 0)\n", "\n", "## Explicitly close multisession workers by switching plan\n", 
#&gt;                   "plan(sequential)\n"), "\n"), "\n", list("\n", 
#&gt;                   "For processing in multiple forked ", list(), 
#&gt;                   " sessions, see\n", list("multicore"), " futures.\n", 
#&gt;                   "\n", "Use ", list(list("parallelly::availableCores()")), 
#&gt;                   " to see the total number of\n", "cores that are available for the current ", 
#&gt;                   list(), " session.\n"), "\n"), nbrOfWorkers.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/nbrOfWorkers.R", 
#&gt;                 "\n", list("nbrOfWorkers"), "\n", list("nbrOfWorkers"), 
#&gt;                 "\n", list("nbrOfFreeWorkers"), "\n", list("Get the number of workers available"), 
#&gt;                 "\n", list("\n", "nbrOfWorkers(evaluator = NULL)\n", 
#&gt;                   "\n", "nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)\n"), 
#&gt;                 "\n", list("\n", list(list("evaluator"), list(
#&gt;                   "A future evaluator function.\n", "If NULL (default), the current evaluator as returned\n", 
#&gt;                   "by ", list(list("plan()")), " is used.")), 
#&gt;                   "\n", "\n", list(list("background"), list("If TRUE, only workers that can process a future in the\n", 
#&gt;                     "background are considered.  If FALSE, also workers running in the main ", 
#&gt;                     list(), "\n", "process are considered, e.g. when using the 'sequential' backend.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used; reserved for future use.")), 
#&gt;                   "\n"), "\n", list("\n", list("nbrOfWorkers()"), 
#&gt;                   " returns a positive number in ", list(list(
#&gt;                     "{1, 2, 3, ...}")), ", which\n", "for some future backends may also be ", 
#&gt;                   list("+Inf"), ".\n", "\n", list("nbrOfFreeWorkers()"), 
#&gt;                   " returns a non-negative number in\n", list(
#&gt;                     list("{0, 1, 2, 3, ...}")), " which is less than or equal to ", 
#&gt;                   list("nbrOfWorkers()"), ".\n"), "\n", list(
#&gt;                   "\n", "Get the number of workers available\n"), 
#&gt;                 "\n", list("\n", "plan(multisession)\n", "nbrOfWorkers()  ## == availableCores()\n", 
#&gt;                   "\n", "plan(sequential)\n", "nbrOfWorkers()  ## == 1\n"), 
#&gt;                 "\n"), nullcon.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils.R", 
#&gt;                 "\n", list("nullcon"), "\n", list("nullcon"), 
#&gt;                 "\n", list("Creates a connection to the system null device"), 
#&gt;                 "\n", list("\n", "nullcon()\n"), "\n", list("\n", 
#&gt;                   "Returns a open, binary ", list(list("base::connection()")), 
#&gt;                   ".\n"), "\n", list("\n", "Creates a connection to the system null device\n"), 
#&gt;                 "\n", list("internal"), "\n"), pid_exists.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils.R", 
#&gt;                 "\n", list("pid_exists"), "\n", list("pid_exists"), 
#&gt;                 "\n", list("Check whether a process PID exists or not"), 
#&gt;                 "\n", list("\n", "pid_exists(pid, debug = getOption(\"future.debug\", FALSE))\n"), 
#&gt;                 "\n", list("\n", list(list("pid"), list("A positive integer.")), 
#&gt;                   "\n"), "\n", list("\n", "Returns ", list("TRUE"), 
#&gt;                   " if a process with the given PID exists,\n", 
#&gt;                   list("FALSE"), " if a process with the given PID does not exists, and\n", 
#&gt;                   list("NA"), " if it is not possible to check PIDs on the current system.\n"), 
#&gt;                 "\n", list("\n", "Check whether a process PID exists or not\n"), 
#&gt;                 "\n", list("\n", "There is no single go-to function in ", 
#&gt;                   list(), " for testing whether a PID exists\n", 
#&gt;                   "or not.  Instead, this function tries to identify a working one among\n", 
#&gt;                   "multiple possible alternatives.  A method is considered working if the\n", 
#&gt;                   "PID of the current process is successfully identified as being existing\n", 
#&gt;                   "such that ", list("pid_exists(Sys.getpid())"), 
#&gt;                   " is ", list("TRUE"), ".  If no working\n", 
#&gt;                   "approach is found, ", list("pid_exists()"), 
#&gt;                   " will always return ", list("NA"), "\n", "regardless of PID tested.\n", 
#&gt;                   "On Unix, including macOS, alternatives ", 
#&gt;                   list("tools::pskill(pid, signal = 0L)"), "\n", 
#&gt;                   "and ", list("system2(\"ps\", args = pid)"), 
#&gt;                   " are used.\n", "On Windows, various alternatives of ", 
#&gt;                   list("system2(\"tasklist\", ...)"), " are used.\n"), 
#&gt;                 "\n", list("\n", list("\n", list(), " The Open Group Base Specifications Issue 7, 2018 edition,\n", 
#&gt;                   "IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)\n", 
#&gt;                   list("https://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html"), 
#&gt;                   "\n", list(), " Microsoft, tasklist, 2018-08-30,\n", 
#&gt;                   list("https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist"), 
#&gt;                   "\n", list(), " R-devel thread 'Detecting whether a process exists or not by its PID?',\n", 
#&gt;                   "2018-08-30.\n", list("https://stat.ethz.ch/pipermail/r-devel/2018-August/076702.html"), 
#&gt;                   "\n"), "\n"), "\n", list("\n", list(list("pskill"), 
#&gt;                   "()"), " and ", list(list("system2"), "()"), 
#&gt;                   ".\n"), "\n", list("internal"), "\n"), plan.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/zzz.plan.R", 
#&gt;                 "\n", list("plan"), "\n", list("plan"), "\n", 
#&gt;                 list("Plan how to resolve a future"), "\n", list(
#&gt;                   "\n", "plan(\n", "  strategy = NULL,\n", "  ...,\n", 
#&gt;                   "  substitute = TRUE,\n", "  .skip = FALSE,\n", 
#&gt;                   "  .call = TRUE,\n", "  .cleanup = TRUE,\n", 
#&gt;                   "  .init = TRUE\n", ")\n"), "\n", list("\n", 
#&gt;                   list(list("strategy"), list("The evaluation function (or name of it) to use\n", 
#&gt;                     "for resolving a future.  If NULL, then the current strategy is returned.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Additional arguments overriding the default arguments\n", 
#&gt;                     "of the evaluation function.  Which additional arguments are supported\n", 
#&gt;                     "depends on what evaluation function is used, e.g. several support\n", 
#&gt;                     "argument ", list("workers"), " but not all.  For details, see the individual\n", 
#&gt;                     "functions of which some are linked to below.")), 
#&gt;                   "\n", "\n", list(list("substitute"), list("If TRUE, the ", 
#&gt;                     list("strategy"), " expression is\n", list(
#&gt;                       "substitute()"), ":d, otherwise not.")), 
#&gt;                   "\n", "\n", list(list(".skip"), list("(internal) If ", 
#&gt;                     list("TRUE"), ", then attempts to set a strategy\n", 
#&gt;                     "that is the same as what is currently in use, will skipped.")), 
#&gt;                   "\n", "\n", list(list(".call"), list("(internal) Used for recording the call to this function.")), 
#&gt;                   "\n", "\n", list(list(".cleanup"), list("(internal) Used to stop implicitly started clusters.")), 
#&gt;                   "\n", "\n", list(list(".init"), list("(internal) Used to initiate workers.")), 
#&gt;                   "\n"), "\n", list("\n", "If a new strategy is chosen, then the previous one is returned\n", 
#&gt;                   "(invisible), otherwise the current one is returned (visibly).\n"), 
#&gt;                 "\n", list("\n", "This function allows ", list(
#&gt;                   "the user"), " to plan the future, more specifically,\n", 
#&gt;                   "it specifies how ", list(list("future()")), 
#&gt;                   ":s are resolved,\n", "e.g. sequentially or in parallel.\n"), 
#&gt;                 "\n", list("\n", "The default strategy is ", 
#&gt;                   list(list("sequential")), ", but the default can be\n", 
#&gt;                   "configured by option ", list("future.plan"), 
#&gt;                   " and, if that is not set,\n", "system environment variable ", 
#&gt;                   list("R_FUTURE_PLAN"), ".\n", "To reset the strategy back to the default, use ", 
#&gt;                   list("plan(\"default\")"), ".\n"), "\n", list(
#&gt;                   list("Implemented evaluation strategies"), 
#&gt;                   list("\n", "\n", list("\n", list(), list(list(
#&gt;                     list("sequential")), ":"), list("\n", "Resolves futures sequentially in the current ", 
#&gt;                     list(), " process.\n"), "\n", list(), list(
#&gt;                     list(list("transparent")), ":"), list("\n", 
#&gt;                     "Resolves futures sequentially in the current ", 
#&gt;                     list(), " process and\n", "assignments will be done to the calling environment.\n", 
#&gt;                     "Early stopping is enabled by default.\n"), 
#&gt;                     "\n", list(), list(list(list("multisession")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously (in parallel) in separate\n", 
#&gt;                       list(), " sessions running in the background on the same machine.\n"), 
#&gt;                     "\n", list(), list(list(list("multicore")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously (in parallel) in separate\n", 
#&gt;                       list("forked"), " ", list(), " processes running in the background on\n", 
#&gt;                       "the same machine.  Not supported on Windows.\n"), 
#&gt;                     "\n", list(), list(list(list("multiprocess")), 
#&gt;                       ":"), list("(DEPRECATED)\n", "If multicore evaluation is supported, that will be used,\n", 
#&gt;                       "otherwise multisession evaluation will be used.\n"), 
#&gt;                     "\n", list(), list(list(list("cluster")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously (in parallel) in separate\n", 
#&gt;                       list(), " sessions running typically on one or more machines.\n"), 
#&gt;                     "\n", list(), list(list(list("remote")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously in a separate ", 
#&gt;                       list(), " session\n", "running on a separate machine, typically on a different\n", 
#&gt;                       "network.\n"), "\n"), "\n", "\n", "Other package may provide additional evaluation strategies.\n", 
#&gt;                     "Notably, the ", list("future.batchtools"), 
#&gt;                     " package implements a\n", "type of futures that will be resolved via job schedulers\n", 
#&gt;                     "that are typically available on high-performance compute\n", 
#&gt;                     "(HPC) clusters, e.g. LSF, Slurm, TORQUE/PBS, Sun Grid Engine,\n", 
#&gt;                     "and OpenLava.\n", "\n", "To \"close\" any background workers (e.g. ", 
#&gt;                     list("multisession"), "), change\n", "the plan to something different; ", 
#&gt;                     list("plan(sequential)"), " is recommended\n", 
#&gt;                     "for this.\n")), "\n", "\n", list(list("For package developers"), 
#&gt;                   list("\n", "\n", "Please refrain from modifying the future strategy inside your packages /\n", 
#&gt;                     "functions, i.e. do not call ", list("plan()"), 
#&gt;                     " in your code.  Instead, leave\n", "the control on what backend to use to the end user.  This idea is part of\n", 
#&gt;                     "the core philosophy of the future framework - as a developer you can never\n", 
#&gt;                     "know what future backends the user have access to.  Moreover, by not making\n", 
#&gt;                     "any assumptions about what backends are available, your code will also work\n", 
#&gt;                     "automatically with any new backends developed after you wrote your code.\n", 
#&gt;                     "\n", "If you think it is necessary to modify the future strategy within a\n", 
#&gt;                     "function, then make sure to undo the changes when exiting the function.\n", 
#&gt;                     "This can be done using:\n", "\n", list("\n", 
#&gt;                       "  oplan &lt;- plan(new_set_of_strategies)\n", 
#&gt;                       "  on.exit(plan(oplan), add = TRUE)\n", 
#&gt;                       "  [...]\n"), "\n", "\n", "This is important because the end-user might have already set the future\n", 
#&gt;                     "strategy elsewhere for other purposes and will most likely not known that\n", 
#&gt;                     "calling your function will break their setup.\n", 
#&gt;                     list("Remember, your package and its functions might be used in a greater\n", 
#&gt;                       "context where multiple packages and functions are involved and those might\n", 
#&gt;                       "also rely on the future framework, so it is important to avoid stepping on\n", 
#&gt;                       "others' toes."), "\n")), "\n", "\n", list(
#&gt;                   list("Using plan() in scripts and vignettes"), 
#&gt;                   list("\n", "\n", "When writing scripts or vignettes that uses futures, try to place any\n", 
#&gt;                     "call to ", list("plan()"), " as far up (as early on) in the code as possible.\n", 
#&gt;                     "This will help users to quickly identify where the future plan is set up\n", 
#&gt;                     "and allow them to modify it to their computational resources.\n", 
#&gt;                     "Even better is to leave it to the user to set the ", 
#&gt;                     list("plan()"), " prior to\n", list("source()"), 
#&gt;                     ":ing the script or running the vignette.\n", 
#&gt;                     "If a ", list(list(".future.R")), " exists in the current directory and / or in\n", 
#&gt;                     "the user's home directory, it is sourced when the ", 
#&gt;                     list("future"), " package is\n", list("loaded"), 
#&gt;                     ".  Because of this, the ", list(".future.R"), 
#&gt;                     " file provides a\n", "convenient place for users to set the ", 
#&gt;                     list("plan()"), ".\n", "This behavior can be controlled via an ", 
#&gt;                     list(), " option - see\n", list("future options"), 
#&gt;                     " for more details.\n")), "\n", "\n", list(
#&gt;                   "\n", "a &lt;- b &lt;- c &lt;- NA_real_\n", "\n", "# An sequential future\n", 
#&gt;                   "plan(sequential)\n", "f &lt;- future({\n", "  a &lt;- 7\n", 
#&gt;                   "  b &lt;- 3\n", "  c &lt;- 2\n", "  a * b * c\n", 
#&gt;                   "})\n", "y &lt;- value(f)\n", "print(y)\n", "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                   "\n", "\n", "# A sequential future with lazy evaluation\n", 
#&gt;                   "plan(sequential)\n", "f &lt;- future({\n", "  a &lt;- 7\n", 
#&gt;                   "  b &lt;- 3\n", "  c &lt;- 2\n", "  a * b * c\n", 
#&gt;                   "}, lazy = TRUE)\n", "y &lt;- value(f)\n", "print(y)\n", 
#&gt;                   "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                   "\n", "\n", "# A multicore future (specified as a string)\n", 
#&gt;                   "plan(\"multicore\")\n", "f &lt;- future({\n", 
#&gt;                   "  a &lt;- 7\n", "  b &lt;- 3\n", "  c &lt;- 2\n", "  a * b * c\n", 
#&gt;                   "})\n", "y &lt;- value(f)\n", "print(y)\n", "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                   "\n", "\n", "## Multisession futures gives an error on R CMD check on\n", 
#&gt;                   "## Windows (but not Linux or macOS) for unknown reasons.\n", 
#&gt;                   "## The same code works in package tests.\n", 
#&gt;                   list("\n", "\n", "# A multisession future (specified via a string variable)\n", 
#&gt;                     "plan(\"future::multisession\")\n", "f &lt;- future({\n", 
#&gt;                     "  a &lt;- 7\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                     "  a * b * c\n", "})\n", "y &lt;- value(f)\n", 
#&gt;                     "print(y)\n", "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                     "\n"), "\n", "\n", "## Explicitly close multisession workers by switching plan\n", 
#&gt;                   "plan(sequential)\n"), "\n"), private_length.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils.R", 
#&gt;                 "\n", list(".length"), "\n", list(".length"), 
#&gt;                 "\n", list("Gets the length of an object without dispatching"), 
#&gt;                 "\n", list("\n", ".length(x)\n"), "\n", list(
#&gt;                   "\n", list(list("x"), list("Any ", list(), 
#&gt;                     " object.")), "\n"), "\n", list("\n", "A non-negative integer.\n"), 
#&gt;                 "\n", list("\n", "Gets the length of an object without dispatching\n"), 
#&gt;                 "\n", list("\n", "This function returns ", list(
#&gt;                   "length(unclass(x))"), ", but tries to avoid\n", 
#&gt;                   "calling ", list("unclass(x)"), " unless necessary.\n"), 
#&gt;                 "\n", list("\n", list(list(".subset"), "()"), 
#&gt;                   " and ", list(list(".subset2"), "()"), ".\n"), 
#&gt;                 "\n", list("internal"), "\n"), `re-exports.Rd` = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/000.re-exports.R", 
#&gt;                 "\n", list("re-exports"), "\n", list("re-exports"), 
#&gt;                 "\n", list("as.cluster"), "\n", list("autoStopCluster"), 
#&gt;                 "\n", list("availableCores"), "\n", list("availableWorkers"), 
#&gt;                 "\n", list("makeClusterMPI"), "\n", list("makeClusterPSOCK"), 
#&gt;                 "\n", list("makeNodePSOCK"), "\n", list("supportsMulticore"), 
#&gt;                 "\n", list("Functions Moved to 'parallelly'"), 
#&gt;                 "\n", list("\n", "The following function used to be part of ", 
#&gt;                   list("future"), " but has since\n", "been migrated to ", 
#&gt;                   list("parallelly"), ".  The migration started with\n", 
#&gt;                   list("future"), " 1.20.0 (November 2020).  They were moved because they\n", 
#&gt;                   "are also useful outside of the ", list("future"), 
#&gt;                   " framework.\n"), "\n", list("\n", list("\n", 
#&gt;                   list(), " ", list(list("parallelly::as.cluster()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::autoStopCluster()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::availableCores()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::availableWorkers()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::makeClusterMPI()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::makeNodePSOCK()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::supportsMulticore()")), 
#&gt;                   "\n"), "\n", "\n", "For backward-compatible reasons, these functions remain available as\n", 
#&gt;                   "exact copies also from this package (as re-exports).  For example,", 
#&gt;                   list(list("html"), list(list("&lt;div class=\"r\"&gt;"))), 
#&gt;                   list("cl &lt;- parallelly::makeClusterPSOCK(2)\n"), 
#&gt;                   list(list("html"), list(list("&lt;/div&gt;"))), "\n", 
#&gt;                   "\n", "can still be accessed as:", list(list(
#&gt;                     "html"), list(list("&lt;div class=\"r\"&gt;"))), 
#&gt;                   list("cl &lt;- future::makeClusterPSOCK(2)\n"), 
#&gt;                   list(list("html"), list(list("&lt;/div&gt;"))), "\n"), 
#&gt;                 "\n"), readImmediateConditions.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils-immediateCondition.R", 
#&gt;                 "\n", list("readImmediateConditions"), "\n", 
#&gt;                 list("readImmediateConditions"), "\n", list("Read All 'immediateCondition' RDS Files"), 
#&gt;                 "\n", list("\n", "readImmediateConditions(\n", 
#&gt;                   "  path = immediateConditionsPath(),\n", "  pattern = \"[.]rds$\",\n", 
#&gt;                   "  include = getOption(\"future.relay.immediate\", \"immediateCondition\"),\n", 
#&gt;                   "  signal = FALSE,\n", "  remove = TRUE\n", 
#&gt;                   ")\n"), "\n", list("\n", list(list("path"), 
#&gt;                   list("(character string) The folder where the RDS files are.")), 
#&gt;                   "\n", "\n", list(list("pattern"), list("(character string) A regular expression selecting\n", 
#&gt;                     "the RDS files to be read.")), "\n", "\n", 
#&gt;                   list(list("include"), list("(character vector) The class or classes of the objects\n", 
#&gt;                     "to be kept.")), "\n", "\n", list(list("signal"), 
#&gt;                     list("(logical) If TRUE, the condition read are signaled.")), 
#&gt;                   "\n", "\n", list(list("remove"), list("(logical) If TRUE, the RDS files used are removed on exit.")), 
#&gt;                   "\n"), "\n", list("\n", "Returns a ", list(
#&gt;                   "base::list"), " of immediateCondition objects.\n"), 
#&gt;                 "\n", list("\n", "Read All 'immediateCondition' RDS Files\n"), 
#&gt;                 "\n", list("internal"), "\n"), remote.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/remote.R", 
#&gt;                 "\n", list("remote"), "\n", list("remote"), "\n", 
#&gt;                 list("Create a remote future whose value will be resolved asynchronously in a remote process"), 
#&gt;                 "\n", list("\n", "remote(\n", "  ...,\n", "  workers = NULL,\n", 
#&gt;                   "  revtunnel = TRUE,\n", "  myip = NULL,\n", 
#&gt;                   "  persistent = TRUE,\n", "  homogeneous = TRUE,\n", 
#&gt;                   "  envir = parent.frame()\n", ")\n"), "\n", 
#&gt;                 list("\n", list(list("..."), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A ", list(list(
#&gt;                     "cluster")), " object,\n", "a character vector of host names, a positive numeric scalar,\n", 
#&gt;                     "or a function.\n", "If a character vector or a numeric scalar, a ", 
#&gt;                     list("cluster"), " object\n", "is created using ", 
#&gt;                     list(list("makeClusterPSOCK"), "(workers)"), 
#&gt;                     ".\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return any of the above types.")), 
#&gt;                   "\n", "\n", list(list("revtunnel"), list("If TRUE, reverse SSH tunneling is used for the\n", 
#&gt;                     "PSOCK cluster nodes to connect back to the master ", 
#&gt;                     list(), " process.  This\n", "avoids the hassle of firewalls, port forwarding and having to know\n", 
#&gt;                     "the internal / public IP address of the master ", 
#&gt;                     list(), " session.")), "\n", "\n", list(list(
#&gt;                     "myip"), list("The external IP address of this machine.\n", 
#&gt;                     "If NULL, then it is inferred using an online service (default).")), 
#&gt;                   "\n", "\n", list(list("persistent"), list("If FALSE, the evaluation environment is cleared\n", 
#&gt;                     "from objects prior to the evaluation of the future.")), 
#&gt;                   "\n", "\n", list(list("homogeneous"), list(
#&gt;                     "If TRUE, all cluster nodes is assumed to use the\n", 
#&gt;                     "same path to ", list("Rscript"), " as the main ", 
#&gt;                     list(), " session.  If FALSE, the\n", "it is assumed to be on the PATH for each node.\n", 
#&gt;                     "If NULL, then ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                     " will decide on TRUE\n", "or FALSE depending on ", 
#&gt;                     list("workers"), ".")), "\n", "\n", list(
#&gt;                     list("envir"), list("The ", list("environment"), 
#&gt;                       " from where global objects should be\n", 
#&gt;                       "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("ClusterFuture"), ".\n"), "\n", 
#&gt;                 list("\n", "A remote future is a future that uses remote cluster evaluation,\n", 
#&gt;                   "which means that its ", list("value is computed and resolved\n", 
#&gt;                     "remotely in another process"), ".\n"), "\n", 
#&gt;                 list("\n", "This function is ", list("not"), 
#&gt;                   " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures on remote machine 'server.example.org', and\n", 
#&gt;                     "# any nested ones sequentially (default) on that remote machine\n", 
#&gt;                     "plan(remote, workers = \"server.example.org\")\n", 
#&gt;                     "\n", "# Evaluate futures on remote machine 'server.example.org', and\n", 
#&gt;                     "# nested ones in parallel on that remote machine\n", 
#&gt;                     "plan(list(\n", "   tweak(remote, workers = \"server.example.org\"),\n", 
#&gt;                     "   multisession\n", "))\n", "\n", "# Evaluate futures on remote machine 'server.example.org', and\n", 
#&gt;                     "# nested ones in parallel on the remote machines n1, n2, and n3.\n", 
#&gt;                     "plan(list(\n", "  tweak(remote, workers = \"server.example.org\"),\n", 
#&gt;                     "  tweak(cluster, workers = c(\"n1\", \"n2\", \"n3\"))\n", 
#&gt;                     "))\n"), list(list("html"), list(list("&lt;/div&gt;"))), 
#&gt;                   "\n"), "\n", list(list("'remote' versus 'cluster'"), 
#&gt;                   list("\n", "\n", "The ", list("remote"), " plan is a very similar to the ", 
#&gt;                     list(list("cluster")), " plan, but provides\n", 
#&gt;                     "more convenient default argument values when connecting to remote machines.  #' Specifically, ", 
#&gt;                     list("remote"), " uses ", list("persistent = TRUE"), 
#&gt;                     " by default, and it sets\n", list("homogeneous"), 
#&gt;                     ", ", list("revtunnel"), ", and ", list("myip"), 
#&gt;                     " \"wisely\" depending on the value of\n", 
#&gt;                     list("workers"), ".\n", "' See below for example on how ", 
#&gt;                     list("remote"), " and ", list("cluster"), 
#&gt;                     " are related.\n")), "\n", "\n", list("\n", 
#&gt;                   list("\\donttest{\n", "\n", "## Use a remote machine\n", 
#&gt;                     "plan(remote, workers = \"remote.server.org\")\n", 
#&gt;                     "\n", "## Evaluate expression remotely\n", 
#&gt;                     "host %&lt;-% { Sys.info()[[\"nodename\"]] }\n", 
#&gt;                     "host\n", "[1] \"remote.server.org\"\n", 
#&gt;                     "\n", "\n", "## The following setups are equivalent:\n", 
#&gt;                     "plan(remote, workers = \"localhost\")\n", 
#&gt;                     "plan(cluster, workers = \"localhost\", persistent = TRUE)\n", 
#&gt;                     "plan(cluster, workers = 1, persistent = TRUE)\n", 
#&gt;                     "plan(multisession, workers = 1, persistent = TRUE)\n", 
#&gt;                     "\n", "## The following setups are equivalent:\n", 
#&gt;                     "plan(remote, workers = \"remote.server.org\")\n", 
#&gt;                     "plan(cluster, workers = \"remote.server.org\", persistent = TRUE, homogeneous = FALSE)\n", 
#&gt;                     "\n", "## The following setups are equivalent:\n", 
#&gt;                     "cl &lt;- makeClusterPSOCK(\"remote.server.org\")\n", 
#&gt;                     "plan(remote, workers = cl)\n", "plan(cluster, workers = cl, persistent = TRUE)\n", 
#&gt;                     "\n", "}"), "\n"), "\n"), requestCore.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multicore.R", 
#&gt;                 "\n", list("requestCore"), "\n", list("requestCore"), 
#&gt;                 "\n", list("Request a core for multicore processing"), 
#&gt;                 "\n", list("\n", "requestCore(\n", "  await,\n", 
#&gt;                   "  workers = availableCores(),\n", "  timeout = getOption(\"future.wait.timeout\", 30 * 24 * 60 * 60),\n", 
#&gt;                   "  delta = getOption(\"future.wait.interval\", 0.2),\n", 
#&gt;                   "  alpha = getOption(\"future.wait.alpha\", 1.01)\n", 
#&gt;                   ")\n"), "\n", list("\n", list(list("await"), 
#&gt;                   list("A function used to try to \"collect\"\n", 
#&gt;                     "finished multicore subprocesses.")), "\n", 
#&gt;                   "\n", list(list("workers"), list("Total number of workers available.")), 
#&gt;                   "\n", "\n", list(list("timeout"), list("Maximum waiting time (in seconds) allowed\n", 
#&gt;                     "before a timeout error is generated.")), 
#&gt;                   "\n", "\n", list(list("delta"), list("Then base interval (in seconds) to wait\n", 
#&gt;                     "between each try.")), "\n", "\n", list(list(
#&gt;                     "alpha"), list("A multiplicative factor used to increase\n", 
#&gt;                     "the wait interval after each try.")), "\n"), 
#&gt;                 "\n", list("\n", "Invisible TRUE. If no cores are available after\n", 
#&gt;                   "extensive waiting, then a timeout error is thrown.\n"), 
#&gt;                 "\n", list("\n", "If no cores are available, the current process\n", 
#&gt;                   "blocks until a core is available.\n"), "\n", 
#&gt;                 list("internal"), "\n"), resetWorkers.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/zzz.plan.R", 
#&gt;                 "\n", list("resetWorkers"), "\n", list("resetWorkers"), 
#&gt;                 "\n", list("Free up active background workers"), 
#&gt;                 "\n", list("\n", "resetWorkers(x, ...)\n"), "\n", 
#&gt;                 list("\n", list(list("x"), list("A FutureStrategy.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "Free up active background workers\n"), 
#&gt;                 "\n", list("\n", "This function will resolve any active futures that is currently\n", 
#&gt;                   "being evaluated on background workers.\n"), 
#&gt;                 "\n", list("\n", "resetWorkers(plan())\n", "\n"), 
#&gt;                 "\n", list("internal"), "\n"), resolve.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/resolve.R", 
#&gt;                 "\n", list("resolve"), "\n", list("resolve"), 
#&gt;                 "\n", list("Resolve one or more futures synchronously"), 
#&gt;                 "\n", list("\n", "resolve(\n", "  x,\n", "  idxs = NULL,\n", 
#&gt;                   "  recursive = 0,\n", "  result = FALSE,\n", 
#&gt;                   "  stdout = FALSE,\n", "  signal = FALSE,\n", 
#&gt;                   "  force = FALSE,\n", "  sleep = 1,\n", "  value = result,\n", 
#&gt;                   "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                   "x"), list("A ", list("Future"), " to be resolved, or a list, an environment, or a\n", 
#&gt;                   "list environment of futures to be resolved.")), 
#&gt;                   "\n", "\n", list(list("idxs"), list("(optional) integer or logical index specifying the subset of\n", 
#&gt;                     "elements to check.")), "\n", "\n", list(
#&gt;                     list("recursive"), list("A non-negative number specifying how deep of a recursion\n", 
#&gt;                       "should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\n", 
#&gt;                       "no recursion is performed.")), "\n", "\n", 
#&gt;                   list(list("result"), list("(internal) If TRUE, the results are retrieved, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("stdout"), list("(internal) If TRUE, captured standard output is relayed, otherwise note.")), 
#&gt;                   "\n", "\n", list(list("signal"), list("(internal) If TRUE, captured ", 
#&gt;                     list("conditions"), " are relayed,\n", "otherwise not.")), 
#&gt;                   "\n", "\n", list(list("force"), list("(internal) If TRUE, captured standard output and captured\n", 
#&gt;                     list("conditions"), " already relayed is relayed again, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("sleep"), list("Number of seconds to wait before checking if futures have been\n", 
#&gt;                     "resolved since last time.")), "\n", "\n", 
#&gt;                   list(list("value"), list("(DEPRECATED) Use argument ", 
#&gt;                     list("result"), " instead.")), "\n", "\n", 
#&gt;                   list(list(list()), list("Not used.")), "\n"), 
#&gt;                 "\n", list("\n", "Returns ", list("x"), " (regardless of subsetting or not).\n", 
#&gt;                   "If ", list("signal"), " is TRUE and one of the futures produces an error, then\n", 
#&gt;                   "that error is produced.\n"), "\n", list("\n", 
#&gt;                   "This function provides an efficient mechanism for waiting for multiple\n", 
#&gt;                   "futures in a container (e.g. list or environment) to be resolved while in\n", 
#&gt;                   "the meanwhile retrieving values of already resolved futures.\n"), 
#&gt;                 "\n", list("\n", "This function is resolves synchronously, i.e. it blocks until ", 
#&gt;                   list("x"), " and\n", "any containing futures are resolved.\n"), 
#&gt;                 "\n", list("\n", "To resolve a future ", list(
#&gt;                   "variable"), ", first retrieve its\n", list(
#&gt;                   "Future"), " object using ", list(list("futureOf()")), 
#&gt;                   ", e.g.\n", list("resolve(futureOf(x))"), ".\n"), 
#&gt;                 "\n"), resolved.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/resolved.R", 
#&gt;                 "\n", list("resolved"), "\n", list("resolved"), 
#&gt;                 "\n", list("Check whether a future is resolved or not"), 
#&gt;                 "\n", list("\n", "resolved(x, ...)\n"), "\n", 
#&gt;                 list("\n", list(list("x"), list("A ", list("Future"), 
#&gt;                   ", a list, or an environment (which also\n", 
#&gt;                   "includes ", list("list environment"), ".")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "A logical of the same length and dimensions as ", 
#&gt;                   list("x"), ".\n", "Each element is TRUE unless the corresponding element is a\n", 
#&gt;                   "non-resolved future in case it is FALSE.\n"), 
#&gt;                 "\n", list("\n", "Check whether a future is resolved or not\n"), 
#&gt;                 "\n", list("\n", "This method needs to be implemented by the class that implement\n", 
#&gt;                   "the Future API.  The implementation should return either TRUE or FALSE\n", 
#&gt;                   "and must never throw an error (except for ", 
#&gt;                   list("FutureError"), ":s which indicate\n", 
#&gt;                   "significant, often unrecoverable infrastructure problems).\n", 
#&gt;                   "It should also be possible to use the method for polling the\n", 
#&gt;                   "future until it is resolved (without having to wait infinitely long),\n", 
#&gt;                   "e.g. ", list("while (!resolved(future)) Sys.sleep(5)"), 
#&gt;                   ".\n"), "\n"), result.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/Future-class.R", 
#&gt;                 "\n", list("result.Future"), "\n", list("result.Future"), 
#&gt;                 "\n", list("result"), "\n", list("Get the results of a resolved future"), 
#&gt;                 "\n", list("\n", list(list("result"), list("Future")), 
#&gt;                   "(future, ...)\n"), "\n", list("\n", list(list(
#&gt;                   "future"), list("A ", list("Future"), ".")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "The ", list("FutureResult"), 
#&gt;                   " object.\n"), "\n", list("\n", "Get the results of a resolved future\n"), 
#&gt;                 "\n", list("\n", "This function is only part of the ", 
#&gt;                   list("backend"), " Future API.\n", "This function is ", 
#&gt;                   list("not"), " part of the frontend Future API.\n"), 
#&gt;                 "\n", list("internal"), "\n"), run.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/Future-class.R", 
#&gt;                 "\n", list("run.Future"), "\n", list("run.Future"), 
#&gt;                 "\n", list("run"), "\n", list("Run a future"), 
#&gt;                 "\n", list("\n", list(list("run"), list("Future")), 
#&gt;                   "(future, ...)\n"), "\n", list("\n", list(list(
#&gt;                   "future"), list("A ", list("Future"), ".")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "The ", list("Future"), 
#&gt;                   " object.\n"), "\n", list("\n", "Run a future\n"), 
#&gt;                 "\n", list("\n", "This function can only be called once per future.\n", 
#&gt;                   "Further calls will result in an informative error.\n", 
#&gt;                   "If a future is not run when its value is queried,\n", 
#&gt;                   "then it is run at that point.\n"), "\n", list(
#&gt;                   "internal"), "\n"), save_rds.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils-immediateCondition.R", 
#&gt;                 "\n", list("save_rds"), "\n", list("save_rds"), 
#&gt;                 "\n", list("Robustly Saves an Object to RDS File Atomically"), 
#&gt;                 "\n", list("\n", "save_rds(object, pathname, ...)\n"), 
#&gt;                 "\n", list("\n", list(list("object"), list("The ", 
#&gt;                   list(), " object to be save.")), "\n", "\n", 
#&gt;                   list(list("pathname"), list("RDS file to written.")), 
#&gt;                   "\n", "\n", list(list(list()), list("(optional) Additional arguments passed to ", 
#&gt;                     list(list("base::saveRDS()")), ".")), "\n"), 
#&gt;                 "\n", list("\n", "(invisible) The pathname of the RDS written.\n"), 
#&gt;                 "\n", list("\n", "Robustly Saves an Object to RDS File Atomically\n"), 
#&gt;                 "\n", list("\n", "Uses ", list("base::saveRDS"), 
#&gt;                   " internally but writes the object atomically by first\n", 
#&gt;                   "writing to a temporary file which is then renamed.\n"), 
#&gt;                 "\n", list("internal"), "\n"), sequential.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/sequential.R", 
#&gt;                 "\n", list("sequential"), "\n", list("sequential"), 
#&gt;                 "\n", list("uniprocess"), "\n", list("transparent"), 
#&gt;                 "\n", list("Create a sequential future whose value will be in the current ", 
#&gt;                   list(), " session"), "\n", list("\n", "sequential(..., envir = parent.frame())\n", 
#&gt;                   "\n", "transparent(..., envir = parent.frame())\n"), 
#&gt;                 "\n", list("\n", list(list("..."), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("envir"), list("The ", list("environment"), 
#&gt;                     " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("SequentialFuture"), ".\n"), "\n", 
#&gt;                 list("\n", "A sequential future is a future that is evaluated sequentially in the\n", 
#&gt;                   "current ", list(), " session similarly to how ", 
#&gt;                   list(), " expressions are evaluated in ", list(), 
#&gt;                   ".\n", "The only difference to ", list(), " itself is that globals are validated\n", 
#&gt;                   "by default just as for all other types of futures in this package.\n"), 
#&gt;                 "\n", list("\n", "This function is ", list("not"), 
#&gt;                   " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures sequentially in the current R process\n", 
#&gt;                     "plan(sequential)\n"), list(list("html"), 
#&gt;                     list(list("&lt;/div&gt;"))), "\n", "\n", "\n"), 
#&gt;                 "\n", list(list("transparent futures (troubleshooting only)"), 
#&gt;                   list("\n", "\n", "Transparent futures are sequential futures configured to emulate how R\n", 
#&gt;                     "evaluates expressions as far as possible.  For instance, errors and\n", 
#&gt;                     "warnings are signaled immediately and assignments are done to the\n", 
#&gt;                     "calling environment (without ", list("local()"), 
#&gt;                     " as default for all other\n", "types of futures).  This makes transparent futures ideal for\n", 
#&gt;                     "troubleshooting, especially when there are errors.\n", 
#&gt;                     list("WARNING: Transparent futures should only be used for debugging and\n", 
#&gt;                       "troubleshooting.  They should not be used for production pipelines\n", 
#&gt;                       "and must not be set within another package.  This is especially\n", 
#&gt;                       "important since 'transparent' futures might be deprecated and replaced\n", 
#&gt;                       "by better means of debugging in future releases."), 
#&gt;                     "\n")), "\n", "\n", list("\n", "## Use sequential futures\n", 
#&gt;                   "plan(sequential)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create a sequential future\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## Since 'a' is a global variable in future 'f' which\n", 
#&gt;                   "## is eagerly resolved (default), this global has already\n", 
#&gt;                   "## been resolved / incorporated, and any changes to 'a'\n", 
#&gt;                   "## at this point will _not_ affect the value of 'f'.\n", 
#&gt;                   "a &lt;- 7\n", "print(a)\n", "\n", "v &lt;- value(f)\n", 
#&gt;                   "print(v)\n", "stopifnot(v == 0)\n"), "\n"), 
#&gt;             sessionDetails.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/sessionDetails.R", 
#&gt;                 "\n", list("sessionDetails"), "\n", list("sessionDetails"), 
#&gt;                 "\n", list("Outputs details on the current ", 
#&gt;                   list(), " session"), "\n", list("\n", "sessionDetails(env = FALSE)\n"), 
#&gt;                 "\n", list("\n", list(list("env"), list("If TRUE, ", 
#&gt;                   list("Sys.getenv()"), " information is returned.")), 
#&gt;                   "\n"), "\n", list("\n", "Invisibly a list of all details.\n"), 
#&gt;                 "\n", list("\n", "Outputs details on the current ", 
#&gt;                   list(), " session\n"), "\n", list("\n", "Note that remote futures use ", 
#&gt;                   list("persistent = TRUE"), " by default.\n"), 
#&gt;                 "\n", list("internal"), "\n"), signalConditions.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/signalConditions.R", 
#&gt;                 "\n", list("signalConditions"), "\n", list("signalConditions"), 
#&gt;                 "\n", list("Signals Captured Conditions"), "\n", 
#&gt;                 list("\n", "signalConditions(\n", "  future,\n", 
#&gt;                   "  include = \"condition\",\n", "  exclude = NULL,\n", 
#&gt;                   "  resignal = TRUE,\n", "  ...\n", ")\n"), 
#&gt;                 "\n", list("\n", list(list("future"), list("A resolved ", 
#&gt;                   list("Future"), ".")), "\n", "\n", list(list(
#&gt;                   "include"), list("A character string of ", 
#&gt;                   list("condition"), "\n", "classes to signal.")), 
#&gt;                   "\n", "\n", list(list("exclude"), list("A character string of ", 
#&gt;                     list("condition"), "\n", "classes ", list(
#&gt;                       "not"), " to signal.")), "\n", "\n", list(
#&gt;                     list("resignal"), list("If TRUE, then already signaled conditions are signaled\n", 
#&gt;                       "again, otherwise not.")), "\n", "\n", 
#&gt;                   list(list(list()), list("Not used.")), "\n"), 
#&gt;                 "\n", list("\n", "Returns the ", list("Future"), 
#&gt;                   " where conditioned that were signaled\n", 
#&gt;                   "have been flagged to have been signaled.\n"), 
#&gt;                 "\n", list("\n", "Captured conditions that meet the ", 
#&gt;                   list("include"), " and ", list("exclude"), 
#&gt;                   "\n", "requirements are signaled ", list("in the order as they were captured"), 
#&gt;                   ".\n"), "\n", list("\n", "Conditions are signaled by\n", 
#&gt;                   list(list("signalCondition"), "()"), ".\n"), 
#&gt;                 "\n"), sticky_globals.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/sticky_globals.R", 
#&gt;                 "\n", list("sticky_globals"), "\n", list("sticky_globals"), 
#&gt;                 "\n", list("Place a sticky-globals environment immediately after the global environment"), 
#&gt;                 "\n", list("\n", "sticky_globals(erase = FALSE, name = \"future:sticky_globals\", pos = 2L)\n"), 
#&gt;                 "\n", list("\n", list(list("erase"), list("(logical) If TRUE, the environment is erased, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("name"), list("(character) The name of the environment on the ", 
#&gt;                     list("base::search"), "\n", "path.")), "\n", 
#&gt;                   "\n", list(list("pos"), list("(integer) The position on the search path where the\n", 
#&gt;                     "environment should be positioned.  If ", 
#&gt;                     list("pos == 0L"), ", then the environment\n", 
#&gt;                     "is detached, if it exists.")), "\n"), "\n", 
#&gt;                 list("\n", "(invisible; environment) The environment.\n"), 
#&gt;                 "\n", list("\n", "Place a sticky-globals environment immediately after the global environment\n"), 
#&gt;                 "\n", list("internal"), "\n"), tweak.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/tweak.R", 
#&gt;                 "\n", list("tweak"), "\n", list("tweak"), "\n", 
#&gt;                 list("Tweak a future function by adjusting its default arguments"), 
#&gt;                 "\n", list("\n", "tweak(strategy, ..., penvir = parent.frame())\n"), 
#&gt;                 "\n", list("\n", list(list("strategy"), list(
#&gt;                   "An existing future function or the name of one.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Named arguments to replace the defaults of existing\n", 
#&gt;                     "arguments.")), "\n", "\n", list(list("penvir"), 
#&gt;                     list("The environment used when searching for a future\n", 
#&gt;                       "function by its name.")), "\n"), "\n", 
#&gt;                 list("\n", "a future function.\n"), "\n", list(
#&gt;                   "\n", "Tweak a future function by adjusting its default arguments\n"), 
#&gt;                 "\n", list("\n", "Use ", list(list("plan()")), 
#&gt;                   " to set a future to become the\n", "new default strategy.\n"), 
#&gt;                 "\n"), usedCores.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multicore.R", 
#&gt;                 "\n", list("usedCores"), "\n", list("usedCores"), 
#&gt;                 "\n", list("Get number of cores currently used"), 
#&gt;                 "\n", list("\n", "usedCores()\n"), "\n", list(
#&gt;                   "\n", "A non-negative integer.\n"), "\n", list(
#&gt;                   "\n", "Get number of children (and don't count the current process)\n", 
#&gt;                   "used by the current ", list(), " session.  The number of children\n", 
#&gt;                   "is the total number of subprocesses launched by this\n", 
#&gt;                   "process that are still running and whose values have yet\n", 
#&gt;                   "not been collected.\n"), "\n", list("internal"), 
#&gt;                 "\n"), value.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/value.R", 
#&gt;                 "\n", list("value"), "\n", list("value"), "\n", 
#&gt;                 list("values"), "\n", list("value.Future"), "\n", 
#&gt;                 list("value.list"), "\n", list("value.listenv"), 
#&gt;                 "\n", list("value.environment"), "\n", list("The value of a future or the values of all elements in a container"), 
#&gt;                 "\n", list("\n", "value(...)\n", "\n", list(list(
#&gt;                   "value"), list("Future")), "(future, stdout = TRUE, signal = TRUE, ...)\n", 
#&gt;                   "\n", list(list("value"), list("list")), "(x, stdout = TRUE, signal = TRUE, ...)\n", 
#&gt;                   "\n", list(list("value"), list("listenv")), 
#&gt;                   "(x, stdout = TRUE, signal = TRUE, ...)\n", 
#&gt;                   "\n", list(list("value"), list("environment")), 
#&gt;                   "(x, stdout = TRUE, signal = TRUE, ...)\n"), 
#&gt;                 "\n", list("\n", list(list(list()), list("All arguments used by the S3 methods.")), 
#&gt;                   "\n", "\n", list(list("future, x"), list("A ", 
#&gt;                     list("Future"), ", an environment, a list, or a list environment.")), 
#&gt;                   "\n", "\n", list(list("stdout"), list("If TRUE, standard output captured while resolving futures\n", 
#&gt;                     "is relayed, otherwise not.")), "\n", "\n", 
#&gt;                   list(list("signal"), list("If TRUE, ", list(
#&gt;                     "conditions"), " captured while resolving\n", 
#&gt;                     "futures are relayed, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", list("value()"), " of a Future object returns the value of the future, which can\n", 
#&gt;                   "be any type of ", list(), " object.\n", "\n", 
#&gt;                   list("value()"), " of a list, an environment, or a list environment returns an\n", 
#&gt;                   "object with the same number of elements and of the same class.\n", 
#&gt;                   "Names and dimension attributes are preserved, if available.\n", 
#&gt;                   "All future elements are replaced by their corresponding ", 
#&gt;                   list("value()"), " values.\n", "For all other elements, the existing object is kept as-is.\n", 
#&gt;                   "\n", "If ", list("signal"), " is TRUE and one of the futures produces an error, then\n", 
#&gt;                   "that error is produced.\n"), "\n", list("\n", 
#&gt;                   "Gets the value of a future or the values of all elements (including futures)\n", 
#&gt;                   "in a container such as a list, an environment, or a list environment.\n", 
#&gt;                   "If one or more futures is unresolved, then this function blocks until all\n", 
#&gt;                   "queried futures are resolved.\n"), "\n")), 
#&gt;         source = list(`ClusterFuture-class.Rd` = c("R/ClusterFuture-class.R", 
#&gt;         "R/MultisessionFuture-class.R"), `ConstantFuture-class.Rd` = "R/ConstantFuture-class.R", 
#&gt;             `Future-class.Rd` = "R/Future-class.R", FutureCondition.Rd = "R/FutureCondition-class.R", 
#&gt;             FutureGlobals.Rd = "R/FutureGlobals-class.R", FutureResult.Rd = "R/FutureResult-class.R", 
#&gt;             `MulticoreFuture-class.Rd` = "R/MulticoreFuture-class.R", 
#&gt;             `MultiprocessFuture-class.Rd` = "R/MultiprocessFuture-class.R", 
#&gt;             `UniprocessFuture-class.Rd` = "R/UniprocessFuture-class.R", 
#&gt;             as_lecyer_cmrg_seed.Rd = "R/rng.R", backtrace.Rd = "R/backtrace.R", 
#&gt;             cluster.Rd = "R/cluster.R", clusterExportSticky.Rd = "R/sticky_globals.R", 
#&gt;             find_references.Rd = "R/utils-marshalling.R", future.Rd = c("R/future.R", 
#&gt;             "R/futureAssign.R", "R/futureAssign_OP.R", "R/futureCall.R"
#&gt;             ), future.options.Rd = "R/options.R", futureOf.Rd = "R/futureOf.R", 
#&gt;             futureSessionInfo.Rd = "R/futureSessionInfo.R", futures.Rd = "R/futures.R", 
#&gt;             getExpression.Rd = "R/Future-class.R", getGlobalsAndPackages.Rd = "R/globals.R", 
#&gt;             `grapes-conditions-grapes.Rd` = "R/conditions_OP.R", 
#&gt;             `grapes-globals-grapes.Rd` = "R/globals_OP.R", `grapes-label-grapes.Rd` = "R/label_OP.R", 
#&gt;             `grapes-lazy-grapes.Rd` = "R/lazy_OP.R", `grapes-plan-grapes.Rd` = "R/plan_OP.R", 
#&gt;             `grapes-seed-grapes.Rd` = "R/seed_OP.R", `grapes-stdout-grapes.Rd` = "R/stdout_OP.R", 
#&gt;             `grapes-tweak-grapes.Rd` = "R/tweak_OP.R", make_rng_seeds.Rd = "R/rng.R", 
#&gt;             mandelbrot.Rd = "R/mandelbrot.R", multicore.Rd = "R/multicore.R", 
#&gt;             multiprocess.Rd = "R/multiprocess.R", multisession.Rd = "R/multisession.R", 
#&gt;             nbrOfWorkers.Rd = "R/nbrOfWorkers.R", nullcon.Rd = "R/utils.R", 
#&gt;             pid_exists.Rd = "R/utils.R", plan.Rd = "R/zzz.plan.R", 
#&gt;             private_length.Rd = "R/utils.R", `re-exports.Rd` = "R/000.re-exports.R", 
#&gt;             readImmediateConditions.Rd = "R/utils-immediateCondition.R", 
#&gt;             remote.Rd = "R/remote.R", requestCore.Rd = "R/multicore.R", 
#&gt;             resetWorkers.Rd = "R/zzz.plan.R", resolve.Rd = "R/resolve.R", 
#&gt;             resolved.Rd = "R/resolved.R", result.Rd = "R/Future-class.R", 
#&gt;             run.Rd = "R/Future-class.R", save_rds.Rd = "R/utils-immediateCondition.R", 
#&gt;             sequential.Rd = "R/sequential.R", sessionDetails.Rd = "R/sessionDetails.R", 
#&gt;             signalConditions.Rd = "R/signalConditions.R", sticky_globals.Rd = "R/sticky_globals.R", 
#&gt;             tweak.Rd = "R/tweak.R", usedCores.Rd = "R/multicore.R", 
#&gt;             value.Rd = "R/value.R"), keywords = list("internal", 
#&gt;             "internal", "internal", "internal", "internal", "internal", 
#&gt;             "internal", "internal", "internal", "internal", character(0), 
#&gt;             character(0), "internals", "internal", character(0), 
#&gt;             "internal", character(0), character(0), character(0), 
#&gt;             "internal", "internal", character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), "internal", "internal", 
#&gt;             character(0), "internal", character(0), character(0), 
#&gt;             "internal", "internal", character(0), "internal", 
#&gt;             character(0), "internal", character(0), "internal", 
#&gt;             "internal", character(0), character(0), "internal", 
#&gt;             "internal", "internal", character(0), "internal", 
#&gt;             character(0), "internal", character(0), "internal", 
#&gt;             character(0)), concepts = list(character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0)), internal = c(TRUE, TRUE, 
#&gt;         TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, 
#&gt;         FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;         TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, 
#&gt;         TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, 
#&gt;         FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;         FALSE, TRUE, FALSE)), tutorials = list(name = character(0), 
#&gt;         file_out = character(0), title = character(0), pagetitle = character(0), 
#&gt;         url = character(0)), vignettes = list(name = c("future-1-overview", 
#&gt;     "future-2-output", "future-3-topologies", "future-4-issues", 
#&gt;     "future-4-non-exportable-objects", "future-5-startup", "future-6-future-api-backend-specification", 
#&gt;     "future-7-for-package-developers", "future-8-how-future-is-validated"
#&gt;     ), file_in = c("vignettes/future-1-overview.Rmd", "vignettes/future-2-output.Rmd", 
#&gt;     "vignettes/future-3-topologies.Rmd", "vignettes/future-4-issues.Rmd", 
#&gt;     "vignettes/future-4-non-exportable-objects.Rmd", "vignettes/future-5-startup.Rmd", 
#&gt;     "vignettes/future-6-future-api-backend-specification.Rmd", 
#&gt;     "vignettes/future-7-for-package-developers.Rmd", "vignettes/future-8-how-future-is-validated.Rmd"
#&gt;     ), file_out = c("articles/future-1-overview.html", "articles/future-2-output.html", 
#&gt;     "articles/future-3-topologies.html", "articles/future-4-issues.html", 
#&gt;     "articles/future-4-non-exportable-objects.html", "articles/future-5-startup.html", 
#&gt;     "articles/future-6-future-api-backend-specification.html", 
#&gt;     "articles/future-7-for-package-developers.html", "articles/future-8-how-future-is-validated.html"
#&gt;     ), title = c("A Future for R: A Comprehensive Overview", 
#&gt;     "A Future for R: Text and Message Output", "A Future for R: Future Topologies", 
#&gt;     "A Future for R: Common Issues with Solutions", "A Future for R: Non-Exportable Objects", 
#&gt;     "A Future for R: Controlling Default Future Strategy", "A Future for R: Future API Backend Specification", 
#&gt;     "A Future for R: Best Practices for Package Developers", 
#&gt;     "A Future for R: How the Future Framework is Validated"), 
#&gt;         description = c(NA_character_, NA_character_, NA_character_, 
#&gt;         NA_character_, NA_character_, NA_character_, NA_character_, 
#&gt;         NA_character_, NA_character_))), examples = TRUE, run_dont_run = FALSE, 
#&gt;     seed = 1014, lazy = FALSE, override = list(), install = FALSE, 
#&gt;     preview = FALSE, new_process = FALSE, devel = FALSE, crayon_enabled = TRUE, 
#&gt;     crayon_colors = 256, pkgdown_internet = TRUE)), envir = base::quote(&lt;environment&gt;), 
#&gt;     quote = base::quote(TRUE))
#&gt; 
#&gt; [[12]]
#&gt; (function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; })(pkg = base::quote(list(package = "future", version = "1.21.0-9005", 
#&gt;     src_path = "/tmp/hb/Rtmpbw1A1Z/future", dst_path = "/tmp/hb/Rtmpbw1A1Z/future/docs", 
#&gt;     install_metadata = FALSE, desc = &lt;environment&gt;, meta = list(
#&gt;         url = "https://future.futureverse.org", home = list(links = list(
#&gt;             list(text = "Roadmap/Milestones", href = "https://github.com/HenrikBengtsson/future/milestones"), 
#&gt;             list(text = "The Futureverse Project", href = "https://www.futureverse.org/"), 
#&gt;             list(text = "Futureverse User Forum (new!)", href = "https://github.com/HenrikBengtsson/future/discussions"))), 
#&gt;         navbar = list(structure = list(right = c("futureverse", 
#&gt;         "pkgs", "cran", "github")), components = list(futureverse = list(
#&gt;             icon = "fas fa-fast-backward", href = "https://www.futureverse.org/"), 
#&gt;             pkgs = list(text = "Packages", menu = list(list(text = "BiocParallel.FutureParam", 
#&gt;                 href = "https://BiocParallel.FutureParam.futureverse.org"), 
#&gt;                 list(text = "doFuture", href = "https://doFuture.futureverse.org"), 
#&gt;                 list(text = "furrr", href = "https://furrr.futureverse.org"), 
#&gt;                 list(text = "future", href = "https://future.futureverse.org"), 
#&gt;                 list(text = "future.apply", href = "https://future.apply.futureverse.org"), 
#&gt;                 list(text = "future.batchtools", href = "https://future.batchtools.futureverse.org"), 
#&gt;                 list(text = "future.callr", href = "https://future.callr.futureverse.org"), 
#&gt;                 list(text = "future.tests", href = "https://future.tests.futureverse.org"), 
#&gt;                 list(text = "globals", href = "https://globals.futureverse.org"), 
#&gt;                 list(text = "listenv", href = "https://listenv.futureverse.org"), 
#&gt;                 list(text = "parallelly", href = "https://parallelly.futureverse.org"), 
#&gt;                 list(text = "progressr", href = "https://progressr.futureverse.org"), 
#&gt;                 list(text = "future.mapreduce (experimental)", 
#&gt;                   href = "https://future.mapreduce.futureverse.org"), 
#&gt;                 list(text = "marshal (experimental)", href = "https://marshal.futureverse.org"))), 
#&gt;             cran = list(icon = "fab fa-r-project", href = "https://cloud.r-project.org/package=future"))), 
#&gt;         template = list(params = list(docsearch = list(api_key = "aa6e02fc501886fb0f7c91ac4e300456", 
#&gt;             index_name = "futureverse", algoliaOptions = list(
#&gt;                 facetFilters = "project:future")), ganalytics = "G-SB3EQSD9FR"))), 
#&gt;     figures = list(dev = "ragg::agg_png", dpi = 96L, dev.args = list(), 
#&gt;         fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, 
#&gt;         fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL), 
#&gt;     repo = list(url = list(home = "https://github.com/HenrikBengtsson/future/", 
#&gt;         source = "https://github.com/HenrikBengtsson/future/blob/master/", 
#&gt;         issue = "https://github.com/HenrikBengtsson/future/issues/", 
#&gt;         user = "https://github.com/")), development = list(destination = "dev", 
#&gt;         mode = "release", version_label = "default", version_tooltip = "Released version", 
#&gt;         in_dev = FALSE), topics = list(name = c(`ClusterFuture-class.Rd` = "ClusterFuture-class", 
#&gt;     `ConstantFuture-class.Rd` = "ConstantFuture-class", `Future-class.Rd` = "Future-class", 
#&gt;     FutureCondition.Rd = "FutureCondition", FutureGlobals.Rd = "FutureGlobals", 
#&gt;     FutureResult.Rd = "FutureResult", `MulticoreFuture-class.Rd` = "MulticoreFuture-class", 
#&gt;     `MultiprocessFuture-class.Rd` = "MultiprocessFuture-class", 
#&gt;     `UniprocessFuture-class.Rd` = "UniprocessFuture-class", as_lecyer_cmrg_seed.Rd = "as_lecyer_cmrg_seed", 
#&gt;     backtrace.Rd = "backtrace", cluster.Rd = "cluster", clusterExportSticky.Rd = "clusterExportSticky", 
#&gt;     find_references.Rd = "find_references", future.Rd = "future", 
#&gt;     future.options.Rd = "future.options", futureOf.Rd = "futureOf", 
#&gt;     futureSessionInfo.Rd = "futureSessionInfo", futures.Rd = "futures", 
#&gt;     getExpression.Rd = "getExpression", getGlobalsAndPackages.Rd = "getGlobalsAndPackages", 
#&gt;     `grapes-conditions-grapes.Rd` = "%conditions%", `grapes-globals-grapes.Rd` = "%globals%", 
#&gt;     `grapes-label-grapes.Rd` = "%label%", `grapes-lazy-grapes.Rd` = "%lazy%", 
#&gt;     `grapes-plan-grapes.Rd` = "%plan%", `grapes-seed-grapes.Rd` = "%seed%", 
#&gt;     `grapes-stdout-grapes.Rd` = "%stdout%", `grapes-tweak-grapes.Rd` = "%tweak%", 
#&gt;     make_rng_seeds.Rd = "make_rng_seeds", mandelbrot.Rd = "mandelbrot", 
#&gt;     multicore.Rd = "multicore", multiprocess.Rd = "multiprocess", 
#&gt;     multisession.Rd = "multisession", nbrOfWorkers.Rd = "nbrOfWorkers", 
#&gt;     nullcon.Rd = "nullcon", pid_exists.Rd = "pid_exists", plan.Rd = "plan", 
#&gt;     private_length.Rd = ".length", `re-exports.Rd` = "re-exports", 
#&gt;     readImmediateConditions.Rd = "readImmediateConditions", remote.Rd = "remote", 
#&gt;     requestCore.Rd = "requestCore", resetWorkers.Rd = "resetWorkers", 
#&gt;     resolve.Rd = "resolve", resolved.Rd = "resolved", result.Rd = "result.Future", 
#&gt;     run.Rd = "run.Future", save_rds.Rd = "save_rds", sequential.Rd = "sequential", 
#&gt;     sessionDetails.Rd = "sessionDetails", signalConditions.Rd = "signalConditions", 
#&gt;     sticky_globals.Rd = "sticky_globals", tweak.Rd = "tweak", 
#&gt;     usedCores.Rd = "usedCores", value.Rd = "value"), file_in = c("ClusterFuture-class.Rd", 
#&gt;     "ConstantFuture-class.Rd", "Future-class.Rd", "FutureCondition.Rd", 
#&gt;     "FutureGlobals.Rd", "FutureResult.Rd", "MulticoreFuture-class.Rd", 
#&gt;     "MultiprocessFuture-class.Rd", "UniprocessFuture-class.Rd", 
#&gt;     "as_lecyer_cmrg_seed.Rd", "backtrace.Rd", "cluster.Rd", "clusterExportSticky.Rd", 
#&gt;     "find_references.Rd", "future.Rd", "future.options.Rd", "futureOf.Rd", 
#&gt;     "futureSessionInfo.Rd", "futures.Rd", "getExpression.Rd", 
#&gt;     "getGlobalsAndPackages.Rd", "grapes-conditions-grapes.Rd", 
#&gt;     "grapes-globals-grapes.Rd", "grapes-label-grapes.Rd", "grapes-lazy-grapes.Rd", 
#&gt;     "grapes-plan-grapes.Rd", "grapes-seed-grapes.Rd", "grapes-stdout-grapes.Rd", 
#&gt;     "grapes-tweak-grapes.Rd", "make_rng_seeds.Rd", "mandelbrot.Rd", 
#&gt;     "multicore.Rd", "multiprocess.Rd", "multisession.Rd", "nbrOfWorkers.Rd", 
#&gt;     "nullcon.Rd", "pid_exists.Rd", "plan.Rd", "private_length.Rd", 
#&gt;     "re-exports.Rd", "readImmediateConditions.Rd", "remote.Rd", 
#&gt;     "requestCore.Rd", "resetWorkers.Rd", "resolve.Rd", "resolved.Rd", 
#&gt;     "result.Rd", "run.Rd", "save_rds.Rd", "sequential.Rd", "sessionDetails.Rd", 
#&gt;     "signalConditions.Rd", "sticky_globals.Rd", "tweak.Rd", "usedCores.Rd", 
#&gt;     "value.Rd"), file_out = c("ClusterFuture-class.html", "ConstantFuture-class.html", 
#&gt;     "Future-class.html", "FutureCondition.html", "FutureGlobals.html", 
#&gt;     "FutureResult.html", "MulticoreFuture-class.html", "MultiprocessFuture-class.html", 
#&gt;     "UniprocessFuture-class.html", "as_lecyer_cmrg_seed.html", 
#&gt;     "backtrace.html", "cluster.html", "clusterExportSticky.html", 
#&gt;     "find_references.html", "future.html", "future.options.html", 
#&gt;     "futureOf.html", "futureSessionInfo.html", "futures.html", 
#&gt;     "getExpression.html", "getGlobalsAndPackages.html", "grapes-conditions-grapes.html", 
#&gt;     "grapes-globals-grapes.html", "grapes-label-grapes.html", 
#&gt;     "grapes-lazy-grapes.html", "grapes-plan-grapes.html", "grapes-seed-grapes.html", 
#&gt;     "grapes-stdout-grapes.html", "grapes-tweak-grapes.html", 
#&gt;     "make_rng_seeds.html", "mandelbrot.html", "multicore.html", 
#&gt;     "multiprocess.html", "multisession.html", "nbrOfWorkers.html", 
#&gt;     "nullcon.html", "pid_exists.html", "plan.html", "private_length.html", 
#&gt;     "re-exports.html", "readImmediateConditions.html", "remote.html", 
#&gt;     "requestCore.html", "resetWorkers.html", "resolve.html", 
#&gt;     "resolved.html", "result.html", "run.html", "save_rds.html", 
#&gt;     "sequential.html", "sessionDetails.html", "signalConditions.html", 
#&gt;     "sticky_globals.html", "tweak.html", "usedCores.html", "value.html"
#&gt;     ), alias = list(`ClusterFuture-class.Rd` = c("ClusterFuture-class", 
#&gt;     "ClusterFuture", "MultisessionFuture", "MultisessionFuture-class"
#&gt;     ), `ConstantFuture-class.Rd` = c("ConstantFuture-class", 
#&gt;     "ConstantFuture"), `Future-class.Rd` = c("Future-class", 
#&gt;     "Future"), FutureCondition.Rd = c("FutureCondition", "FutureMessage", 
#&gt;     "FutureWarning", "FutureError", "RngFutureCondition", "RngFutureWarning", 
#&gt;     "RngFutureError", "UnexpectedFutureResultError"), FutureGlobals.Rd = c("FutureGlobals", 
#&gt;     "as.FutureGlobals", "as.FutureGlobals.FutureGlobals", "as.FutureGlobals.Globals", 
#&gt;     "as.FutureGlobals.list", "[.FutureGlobals", "c.FutureGlobals", 
#&gt;     "unique.FutureGlobals"), FutureResult.Rd = c("FutureResult", 
#&gt;     "as.character.FutureResult", "print.FutureResult"), `MulticoreFuture-class.Rd` = c("MulticoreFuture-class", 
#&gt;     "MulticoreFuture"), `MultiprocessFuture-class.Rd` = c("MultiprocessFuture-class", 
#&gt;     "MultiprocessFuture"), `UniprocessFuture-class.Rd` = c("UniprocessFuture-class", 
#&gt;     "UniprocessFuture", "SequentialFuture", "TransparentFuture"
#&gt;     ), as_lecyer_cmrg_seed.Rd = c("as_lecyer_cmrg_seed", "is_lecyer_cmrg_seed"
#&gt;     ), backtrace.Rd = "backtrace", cluster.Rd = "cluster", clusterExportSticky.Rd = "clusterExportSticky", 
#&gt;         find_references.Rd = c("find_references", "assert_no_references"
#&gt;         ), future.Rd = c("future", "futureCall", "futureAssign", 
#&gt;         "%&lt;-%", "%-&gt;%"), future.options.Rd = c("future.options", 
#&gt;         "future.cmdargs", ".future.R", "future.startup.script", 
#&gt;         "R_FUTURE_STARTUP_SCRIPT", "future.debug", "R_FUTURE_DEBUG", 
#&gt;         "future.demo.mandelbrot.region", "R_FUTURE_DEMO_MANDELBROT_REGION", 
#&gt;         "future.demo.mandelbrot.nrow", "R_FUTURE_DEMO_MANDELBROT_NROW", 
#&gt;         "future.fork.multithreading.enable", "R_FUTURE_FORK_MULTITHREADING_ENABLE", 
#&gt;         "future.globals.maxSize", "R_FUTURE_GLOBALS_MAXSIZE", 
#&gt;         "future.globals.method", "R_FUTURE_GLOBALS_METHOD", "future.globals.onMissing", 
#&gt;         "R_FUTURE_GLOBALS_ONMISSING", "future.globals.resolve", 
#&gt;         "R_FUTURE_GLOBALS_RESOLVE", "future.globals.onReference", 
#&gt;         "R_FUTURE_GLOBALS_ONREFERENCE", "future.plan", "R_FUTURE_PLAN", 
#&gt;         "future.resolve.recursive", "R_FUTURE_RNG_ONMISUSE", 
#&gt;         "future.wait.alpha", "R_FUTURE_WAIT_ALPHA", "future.wait.interval", 
#&gt;         "R_FUTURE_WAIT_INTERVAL", "future.wait.timeout", "R_FUTURE_WAIT_TIMEOUT", 
#&gt;         "R_FUTURE_RESOLVED_TIMEOUT"), futureOf.Rd = "futureOf", 
#&gt;         futureSessionInfo.Rd = "futureSessionInfo", futures.Rd = "futures", 
#&gt;         getExpression.Rd = c("getExpression", "getExpression.Future"
#&gt;         ), getGlobalsAndPackages.Rd = "getGlobalsAndPackages", 
#&gt;         `grapes-conditions-grapes.Rd` = "%conditions%", `grapes-globals-grapes.Rd` = c("%globals%", 
#&gt;         "%packages%"), `grapes-label-grapes.Rd` = "%label%", 
#&gt;         `grapes-lazy-grapes.Rd` = "%lazy%", `grapes-plan-grapes.Rd` = "%plan%", 
#&gt;         `grapes-seed-grapes.Rd` = "%seed%", `grapes-stdout-grapes.Rd` = "%stdout%", 
#&gt;         `grapes-tweak-grapes.Rd` = "%tweak%", make_rng_seeds.Rd = "make_rng_seeds", 
#&gt;         mandelbrot.Rd = c("mandelbrot", "as.raster.Mandelbrot", 
#&gt;         "plot.Mandelbrot", "mandelbrot_tiles"), multicore.Rd = "multicore", 
#&gt;         multiprocess.Rd = "multiprocess", multisession.Rd = "multisession", 
#&gt;         nbrOfWorkers.Rd = c("nbrOfWorkers", "nbrOfFreeWorkers"
#&gt;         ), nullcon.Rd = "nullcon", pid_exists.Rd = "pid_exists", 
#&gt;         plan.Rd = "plan", private_length.Rd = ".length", `re-exports.Rd` = c("re-exports", 
#&gt;         "as.cluster", "autoStopCluster", "availableCores", "availableWorkers", 
#&gt;         "makeClusterMPI", "makeClusterPSOCK", "makeNodePSOCK", 
#&gt;         "supportsMulticore"), readImmediateConditions.Rd = "readImmediateConditions", 
#&gt;         remote.Rd = "remote", requestCore.Rd = "requestCore", 
#&gt;         resetWorkers.Rd = "resetWorkers", resolve.Rd = "resolve", 
#&gt;         resolved.Rd = "resolved", result.Rd = c("result.Future", 
#&gt;         "result"), run.Rd = c("run.Future", "run"), save_rds.Rd = "save_rds", 
#&gt;         sequential.Rd = c("sequential", "uniprocess", "transparent"
#&gt;         ), sessionDetails.Rd = "sessionDetails", signalConditions.Rd = "signalConditions", 
#&gt;         sticky_globals.Rd = "sticky_globals", tweak.Rd = "tweak", 
#&gt;         usedCores.Rd = "usedCores", value.Rd = c("value", "values", 
#&gt;         "value.Future", "value.list", "value.listenv", "value.environment"
#&gt;         )), funs = list(`ClusterFuture-class.Rd` = c("ClusterFuture()", 
#&gt;     "MultisessionFuture()"), `ConstantFuture-class.Rd` = "ConstantFuture()", 
#&gt;         `Future-class.Rd` = "Future()", FutureCondition.Rd = c("FutureCondition()", 
#&gt;         "FutureMessage()", "FutureWarning()", "FutureError()", 
#&gt;         "RngFutureCondition()", "RngFutureWarning()", "RngFutureError()", 
#&gt;         "UnexpectedFutureResultError()"), FutureGlobals.Rd = "FutureGlobals()", 
#&gt;         FutureResult.Rd = c("FutureResult()", "as.character(&lt;i&gt;&amp;lt;FutureResult&amp;gt;&lt;/i&gt;)", 
#&gt;         "print(&lt;i&gt;&amp;lt;FutureResult&amp;gt;&lt;/i&gt;)"), `MulticoreFuture-class.Rd` = "MulticoreFuture()", 
#&gt;         `MultiprocessFuture-class.Rd` = "MultiprocessFuture()", 
#&gt;         `UniprocessFuture-class.Rd` = c("UniprocessFuture()", 
#&gt;         "SequentialFuture()", "TransparentFuture()"), as_lecyer_cmrg_seed.Rd = c("as_lecyer_cmrg_seed()", 
#&gt;         "is_lecyer_cmrg_seed()"), backtrace.Rd = "backtrace()", 
#&gt;         cluster.Rd = "cluster()", clusterExportSticky.Rd = "clusterExportSticky()", 
#&gt;         find_references.Rd = c("find_references()", "assert_no_references()"
#&gt;         ), future.Rd = c("future()", "futureAssign()", "`%&amp;lt;-%`", 
#&gt;         "futureCall()"), future.options.Rd = character(0), futureOf.Rd = "futureOf()", 
#&gt;         futureSessionInfo.Rd = "futureSessionInfo()", futures.Rd = "futures()", 
#&gt;         getExpression.Rd = "getExpression()", getGlobalsAndPackages.Rd = "getGlobalsAndPackages()", 
#&gt;         `grapes-conditions-grapes.Rd` = "`%conditions%`", `grapes-globals-grapes.Rd` = c("`%globals%`", 
#&gt;         "`%packages%`"), `grapes-label-grapes.Rd` = "`%label%`", 
#&gt;         `grapes-lazy-grapes.Rd` = "`%lazy%`", `grapes-plan-grapes.Rd` = "`%plan%`", 
#&gt;         `grapes-seed-grapes.Rd` = "`%seed%`", `grapes-stdout-grapes.Rd` = "`%stdout%`", 
#&gt;         `grapes-tweak-grapes.Rd` = "`%tweak%`", make_rng_seeds.Rd = "make_rng_seeds()", 
#&gt;         mandelbrot.Rd = "mandelbrot()", multicore.Rd = "multicore()", 
#&gt;         multiprocess.Rd = "multiprocess()", multisession.Rd = "multisession()", 
#&gt;         nbrOfWorkers.Rd = c("nbrOfWorkers()", "nbrOfFreeWorkers()"
#&gt;         ), nullcon.Rd = "nullcon()", pid_exists.Rd = "pid_exists()", 
#&gt;         plan.Rd = "plan()", private_length.Rd = ".length()", 
#&gt;         `re-exports.Rd` = character(0), readImmediateConditions.Rd = "readImmediateConditions()", 
#&gt;         remote.Rd = "remote()", requestCore.Rd = "requestCore()", 
#&gt;         resetWorkers.Rd = "resetWorkers()", resolve.Rd = "resolve()", 
#&gt;         resolved.Rd = "resolved()", result.Rd = "result(&lt;i&gt;&amp;lt;Future&amp;gt;&lt;/i&gt;)", 
#&gt;         run.Rd = "run(&lt;i&gt;&amp;lt;Future&amp;gt;&lt;/i&gt;)", save_rds.Rd = "save_rds()", 
#&gt;         sequential.Rd = c("sequential()", "transparent()"), sessionDetails.Rd = "sessionDetails()", 
#&gt;         signalConditions.Rd = "signalConditions()", sticky_globals.Rd = "sticky_globals()", 
#&gt;         tweak.Rd = "tweak()", usedCores.Rd = "usedCores()", value.Rd = "value()"), 
#&gt;         title = c(`ClusterFuture-class.Rd` = "A cluster future is a future whose value will be resolved asynchronously in a parallel process", 
#&gt;         `ConstantFuture-class.Rd` = "A future with a constant value", 
#&gt;         `Future-class.Rd` = "A future represents a value that will be available at some point in the future", 
#&gt;         FutureCondition.Rd = "A condition (message, warning, or error) that occurred while orchestrating a future", 
#&gt;         FutureGlobals.Rd = "A representation of a set of globals used with futures", 
#&gt;         FutureResult.Rd = "Results from resolving a future", 
#&gt;         `MulticoreFuture-class.Rd` = "A multicore future is a future whose value will be resolved asynchronously in a parallel process", 
#&gt;         `MultiprocessFuture-class.Rd` = "A multiprocess future is a future whose value will be resolved asynchronously in a parallel process", 
#&gt;         `UniprocessFuture-class.Rd` = "An uniprocess future is a future whose value will be resolved synchronously in the current process", 
#&gt;         as_lecyer_cmrg_seed.Rd = "Get a L'Ecuyer-CMRG seed either from an input seed or the current RNG state", 
#&gt;         backtrace.Rd = "Back trace the expressions evaluated when an error was caught", 
#&gt;         cluster.Rd = "Create a cluster future whose value will be resolved asynchronously in a parallel process", 
#&gt;         clusterExportSticky.Rd = "Export globals to the sticky-globals environment of the cluster nodes", 
#&gt;         find_references.Rd = "Get the first or all references of an &lt;span style=\"R\"&gt;R&lt;/span&gt; object", 
#&gt;         future.Rd = "Create a future", future.options.Rd = "Options used for futures", 
#&gt;         futureOf.Rd = "Get the future of a future variable", 
#&gt;         futureSessionInfo.Rd = "Get session information specific to the future framework", 
#&gt;         futures.Rd = "Get all futures in a container", getExpression.Rd = "Inject code for the next type of future to use for nested futures", 
#&gt;         getGlobalsAndPackages.Rd = "Retrieves global variables of an expression and their associated packages", 
#&gt;         `grapes-conditions-grapes.Rd` = "Control whether standard output should be captured or not", 
#&gt;         `grapes-globals-grapes.Rd` = "Specify globals and packages for a future assignment", 
#&gt;         `grapes-label-grapes.Rd` = "Specify label for a future assignment", 
#&gt;         `grapes-lazy-grapes.Rd` = "Control lazy / eager evaluation for a future assignment", 
#&gt;         `grapes-plan-grapes.Rd` = "Use a specific plan for a future assignment", 
#&gt;         `grapes-seed-grapes.Rd` = "Set random seed for future assignment", 
#&gt;         `grapes-stdout-grapes.Rd` = "Control whether standard output should be captured or not", 
#&gt;         `grapes-tweak-grapes.Rd` = "Temporarily tweaks the arguments of the current strategy", 
#&gt;         make_rng_seeds.Rd = "Produce Reproducible Seeds for Parallel Random Number Generation", 
#&gt;         mandelbrot.Rd = "Mandelbrot convergence counts", multicore.Rd = "Create a multicore future whose value will be resolved asynchronously in a forked parallel process", 
#&gt;         multiprocess.Rd = "Create a multiprocess future whose value will be resolved asynchronously using multicore or a multisession evaluation", 
#&gt;         multisession.Rd = "Create a multisession future whose value will be resolved asynchronously in a parallel &lt;span style=\"R\"&gt;R&lt;/span&gt; session", 
#&gt;         nbrOfWorkers.Rd = "Get the number of workers available", 
#&gt;         nullcon.Rd = "Creates a connection to the system null device", 
#&gt;         pid_exists.Rd = "Check whether a process PID exists or not", 
#&gt;         plan.Rd = "Plan how to resolve a future", private_length.Rd = "Gets the length of an object without dispatching", 
#&gt;         `re-exports.Rd` = "Functions Moved to 'parallelly'", 
#&gt;         readImmediateConditions.Rd = "Read All 'immediateCondition' RDS Files", 
#&gt;         remote.Rd = "Create a remote future whose value will be resolved asynchronously in a remote process", 
#&gt;         requestCore.Rd = "Request a core for multicore processing", 
#&gt;         resetWorkers.Rd = "Free up active background workers", 
#&gt;         resolve.Rd = "Resolve one or more futures synchronously", 
#&gt;         resolved.Rd = "Check whether a future is resolved or not", 
#&gt;         result.Rd = "Get the results of a resolved future", run.Rd = "Run a future", 
#&gt;         save_rds.Rd = "Robustly Saves an Object to RDS File Atomically", 
#&gt;         sequential.Rd = "Create a sequential future whose value will be in the current &lt;span style=\"R\"&gt;R&lt;/span&gt; session", 
#&gt;         sessionDetails.Rd = "Outputs details on the current &lt;span style=\"R\"&gt;R&lt;/span&gt; session", 
#&gt;         signalConditions.Rd = "Signals Captured Conditions", 
#&gt;         sticky_globals.Rd = "Place a sticky-globals environment immediately after the global environment", 
#&gt;         tweak.Rd = "Tweak a future function by adjusting its default arguments", 
#&gt;         usedCores.Rd = "Get number of cores currently used", 
#&gt;         value.Rd = "The value of a future or the values of all elements in a container"
#&gt;         ), rd = list(`ClusterFuture-class.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/ClusterFuture-class.R,", 
#&gt;             "\n", "%   R/MultisessionFuture-class.R", "\n", list(
#&gt;                 "ClusterFuture-class"), "\n", list("ClusterFuture-class"), 
#&gt;             "\n", list("ClusterFuture"), "\n", list("MultisessionFuture"), 
#&gt;             "\n", list("MultisessionFuture-class"), "\n", list(
#&gt;                 "A cluster future is a future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "ClusterFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  substitute = TRUE,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  globals = TRUE,\n", "  packages = NULL,\n", 
#&gt;                 "  local = !persistent,\n", "  persistent = FALSE,\n", 
#&gt;                 "  workers = NULL,\n", "  user = NULL,\n", "  master = NULL,\n", 
#&gt;                 "  revtunnel = TRUE,\n", "  homogeneous = NULL,\n", 
#&gt;                 "  ...\n", ")\n", "\n", "MultisessionFuture(\n", 
#&gt;                 "  expr = NULL,\n", "  substitute = TRUE,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  persistent = FALSE,\n", 
#&gt;                 "  workers = NULL,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An ", list(), 
#&gt;                 " ", list("expression"), ".")), "\n", "\n", list(
#&gt;                 list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("packages"), list(
#&gt;                   "(optional) a character vector specifying packages\n", 
#&gt;                   "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("local"), list("If TRUE, the expression is evaluated such that\n", 
#&gt;                   "all assignments are done to local temporary environment, otherwise\n", 
#&gt;                   "the assignments are done to the global environment of the ", 
#&gt;                   list(), " process\n", "evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("persistent"), list("If FALSE, the evaluation environment is cleared\n", 
#&gt;                   "from objects prior to the evaluation of the future.")), 
#&gt;                 "\n", "\n", list(list("workers"), list("A ", 
#&gt;                   list(list("cluster")), " object,\n", "a character vector of host names, a positive numeric scalar,\n", 
#&gt;                   "or a function.\n", "If a character vector or a numeric scalar, a ", 
#&gt;                   list("cluster"), " object\n", "is created using ", 
#&gt;                   list(list("makeClusterPSOCK"), "(workers)"), 
#&gt;                   ".\n", "If a function, it is called without arguments ", 
#&gt;                   list("when the future\n", "is created"), " and its value is used to configure the workers.\n", 
#&gt;                   "The function should return any of the above types.")), 
#&gt;                 "\n", "\n", list(list("user"), list("(optional) The user name to be used when communicating\n", 
#&gt;                   "with another host.")), "\n", "\n", list(list(
#&gt;                   "master"), list("(optional) The hostname or IP address of the master\n", 
#&gt;                   "machine running this node.")), "\n", "\n", 
#&gt;                 list(list("revtunnel"), list("If TRUE, reverse SSH tunneling is used for the\n", 
#&gt;                   "PSOCK cluster nodes to connect back to the master ", 
#&gt;                   list(), " process.  This\n", "avoids the hassle of firewalls, port forwarding and having to know\n", 
#&gt;                   "the internal / public IP address of the master ", 
#&gt;                   list(), " session.")), "\n", "\n", list(list(
#&gt;                   "homogeneous"), list("If TRUE, all cluster nodes is assumed to use the\n", 
#&gt;                   "same path to ", list("Rscript"), " as the main ", 
#&gt;                   list(), " session.  If FALSE, the\n", "it is assumed to be on the PATH for each node.\n", 
#&gt;                   "If NULL, then ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                   " will decide on TRUE\n", "or FALSE depending on ", 
#&gt;                   list("workers"), ".")), "\n", "\n", list(list(
#&gt;                   "..."), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", list("ClusterFuture()"), " returns an object of class ", 
#&gt;                 list("ClusterFuture"), ".\n", "\n", list("MultisessionFuture()"), 
#&gt;                 " returns an object of class\n", list("MultisessionFuture"), 
#&gt;                 ", which inherits from ", list("ClusterFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "A cluster future is a future whose value will be resolved asynchronously in a parallel process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"cluster future\", see function\n", 
#&gt;                 list(list("cluster()")), ".\n"), "\n", list("internal"), 
#&gt;             "\n"), `ConstantFuture-class.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/ConstantFuture-class.R", 
#&gt;             "\n", list("ConstantFuture-class"), "\n", list("ConstantFuture-class"), 
#&gt;             "\n", list("ConstantFuture"), "\n", list("A future with a constant value"), 
#&gt;             "\n", list("\n", "ConstantFuture(..., globals = TRUE, envir = emptyenv())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Additional named elements of the future.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("envir"), list(
#&gt;                   "The ", list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n"), "\n", list("\n", "An object of class ", 
#&gt;                 list("ConstantFuture"), ".\n"), "\n", list("\n", 
#&gt;                 "A constant future is a future whose expression is a constant\n", 
#&gt;                 "and therefore by definition is already resolved upon creation.\n"), 
#&gt;             "\n", list("internal"), "\n"), `Future-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/Future-class.R", 
#&gt;             "\n", list("Future-class"), "\n", list("Future-class"), 
#&gt;             "\n", list("Future"), "\n", list("A future represents a value that will be available at some point in the future"), 
#&gt;             "\n", list("\n", "Future(\n", "  expr = NULL,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  substitute = TRUE,\n", 
#&gt;                 "  stdout = TRUE,\n", "  conditions = \"condition\",\n", 
#&gt;                 "  globals = NULL,\n", "  packages = NULL,\n", 
#&gt;                 "  seed = FALSE,\n", "  lazy = FALSE,\n", "  local = TRUE,\n", 
#&gt;                 "  gc = FALSE,\n", "  earlySignal = FALSE,\n", 
#&gt;                 "  label = NULL,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An ", list(), 
#&gt;                 " ", list("expression"), ".")), "\n", "\n", list(
#&gt;                 list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("stdout"), list("If TRUE (default), then the standard output is captured,\n", 
#&gt;                   "and re-outputted when ", list("value()"), 
#&gt;                   " is called.\n", "If FALSE, any output is silenced (by sinking it to the null device as\n", 
#&gt;                   "it is outputted).\n", "If NA (not recommended), output is ", 
#&gt;                   list("not"), " intercepted.")), "\n", "\n", 
#&gt;                 list(list("conditions"), list("A character string of conditions classes to be captured\n", 
#&gt;                   "and relayed.  The default is to relay messages and warnings.\n", 
#&gt;                   "To not intercept any types of conditions, use ", 
#&gt;                   list("conditions = NULL"), ".\n", "Attribute ", 
#&gt;                   list("exclude"), " can be used to ignore specific classes, e.g.\n", 
#&gt;                   list("conditions = structure(\"condition\", exclude = \"message\")"), 
#&gt;                   " will capture\n", "all ", list("condition"), 
#&gt;                   " classes except those that inherits from the ", 
#&gt;                   list("message"), " class.\n", "Errors are always relayed.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("packages"), list(
#&gt;                   "(optional) a character vector specifying packages\n", 
#&gt;                   "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("seed"), list("(optional) If TRUE, the random seed, that is, the state of the\n", 
#&gt;                   "random number generator (RNG) will be set such that statistically sound\n", 
#&gt;                   "random numbers are produced (also during parallelization).\n", 
#&gt;                   "If FALSE (default), it is assumed that the future expression does neither\n", 
#&gt;                   "need nor use random numbers generation.\n", 
#&gt;                   "To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\n", 
#&gt;                   "or a regular RNG seed (a single integer).  If the latter, then a\n", 
#&gt;                   "L'Ecuyer-CMRG seed will be automatically created based on the given seed.\n", 
#&gt;                   "Furthermore, if FALSE, then the future will be monitored to make sure it\n", 
#&gt;                   "does not use random numbers.  If it does and depending on the value of\n", 
#&gt;                   "option ", list(list("future.rng.onMisuse")), 
#&gt;                   ", the check is\n", "ignored, an informative warning, or error will be produced.\n", 
#&gt;                   "If ", list("seed"), " is NULL, then the effect is as with ", 
#&gt;                   list("seed = FALSE"), "\n", "but without the RNG check being performed.")), 
#&gt;                 "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                 "\n", "\n", list(list("local"), list("If TRUE, the expression is evaluated such that\n", 
#&gt;                   "all assignments are done to local temporary environment, otherwise\n", 
#&gt;                   "the assignments are done to the global environment of the ", 
#&gt;                   list(), " process\n", "evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("gc"), list("If TRUE, the garbage collector run (in the process that\n", 
#&gt;                   "evaluated the future) only after the value of the future is collected.\n", 
#&gt;                   "Exactly when the values are collected may depend on various factors such\n", 
#&gt;                   "as number of free workers and whether ", list(
#&gt;                     "earlySignal"), " is TRUE (more\n", "frequently) or FALSE (less frequently).\n", 
#&gt;                   list("Some types of futures ignore this argument."))), 
#&gt;                 "\n", "\n", list(list("earlySignal"), list("Specified whether conditions should be signaled as soon\n", 
#&gt;                   "as possible or not.")), "\n", "\n", list(list(
#&gt;                   "label"), list("An optional character string label attached to the future.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Additional named elements of the future.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class ", 
#&gt;                 list("Future"), ".\n"), "\n", list("\n", "A ", 
#&gt;                 list("future"), " is an abstraction for a ", 
#&gt;                 list("value"), " that may\n", "available at some point in the future.  A future can either be\n", 
#&gt;                 list("unresolved"), " or ", list("resolved"), 
#&gt;                 ", a state which can be checked\n", "with ", 
#&gt;                 list(list("resolved()")), ".  As long as it is ", 
#&gt;                 list("unresolved"), ", the\n", "value is not available.  As soon as it is ", 
#&gt;                 list("resolved"), ", the value\n", "is available via ", 
#&gt;                 list(list("value"), "()"), ".\n"), "\n", list(
#&gt;                 "\n", "A Future object is itself an ", list("environment"), 
#&gt;                 ".\n"), "\n", list("\n", "One function that creates a Future is ", 
#&gt;                 list(list("future()")), ".\n", "It returns a Future that evaluates an ", 
#&gt;                 list(), " expression in the future.\n", "An alternative approach is to use the ", 
#&gt;                 list(list("%&lt;-%")), " infix\n", "assignment operator, which creates a future from the\n", 
#&gt;                 "right-hand-side (RHS) ", list(), " expression and assigns its future value\n", 
#&gt;                 "to a variable as a ", list(list("promise")), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), FutureCondition.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/FutureCondition-class.R", 
#&gt;             "\n", list("FutureCondition"), "\n", list("FutureCondition"), 
#&gt;             "\n", list("FutureMessage"), "\n", list("FutureWarning"), 
#&gt;             "\n", list("FutureError"), "\n", list("RngFutureCondition"), 
#&gt;             "\n", list("RngFutureWarning"), "\n", list("RngFutureError"), 
#&gt;             "\n", list("UnexpectedFutureResultError"), "\n", 
#&gt;             list("A condition (message, warning, or error) that occurred while orchestrating a future"), 
#&gt;             "\n", list("\n", "FutureCondition(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "FutureMessage(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "FutureWarning(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "FutureError(message, call = NULL, uuid = future$uuid, future = NULL)\n", 
#&gt;                 "\n", "RngFutureCondition(\n", "  message = NULL,\n", 
#&gt;                 "  call = NULL,\n", "  uuid = future$uuid,\n", 
#&gt;                 "  future = NULL\n", ")\n", "\n", "RngFutureWarning(...)\n", 
#&gt;                 "\n", "RngFutureError(...)\n", "\n", "UnexpectedFutureResultError(future, hint = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("message"), list("A message condition.")), 
#&gt;                 "\n", "\n", list(list("call"), list("The call stack that led up to the condition.")), 
#&gt;                 "\n", "\n", list(list("uuid"), list("A universally unique identifier for the future associated with\n", 
#&gt;                   "this FutureCondition.")), "\n", "\n", list(
#&gt;                   list("future"), list("The ", list("Future"), 
#&gt;                     " involved.")), "\n", "\n", list(list("hint"), 
#&gt;                   list("(optional) A string with a suggestion on what might be wrong.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class FutureCondition which inherits from class\n", 
#&gt;                 list("condition"), " and FutureMessage, FutureWarning,\n", 
#&gt;                 "and FutureError all inherits from FutureCondition.\n", 
#&gt;                 "Moreover, a FutureError inherits from ", list(
#&gt;                   "error"), ",\n", "a FutureWarning from ", list(
#&gt;                   "warning"), ", and\n", "a FutureMessage from ", 
#&gt;                 list("message"), ".\n"), "\n", list("\n", "While ", 
#&gt;                 list("orchestrating"), " (creating, launching, querying, collection)\n", 
#&gt;                 "futures, unexpected run-time errors (and other types of conditions) may\n", 
#&gt;                 "occur.  Such conditions are coerced to a corresponding FutureCondition\n", 
#&gt;                 "class to help distinguish them from conditions that occur due to the\n", 
#&gt;                 list("evaluation"), " of the future.\n"), "\n", 
#&gt;             list("internal"), "\n"), FutureGlobals.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/FutureGlobals-class.R", 
#&gt;             "\n", list("FutureGlobals"), "\n", list("FutureGlobals"), 
#&gt;             "\n", list("as.FutureGlobals"), "\n", list("as.FutureGlobals.FutureGlobals"), 
#&gt;             "\n", list("as.FutureGlobals.Globals"), "\n", list(
#&gt;                 "as.FutureGlobals.list"), "\n", list("[.FutureGlobals"), 
#&gt;             "\n", list("c.FutureGlobals"), "\n", list("unique.FutureGlobals"), 
#&gt;             "\n", list("A representation of a set of globals used with futures"), 
#&gt;             "\n", list("\n", "FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)\n"), 
#&gt;             "\n", list("\n", list(list("object"), list("A named list.")), 
#&gt;                 "\n", "\n", list(list("resolved"), list("A logical indicating whether these globals\n", 
#&gt;                   "have been scanned for and resolved futures or not.")), 
#&gt;                 "\n", "\n", list(list("total_size"), list("The total size of all globals, if known.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class ", 
#&gt;                 list("FutureGlobals"), ".\n"), "\n", list("\n", 
#&gt;                 "A representation of a set of globals used with futures\n"), 
#&gt;             "\n", list("\n", "This class extends the ", list(
#&gt;                 "Globals"), " class by adding\n", "attributes ", 
#&gt;                 list("resolved"), " and ", list("total_size"), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), FutureResult.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/FutureResult-class.R", 
#&gt;             "\n", list("FutureResult"), "\n", list("FutureResult"), 
#&gt;             "\n", list("as.character.FutureResult"), "\n", list(
#&gt;                 "print.FutureResult"), "\n", list("Results from resolving a future"), 
#&gt;             "\n", list("\n", "FutureResult(\n", "  value = NULL,\n", 
#&gt;                 "  visible = TRUE,\n", "  stdout = NULL,\n", 
#&gt;                 "  conditions = NULL,\n", "  rng = FALSE,\n", 
#&gt;                 "  ...,\n", "  started = .POSIXct(NA_real_),\n", 
#&gt;                 "  finished = Sys.time(),\n", "  version = \"1.8\"\n", 
#&gt;                 ")\n", "\n", list(list("as.character"), list(
#&gt;                   "FutureResult")), "(x, ...)\n", "\n", list(
#&gt;                   list("print"), list("FutureResult")), "(x, ...)\n"), 
#&gt;             "\n", list("\n", list(list("value"), list("The value of the future expression.\n", 
#&gt;                 "If the expression was not fully resolved (e.g. an error) occurred,\n", 
#&gt;                 "the the value is ", list("NULL"), ".")), "\n", 
#&gt;                 "\n", list(list("visible"), list("If TRUE, the value was visible, otherwise invisible.")), 
#&gt;                 "\n", "\n", list(list("conditions"), list("A list of zero or more list elements each containing\n", 
#&gt;                   "a captured ", list("condition"), " and possibly more meta data such as the\n", 
#&gt;                   "call stack and a timestamp.")), "\n", "\n", 
#&gt;                 list(list("rng"), list("If TRUE, the ", list(
#&gt;                   ".Random.seed"), " was updated from resolving the\n", 
#&gt;                   "future, otherwise not.")), "\n", "\n", list(
#&gt;                   list(list()), list("(optional) Additional named results to be returned.")), 
#&gt;                 "\n", "\n", list(list("started, finished"), list(
#&gt;                   list("POSIXct"), " timestamps\n", "when the evaluation of the future expression was started and finished.")), 
#&gt;                 "\n", "\n", list(list("version"), list("The version format of the results.")), 
#&gt;                 "\n"), "\n", list("\n", "An object of class FutureResult.\n"), 
#&gt;             "\n", list("\n", "Results from resolving a future\n"), 
#&gt;             "\n", list("\n", "This function is only part of the ", 
#&gt;                 list("backend"), " Future API.\n", "This function is ", 
#&gt;                 list("not"), " part of the frontend Future API.\n"), 
#&gt;             "\n", list(list("Note to developers"), list("\n", 
#&gt;                 "\n", "The FutureResult structure is ", list(
#&gt;                   "under development"), " and may change at anytime,\n", 
#&gt;                 "e.g. elements may be renamed or removed.  Because of this, please avoid\n", 
#&gt;                 "accessing the elements directly in code.  Feel free to reach out if you need\n", 
#&gt;                 "to do so in your code.\n")), "\n", "\n", list(
#&gt;                 "internal"), "\n"), `MulticoreFuture-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/MulticoreFuture-class.R", 
#&gt;             "\n", list("MulticoreFuture-class"), "\n", list("MulticoreFuture-class"), 
#&gt;             "\n", list("MulticoreFuture"), "\n", list("A multicore future is a future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "MulticoreFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  substitute = TRUE,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  globals = TRUE,\n", "  lazy = FALSE,\n", "  ...\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("expr"), list(
#&gt;                 "An ", list(), " ", list("expression"), ".")), 
#&gt;                 "\n", "\n", list(list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                   "to control how globals are handled.\n", "For details, see section 'Globals used by future expressions'\n", 
#&gt;                   "in the help for ", list(list("future()")), 
#&gt;                   ".")), "\n", "\n", list(list("lazy"), list(
#&gt;                   "If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "An object of class ", list("MulticoreFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "A multicore future is a future whose value will be resolved asynchronously in a parallel process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"multicore future\", see function\n", 
#&gt;                 list(list("multicore()")), ".\n"), "\n", list(
#&gt;                 "internal"), "\n"), `MultiprocessFuture-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/MultiprocessFuture-class.R", 
#&gt;             "\n", list("MultiprocessFuture-class"), "\n", list(
#&gt;                 "MultiprocessFuture-class"), "\n", list("MultiprocessFuture"), 
#&gt;             "\n", list("A multiprocess future is a future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An ", list(), 
#&gt;                 " ", list("expression"), ".")), "\n", "\n", list(
#&gt;                 list("substitute"), list("If TRUE, argument ", 
#&gt;                   list("expr"), " is\n", list(list("substitute"), 
#&gt;                     "()"), ":ed, otherwise not.")), "\n", "\n", 
#&gt;                 list(list("envir"), list("The ", list("environment"), 
#&gt;                   " from where global objects should be\n", "identified.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "An object of class ", list("MultiprocessFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"multiprocess future\", see function\n", 
#&gt;                 list(list("multiprocess()")), ".\n"), "\n", list(
#&gt;                 "internal"), "\n"), `UniprocessFuture-class.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/UniprocessFuture-class.R", 
#&gt;             "\n", list("UniprocessFuture-class"), "\n", list(
#&gt;                 "UniprocessFuture-class"), "\n", list("UniprocessFuture"), 
#&gt;             "\n", list("SequentialFuture"), "\n", list("TransparentFuture"), 
#&gt;             "\n", list("An uniprocess future is a future whose value will be resolved synchronously in the current process"), 
#&gt;             "\n", list("\n", "UniprocessFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  substitute = TRUE,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  globals = TRUE,\n", "  packages = NULL,\n", 
#&gt;                 "  lazy = FALSE,\n", "  local = TRUE,\n", "  ...\n", 
#&gt;                 ")\n", "\n", "SequentialFuture(\n", "  expr = NULL,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  substitute = TRUE,\n", 
#&gt;                 "  lazy = FALSE,\n", "  globals = TRUE,\n", "  local = TRUE,\n", 
#&gt;                 "  ...\n", ")\n", "\n", "TransparentFuture(\n", 
#&gt;                 "  expr = NULL,\n", "  envir = parent.frame(),\n", 
#&gt;                 "  substitute = TRUE,\n", "  lazy = FALSE,\n", 
#&gt;                 "  globals = TRUE,\n", "  local = FALSE,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "expr"), list("An ", list(), " ", list("expression"), 
#&gt;                 ".")), "\n", "\n", list(list("substitute"), list(
#&gt;                 "If TRUE, argument ", list("expr"), " is\n", 
#&gt;                 list(list("substitute"), "()"), ":ed, otherwise not.")), 
#&gt;                 "\n", "\n", list(list("envir"), list("The ", 
#&gt;                   list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n", "\n", list(list("globals"), 
#&gt;                   list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                     "to control how globals are handled.\n", 
#&gt;                     "For details, see section 'Globals used by future expressions'\n", 
#&gt;                     "in the help for ", list(list("future()")), 
#&gt;                     ".")), "\n", "\n", list(list("packages"), 
#&gt;                   list("(optional) a character vector specifying packages\n", 
#&gt;                     "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                 "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                 "\n", "\n", list(list("local"), list("If TRUE, the expression is evaluated such that\n", 
#&gt;                   "all assignments are done to local temporary environment, otherwise\n", 
#&gt;                   "the assignments are done to the global environment of the ", 
#&gt;                   list(), " process\n", "evaluating the future.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "An object of class ", list("UniprocessFuture"), 
#&gt;                 ".\n"), "\n", list("\n", "An uniprocess future is a future whose value will be resolved synchronously in the current process\n"), 
#&gt;             "\n", list("\n", "To evaluate an expression using \"uniprocess future\", see functions\n", 
#&gt;                 list(list("uniprocess()")), ".\n"), "\n", list(
#&gt;                 "internal"), "\n"), as_lecyer_cmrg_seed.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/rng.R", "\n", list(
#&gt;                 "as_lecyer_cmrg_seed"), "\n", list("as_lecyer_cmrg_seed"), 
#&gt;             "\n", list("is_lecyer_cmrg_seed"), "\n", list("Get a L'Ecuyer-CMRG seed either from an input seed or the current RNG state"), 
#&gt;             "\n", list("\n", "as_lecyer_cmrg_seed(seed)\n", "\n", 
#&gt;                 "is_lecyer_cmrg_seed(seed)\n"), "\n", list("\n", 
#&gt;                 list(list("seed"), list("TRUE or NA, or a numeric vector of length one or seven.")), 
#&gt;                 "\n"), "\n", list("\n", list("as_lecyer_cmrg_seed(seed)"), 
#&gt;                 " returns a L'Ecuyer-CMRG seed, which is a\n", 
#&gt;                 "7-digit integer vector, based on the input ", 
#&gt;                 list("seed"), ".\n", "If already a L'Ecuyer-CMRG seed, then ", 
#&gt;                 list("seed"), " is return as-is.\n", "If a scalar integer, then a random L'Ecuyer-CMRG seed is created based\n", 
#&gt;                 "on this seed as the current RNG state.\n", "If ", 
#&gt;                 list("seed = TRUE"), " and the current seed is already a L'Ecuyer-CMRG seed,\n", 
#&gt;                 "then then current seed (", list(".Random.seed"), 
#&gt;                 ") is return as-is.\n", "If ", list("seed = TRUE"), 
#&gt;                 " and the current seed is ", list("not"), " of the 'L'Ecuyer-CMRG' kind,\n", 
#&gt;                 "or ", list("seed = NA"), ", then a random one is created (based on the current RNG\n", 
#&gt;                 "state).\n", "Any other values, including FALSE, is an error.\n", 
#&gt;                 "\n", list("is_lecyer_cmrg_seed(seed)"), " returns TRUE if ", 
#&gt;                 list("seed"), " is L'Ecuyer-CMRG seed,\n", "otherwise FALSE.\n"), 
#&gt;             "\n", list("\n", "Get a L'Ecuyer-CMRG seed either from an input seed or the current RNG state\n"), 
#&gt;             "\n", list("\n", "The ", list("as_lecyer_cmrg_seed()"), 
#&gt;                 " function preserves the current RNG state, that\n", 
#&gt;                 "is, it leaves ", list("globalenv()$.Random.seed"), 
#&gt;                 " intact, which means it also leaved\n", "the RNG kind (", 
#&gt;                 list("RNGkind()"), ") intact.\n", "\n", "Per ", 
#&gt;                 list(list("base::RNGkind()")), ", a L'Ecuyer-CMRG seed comprise a length-seven integer\n", 
#&gt;                 "vector of format ", list(".Random.seed &lt;- c(rng.kind, n)"), 
#&gt;                 " where ", list("length(n) == 6L"), " and ", 
#&gt;                 list("rng.kind"), " fulfills ", list("rng.kind %% 10000L == 407L"), 
#&gt;                 ".\n"), "\n", list("\n", "# The current RNG kind\n", 
#&gt;                 "okind &lt;- RNGkind()\n", "oseed &lt;- globalenv()$.Random.seed\n", 
#&gt;                 "\n", "# (a) A L'Ecuyer-CMRG seed based on a numeric-scalar seed\n", 
#&gt;                 "seed1 &lt;- future:::as_lecyer_cmrg_seed(42)\n", 
#&gt;                 "str(seed1)\n", "## int [1:7] 10407 -2133391687 507561766 1260545903 1362917092 -1772566379 -1344458670\n", 
#&gt;                 "# The RNG kind and the RNG state is preserved\n", 
#&gt;                 "stopifnot(\n", "  future:::is_lecyer_cmrg_seed(seed1),\n", 
#&gt;                 "  identical(RNGkind(), okind),\n", "  identical(globalenv()$.Random.seed, oseed)\n", 
#&gt;                 ")\n", "\n", "# (b) A L'Ecuyer-CMRG seed based on a L'Ecuyer-CMRG seed\n", 
#&gt;                 "seed2 &lt;- future:::as_lecyer_cmrg_seed(seed1)\n", 
#&gt;                 "str(seed2)\n", "## int [1:7] 10407 -2133391687 507561766 1260545903 1362917092 -1772566379 -1344458670\n", 
#&gt;                 "# The input L'Ecuyer-CMRG seed is returned as-is\n", 
#&gt;                 "stopifnot(identical(seed2, seed1))\n", "# The RNG kind and the RNG state is preserved\n", 
#&gt;                 "stopifnot(\n", "  future:::is_lecyer_cmrg_seed(seed2),\n", 
#&gt;                 "  identical(RNGkind(), okind),\n", "  identical(globalenv()$.Random.seed, oseed)\n", 
#&gt;                 ")\n", "\n", "# (c) A L'Ecuyer-CMRG seed based on the current RNG state\n", 
#&gt;                 "seed3 &lt;- future:::as_lecyer_cmrg_seed(TRUE)\n", 
#&gt;                 "str(seed3)\n", "## int [1:7] 10407 495333909 -1491719214 416071979 49340016 1956499377 899435966\n", 
#&gt;                 "stopifnot(future:::is_lecyer_cmrg_seed(seed3))\n", 
#&gt;                 "\n", "\n", "# All of the above calls preserve the RNG state including the RNG kind\n", 
#&gt;                 "stopifnot(\n", "  identical(RNGkind(), okind),\n", 
#&gt;                 "  identical(globalenv()$.Random.seed, oseed)\n", 
#&gt;                 ")\n"), "\n", list("internal"), "\n"), backtrace.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/backtrace.R", "\n", 
#&gt;             list("backtrace"), "\n", list("backtrace"), "\n", 
#&gt;             list("Back trace the expressions evaluated when an error was caught"), 
#&gt;             "\n", list("\n", "backtrace(future, envir = parent.frame(), ...)\n"), 
#&gt;             "\n", list("\n", list(list("future"), list("A future with a caught error.")), 
#&gt;                 "\n", "\n", list(list("envir"), list("the environment where to locate the future.")), 
#&gt;                 "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                 "\n"), "\n", list("\n", "A list with the future's call stack that led up to the error.\n"), 
#&gt;             "\n", list("\n", "Back trace the expressions evaluated when an error was caught\n"), 
#&gt;             "\n", list("\n", "my_log &lt;- function(x) log(x)\n", 
#&gt;                 "foo &lt;- function(...) my_log(...)\n", "\n", "f &lt;- future({ foo(\"a\") })\n", 
#&gt;                 "res &lt;- tryCatch({\n", "  v &lt;- value(f)\n", "}, error = function(ex) {\n", 
#&gt;                 "  t &lt;- backtrace(f)\n", "  print(t)\n", "})\n", 
#&gt;                 list("\n", "## R CMD check: make sure any open connections are closed afterward\n", 
#&gt;                   "if (!inherits(plan(\"next\"), \"sequential\")) plan(sequential)\n"), 
#&gt;                 "\n", "\n"), "\n"), cluster.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cluster.R", 
#&gt;             "\n", list("cluster"), "\n", list("cluster"), "\n", 
#&gt;             list("Create a cluster future whose value will be resolved asynchronously in a parallel process"), 
#&gt;             "\n", list("\n", "cluster(..., workers = availableWorkers(), envir = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list(list()), list("Additional named elements passed to ", 
#&gt;                 list(list("ClusterFuture()")), ".")), "\n", "\n", 
#&gt;                 list(list("workers"), list("A ", list(list("cluster")), 
#&gt;                   " object,\n", "a character vector of host names, a positive numeric scalar,\n", 
#&gt;                   "or a function.\n", "If a character vector or a numeric scalar, a ", 
#&gt;                   list("cluster"), " object\n", "is created using ", 
#&gt;                   list(list("makeClusterPSOCK"), "(workers)"), 
#&gt;                   ".\n", "If a function, it is called without arguments ", 
#&gt;                   list("when the future\n", "is created"), " and its value is used to configure the workers.\n", 
#&gt;                   "The function should return any of the above types.")), 
#&gt;                 "\n", "\n", list(list("envir"), list("The ", 
#&gt;                   list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n"), "\n", list("\n", "A ", 
#&gt;                 list("ClusterFuture"), ".\n"), "\n", list("\n", 
#&gt;                 "A cluster future is a future that uses cluster evaluation,\n", 
#&gt;                 "which means that its ", list("value is computed and resolved in\n", 
#&gt;                   "parallel in another process"), ".\n"), "\n", 
#&gt;             list("\n", "This function is ", list("not"), " meant to be called directly.  Instead, the\n", 
#&gt;                 "typical usages are:", list(list("html"), list(
#&gt;                   list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures via a single background R process on the local machine\n", 
#&gt;                   "plan(cluster, workers = 1)\n", "\n", "# Evaluate futures via two background R processes on the local machine\n", 
#&gt;                   "plan(cluster, workers = 2)\n", "\n", "# Evaluate futures via a single R process on another machine on on the\n", 
#&gt;                   "# local area network (LAN)\n", "plan(cluster, workers = \"raspberry-pi\")\n", 
#&gt;                   "\n", "# Evaluate futures via a single R process running on a remote machine\n", 
#&gt;                   "plan(cluster, workers = \"pi.example.org\")\n", 
#&gt;                   "\n", "# Evaluate futures via four R processes, one running on the local machine,\n", 
#&gt;                   "# two running on LAN machine 'n1' and one on a remote machine\n", 
#&gt;                   "plan(cluster, workers = c(\"localhost\", \"n1\", \"n1\", \"pi.example.org\")\n"), 
#&gt;                 list(list("html"), list(list("&lt;/div&gt;"))), "\n"), 
#&gt;             "\n", list("\n", list("\n", "\n", "## Use cluster futures\n", 
#&gt;                 "cl &lt;- parallel::makeCluster(2, timeout = 60)\n", 
#&gt;                 "plan(cluster, workers = cl)\n", "\n", "## A global variable\n", 
#&gt;                 "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                 "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                 "  a * b * c\n", "})\n", "\n", "## A cluster future is evaluated in a separate process.\n", 
#&gt;                 "## Regardless, changing the value of a global variable will\n", 
#&gt;                 "## not affect the result of the future.\n", 
#&gt;                 "a &lt;- 7\n", "print(a)\n", "\n", "v &lt;- value(f)\n", 
#&gt;                 "print(v)\n", "stopifnot(v == 0)\n", "\n", "## CLEANUP\n", 
#&gt;                 "parallel::stopCluster(cl)\n", "\n"), "\n"), 
#&gt;             "\n"), clusterExportSticky.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sticky_globals.R", 
#&gt;             "\n", list("clusterExportSticky"), "\n", list("clusterExportSticky"), 
#&gt;             "\n", list("Export globals to the sticky-globals environment of the cluster nodes"), 
#&gt;             "\n", list("\n", "clusterExportSticky(cl, globals)\n"), 
#&gt;             "\n", list("\n", list(list("cl"), list("(cluster) A cluster object as returned by\n", 
#&gt;                 list(list("parallel::makeCluster()")), ".")), 
#&gt;                 "\n", "\n", list(list("globals"), list("(list) A named list of sticky globals to be exported.")), 
#&gt;                 "\n"), "\n", list("\n", "(invisible; cluster) The cluster object.\n"), 
#&gt;             "\n", list("\n", "Export globals to the sticky-globals environment of the cluster nodes\n"), 
#&gt;             "\n", list("\n", "This requires that the ", list(
#&gt;                 "future"), " package is installed on the cluster\n", 
#&gt;                 "nodes.\n"), "\n", list("internals"), "\n"), 
#&gt;             find_references.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils-marshalling.R", 
#&gt;                 "\n", list("find_references"), "\n", list("find_references"), 
#&gt;                 "\n", list("assert_no_references"), "\n", list(
#&gt;                   "Get the first or all references of an ", list(), 
#&gt;                   " object"), "\n", list("\n", "find_references(x, first_only = FALSE)\n", 
#&gt;                   "\n", "assert_no_references(\n", "  x,\n", 
#&gt;                   "  action = c(\"error\", \"warning\", \"message\", \"string\"),\n", 
#&gt;                   "  source = c(\"globals\", \"value\")\n", ")\n"), 
#&gt;                 "\n", list("\n", list(list("x"), list("The ", 
#&gt;                   list(), " object to be checked.")), "\n", "\n", 
#&gt;                   list(list("first_only"), list("If ", list("TRUE"), 
#&gt;                     ", only the first reference is returned,\n", 
#&gt;                     "otherwise all references.")), "\n", "\n", 
#&gt;                   list(list("action"), list("Type of action to take if a reference is found.")), 
#&gt;                   "\n", "\n", list(list("source"), list("Is the source of ", 
#&gt;                     list("x"), " the globals or the value of the future?")), 
#&gt;                   "\n"), "\n", list("\n", list("find_references()"), 
#&gt;                   " returns a list of zero or more references\n", 
#&gt;                   "identified.\n", "\n", "If a reference is detected, an informative error, warning, message,\n", 
#&gt;                   "or a character string is produced, otherwise ", 
#&gt;                   list("NULL"), " is returned\n", "invisibly.\n"), 
#&gt;                 "\n", list("\n", "Get the first or all references of an ", 
#&gt;                   list(), " object\n", "\n", "Assert that there are no references among the identified globals\n"), 
#&gt;                 "\n", list("internal"), "\n"), future.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/future.R, R/futureAssign.R,", 
#&gt;                 "\n", "%   R/futureAssign_OP.R, R/futureCall.R", 
#&gt;                 "\n", list("future"), "\n", list("future"), "\n", 
#&gt;                 list("futureCall"), "\n", list("futureAssign"), 
#&gt;                 "\n", list("%&lt;-%"), "\n", list("%-&gt;%"), "\n", 
#&gt;                 list("Create a future"), "\n", list("\n", "future(\n", 
#&gt;                   "  expr,\n", "  envir = parent.frame(),\n", 
#&gt;                   "  substitute = TRUE,\n", "  lazy = FALSE,\n", 
#&gt;                   "  seed = FALSE,\n", "  globals = TRUE,\n", 
#&gt;                   "  packages = NULL,\n", "  stdout = TRUE,\n", 
#&gt;                   "  conditions = \"condition\",\n", "  earlySignal = FALSE,\n", 
#&gt;                   "  label = NULL,\n", "  gc = FALSE,\n", "  ...\n", 
#&gt;                   ")\n", "\n", "futureAssign(\n", "  x,\n", "  value,\n", 
#&gt;                   "  envir = parent.frame(),\n", "  substitute = TRUE,\n", 
#&gt;                   "  lazy = FALSE,\n", "  seed = FALSE,\n", "  globals = TRUE,\n", 
#&gt;                   "  packages = NULL,\n", "  stdout = TRUE,\n", 
#&gt;                   "  conditions = \"condition\",\n", "  earlySignal = FALSE,\n", 
#&gt;                   "  label = NULL,\n", "  gc = FALSE,\n", "  ...,\n", 
#&gt;                   "  assign.env = envir\n", ")\n", "\n", "x %&lt;-% value\n", 
#&gt;                   "\n", "futureCall(\n", "  FUN,\n", "  args = list(),\n", 
#&gt;                   "  envir = parent.frame(),\n", "  lazy = FALSE,\n", 
#&gt;                   "  seed = FALSE,\n", "  globals = TRUE,\n", 
#&gt;                   "  packages = NULL,\n", "  stdout = TRUE,\n", 
#&gt;                   "  conditions = \"condition\",\n", "  earlySignal = FALSE,\n", 
#&gt;                   "  label = NULL,\n", "  gc = FALSE,\n", "  ...\n", 
#&gt;                   ")\n"), "\n", list("\n", list(list("expr, value"), 
#&gt;                   list("An ", list(), " ", list("expression"), 
#&gt;                     ".")), "\n", "\n", list(list("envir"), list(
#&gt;                   "The ", list("environment"), " from where global objects should be\n", 
#&gt;                   "identified.")), "\n", "\n", list(list("substitute"), 
#&gt;                   list("If TRUE, argument ", list("expr"), " is\n", 
#&gt;                     list(list("substitute"), "()"), ":ed, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                     "eagerly (starting immediately), otherwise not.")), 
#&gt;                   "\n", "\n", list(list("seed"), list("(optional) If TRUE, the random seed, that is, the state of the\n", 
#&gt;                     "random number generator (RNG) will be set such that statistically sound\n", 
#&gt;                     "random numbers are produced (also during parallelization).\n", 
#&gt;                     "If FALSE (default), it is assumed that the future expression does neither\n", 
#&gt;                     "need nor use random numbers generation.\n", 
#&gt;                     "To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\n", 
#&gt;                     "or a regular RNG seed (a single integer).  If the latter, then a\n", 
#&gt;                     "L'Ecuyer-CMRG seed will be automatically created based on the given seed.\n", 
#&gt;                     "Furthermore, if FALSE, then the future will be monitored to make sure it\n", 
#&gt;                     "does not use random numbers.  If it does and depending on the value of\n", 
#&gt;                     "option ", list(list("future.rng.onMisuse")), 
#&gt;                     ", the check is\n", "ignored, an informative warning, or error will be produced.\n", 
#&gt;                     "If ", list("seed"), " is NULL, then the effect is as with ", 
#&gt;                     list("seed = FALSE"), "\n", "but without the RNG check being performed.")), 
#&gt;                   "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                     "to control how globals are handled.\n", 
#&gt;                     "For details, see section 'Globals used by future expressions'\n", 
#&gt;                     "in the help for ", list(list("future()")), 
#&gt;                     ".")), "\n", "\n", list(list("packages"), 
#&gt;                     list("(optional) a character vector specifying packages\n", 
#&gt;                       "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                   "\n", "\n", list(list("stdout"), list("If TRUE (default), then the standard output is captured,\n", 
#&gt;                     "and re-outputted when ", list("value()"), 
#&gt;                     " is called.\n", "If FALSE, any output is silenced (by sinking it to the null device as\n", 
#&gt;                     "it is outputted).\n", "If NA (not recommended), output is ", 
#&gt;                     list("not"), " intercepted.")), "\n", "\n", 
#&gt;                   list(list("conditions"), list("A character string of conditions classes to be captured\n", 
#&gt;                     "and relayed.  The default is to relay messages and warnings.\n", 
#&gt;                     "To not intercept any types of conditions, use ", 
#&gt;                     list("conditions = NULL"), ".\n", "Attribute ", 
#&gt;                     list("exclude"), " can be used to ignore specific classes, e.g.\n", 
#&gt;                     list("conditions = structure(\"condition\", exclude = \"message\")"), 
#&gt;                     " will capture\n", "all ", list("condition"), 
#&gt;                     " classes except those that inherits from the ", 
#&gt;                     list("message"), " class.\n", "Errors are always relayed.")), 
#&gt;                   "\n", "\n", list(list("earlySignal"), list(
#&gt;                     "Specified whether conditions should be signaled as soon\n", 
#&gt;                     "as possible or not.")), "\n", "\n", list(
#&gt;                     list("label"), list("An optional character string label attached to the future.")), 
#&gt;                   "\n", "\n", list(list("gc"), list("If TRUE, the garbage collector run (in the process that\n", 
#&gt;                     "evaluated the future) only after the value of the future is collected.\n", 
#&gt;                     "Exactly when the values are collected may depend on various factors such\n", 
#&gt;                     "as number of free workers and whether ", 
#&gt;                     list("earlySignal"), " is TRUE (more\n", 
#&gt;                     "frequently) or FALSE (less frequently).\n", 
#&gt;                     list("Some types of futures ignore this argument."))), 
#&gt;                   "\n", "\n", list(list(list()), list("Additional arguments passed to ", 
#&gt;                     list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("x"), list("the name of a future variable, which will hold the value\n", 
#&gt;                     "of the future expression (as a promise).")), 
#&gt;                   "\n", "\n", list(list("assign.env"), list("The ", 
#&gt;                     list("environment"), " to which the variable\n", 
#&gt;                     "should be assigned.")), "\n", "\n", list(
#&gt;                     list("FUN"), list("A ", list("function"), 
#&gt;                       " to be evaluated.")), "\n", "\n", list(
#&gt;                     list("args"), list("A ", list("list"), " of arguments passed to function ", 
#&gt;                       list("FUN"), ".")), "\n"), "\n", list("\n", 
#&gt;                   list("f &lt;- future(expr)"), " creates a ", list(
#&gt;                     "Future"), " ", list("f"), " that evaluates expression ", 
#&gt;                   list("expr"), ", the value of the future is retrieved using ", 
#&gt;                   list("v &lt;- value(f)"), ".\n", "\n", list("x %&lt;-% value"), 
#&gt;                   " (a future assignment) and\n", list("futureAssign(\"x\", value)"), 
#&gt;                   " create a ", list("Future"), " that evaluates\n", 
#&gt;                   "expression ", list("expr"), " and binds its value (as a\n", 
#&gt;                   list("promise"), ") to\n", "a variable ", list(
#&gt;                     "x"), ".  The value of the future is automatically retrieved\n", 
#&gt;                   "when the assigned variable (promise) is queried.\n", 
#&gt;                   "The future itself is returned invisibly, e.g.\n", 
#&gt;                   list("f &lt;- futureAssign(\"x\", expr)"), " and ", 
#&gt;                   list("f &lt;- (x %&lt;-% expr)"), ".\n", "Alternatively, the future of a future variable ", 
#&gt;                   list("x"), " can be retrieved\n", "without blocking using ", 
#&gt;                   list("f &lt;- ", list("futureOf"), "(x)"), ".\n", 
#&gt;                   "Both the future and the variable (promise) are assigned to environment\n", 
#&gt;                   list("assign.env"), " where the name of the future is ", 
#&gt;                   list(".future_&lt;name&gt;"), ".\n", "\n", list("f &lt;- futureCall(FUN, args)"), 
#&gt;                   " creates a ", list("Future"), " ", list("f"), 
#&gt;                   " that calls function ", list("FUN"), " with arguments ", 
#&gt;                   list("args"), ", where the value of the future is retrieved using ", 
#&gt;                   list("x &lt;- value(f)"), ".\n"), "\n", list("\n", 
#&gt;                   list(list("html"), list(list(list("logo.png"), 
#&gt;                     list("options: align='right' alt='logo' width='120'")))), 
#&gt;                   "\n", "Creates a future that evaluates an ", 
#&gt;                   list(), " expression or\n", "a future that calls an ", 
#&gt;                   list(), " function with a set of arguments.\n", 
#&gt;                   "How, when, and where these futures are evaluated can be configured\n", 
#&gt;                   "using ", list(list("plan()")), " such that it is evaluated in parallel on,\n", 
#&gt;                   "for instance, the current machine, on a remote machine, or via a\n", 
#&gt;                   "job queue on a compute cluster.\n", "Importantly, any ", 
#&gt;                   list(), " code using futures remains the same regardless\n", 
#&gt;                   "on these settings and there is no need to modify the code when\n", 
#&gt;                   "switching from, say, sequential to parallel processing.\n"), 
#&gt;                 "\n", list("\n", "The state of a future is either unresolved or resolved.\n", 
#&gt;                   "The value of a future can be retrieved using ", 
#&gt;                   list("v &lt;- ", list("value"), "(f)"), ".\n", 
#&gt;                   "Querying the value of a non-resolved future will ", 
#&gt;                   list("block"), " the call\n", "until the future is resolved.\n", 
#&gt;                   "It is possible to check whether a future is resolved or not\n", 
#&gt;                   "without blocking by using ", list(list("resolved"), 
#&gt;                     "(f)"), ".\n", "\n", "For a future created via a future assignment\n", 
#&gt;                   "(", list("x %&lt;-% value"), " or ", list("futureAssign(\"x\", value)"), 
#&gt;                   "), the value\n", "is bound to a promise, which when queried will internally call\n", 
#&gt;                   list(list("value()")), "  on the future and which will then be resolved\n", 
#&gt;                   "into a regular variable bound to that value.  For example, with future\n", 
#&gt;                   "assignment ", list("x %&lt;-% value"), ", the first time variable ", 
#&gt;                   list("x"), " is\n", "queried the call blocks if (and only if) the future is not yet resolved.\n", 
#&gt;                   "As soon as it is resolved, and any succeeding queries, querying ", 
#&gt;                   list("x"), "\n", "will immediately give the value.\n", 
#&gt;                   "\n", "The future assignment construct ", list(
#&gt;                     "x %&lt;-% value"), " is not a formal\n", "assignment per se, but a binary infix operator on objects ", 
#&gt;                   list("x"), "\n", "and expression ", list("value"), 
#&gt;                   ".  However, by using non-standard evaluation,\n", 
#&gt;                   "this constructs can emulate an assignment operator similar to\n", 
#&gt;                   list("x &lt;- value"), ". Due to ", list(), "'s precedence rules of operators,\n", 
#&gt;                   "future expressions often need to be explicitly bracketed, e.g.\n", 
#&gt;                   list("x %&lt;-% { a + b }"), ".\n", "\n", "The ", 
#&gt;                   list("futureCall()"), " function works analogously to\n", 
#&gt;                   list(list("do.call"), "()"), ", which calls a function with a set of\n", 
#&gt;                   "arguments.  The difference is that ", list(
#&gt;                     "do.call()"), " returns the value of\n", 
#&gt;                   "the call whereas ", list("futureCall()"), 
#&gt;                   " returns a future.\n"), "\n", list(list("Eager or lazy evaluation"), 
#&gt;                   list("\n", "\n", "By default, a future is resolved using ", 
#&gt;                     list("eager"), " evaluation\n", "(", list(
#&gt;                       "lazy = FALSE"), ").  This means that the expression starts to\n", 
#&gt;                     "be evaluated as soon as the future is created.\n", 
#&gt;                     "\n", "As an alternative, the future can be resolved using ", 
#&gt;                     list("lazy"), "\n", "evaluation (", list(
#&gt;                       "lazy = TRUE"), ").  This means that the expression\n", 
#&gt;                     "will only be evaluated when the value of the future is requested.\n", 
#&gt;                     list("Note that this means that the expression may not be evaluated\n", 
#&gt;                       "at all - it is guaranteed to be evaluated if the value is requested"), 
#&gt;                     ".\n", "\n", "For future assignments, lazy evaluation can be controlled via the\n", 
#&gt;                     list("%lazy%"), " operator, e.g. ", list(
#&gt;                       "x %&lt;-% { expr } %lazy% TRUE"), ".\n")), 
#&gt;                 "\n", "\n", list(list("Globals used by future expressions"), 
#&gt;                   list("\n", "\n", "Global objects (short ", 
#&gt;                     list("globals"), ") are objects (e.g. variables and\n", 
#&gt;                     "functions) that are needed in order for the future expression to be\n", 
#&gt;                     "evaluated while not being local objects that are defined by the future\n", 
#&gt;                     "expression. For example, in\n", list("\n", 
#&gt;                       "  a &lt;- 42\n", "  f &lt;- future({ b &lt;- 2; a * b })\n"), 
#&gt;                     "\n", "variable ", list("a"), " is a global of future assignment ", 
#&gt;                     list("f"), " whereas\n", list("b"), " is a local variable.\n", 
#&gt;                     "In order for the future to be resolved successfully (and correctly),\n", 
#&gt;                     "all globals need to be gathered when the future is created such that\n", 
#&gt;                     "they are available whenever and wherever the future is resolved.\n", 
#&gt;                     "\n", "The default behavior (", list("globals = TRUE"), 
#&gt;                     "),\n", "is that globals are automatically identified and gathered.\n", 
#&gt;                     "More precisely, globals are identified via code inspection of the\n", 
#&gt;                     "future expression ", list("expr"), " and their values are retrieved with\n", 
#&gt;                     "environment ", list("envir"), " as the starting point (basically via\n", 
#&gt;                     list("get(global, envir = envir, inherits = TRUE)"), 
#&gt;                     ").\n", list("In most cases, such automatic collection of globals is sufficient\n", 
#&gt;                       "and less tedious and error prone than if they are manually specified"), 
#&gt;                     ".\n", "\n", "However, for full control, it is also possible to explicitly specify\n", 
#&gt;                     "exactly which the globals are by providing their names as a character\n", 
#&gt;                     "vector.\n", "In the above example, we could use\n", 
#&gt;                     list("\n", "  a &lt;- 42\n", "  f &lt;- future({ b &lt;- 2; a * b }, globals = \"a\")\n"), 
#&gt;                     "\n", "\n", "Yet another alternative is to explicitly specify also their values\n", 
#&gt;                     "using a named list as in\n", list("\n", 
#&gt;                       "  a &lt;- 42\n", "  f &lt;- future({ b &lt;- 2; a * b }, globals = list(a = a))\n"), 
#&gt;                     "\n", "or\n", list("\n", "  f &lt;- future({ b &lt;- 2; a * b }, globals = list(a = 42))\n"), 
#&gt;                     "\n", "\n", "Specifying globals explicitly avoids the overhead added from\n", 
#&gt;                     "automatically identifying the globals and gathering their values.\n", 
#&gt;                     "Furthermore, if we know that the future expression does not make use\n", 
#&gt;                     "of any global variables, we can disable the automatic search for\n", 
#&gt;                     "globals by using\n", list("\n", "  f &lt;- future({ a &lt;- 42; b &lt;- 2; a * b }, globals = FALSE)\n"), 
#&gt;                     "\n", "\n", "Future expressions often make use of functions from one or more packages.\n", 
#&gt;                     "As long as these functions are part of the set of globals, the future\n", 
#&gt;                     "package will make sure that those packages are attached when the future\n", 
#&gt;                     "is resolved.  Because there is no need for such globals to be frozen\n", 
#&gt;                     "or exported, the future package will not export them, which reduces\n", 
#&gt;                     "the amount of transferred objects.\n", "For example, in\n", 
#&gt;                     list("\n", "  x &lt;- rnorm(1000)\n", "  f &lt;- future({ median(x) })\n"), 
#&gt;                     "\n", "variable ", list("x"), " and ", list(
#&gt;                       "median()"), " are globals, but only ", 
#&gt;                     list("x"), "\n", "is exported whereas ", 
#&gt;                     list("median()"), ", which is part of the ", 
#&gt;                     list("stats"), "\n", "package, is not exported.  Instead it is made sure that the ", 
#&gt;                     list("stats"), "\n", "package is on the search path when the future expression is evaluated.\n", 
#&gt;                     "Effectively, the above becomes\n", list(
#&gt;                       "\n", "  x &lt;- rnorm(1000)\n", "  f &lt;- future({\n", 
#&gt;                       "    library(\"stats\")\n", "    median(x)\n", 
#&gt;                       "  })\n"), "\n", "To manually specify this, one can either do\n", 
#&gt;                     list("\n", "  x &lt;- rnorm(1000)\n", "  f &lt;- future({\n", 
#&gt;                       "    median(x)\n", "  }, globals = list(x = x, median = stats::median)\n"), 
#&gt;                     "\n", "or\n", list("\n", "  x &lt;- rnorm(1000)\n", 
#&gt;                       "  f &lt;- future({\n", "    library(\"stats\")\n", 
#&gt;                       "    median(x)\n", "  }, globals = list(x = x))\n"), 
#&gt;                     "\n", "Both are effectively the same.\n", 
#&gt;                     "\n", "Although rarely needed, a combination of automatic identification and manual\n", 
#&gt;                     "specification of globals is supported via attributes ", 
#&gt;                     list("add"), " (to add\n", "false negatives) and ", 
#&gt;                     list("ignore"), " (to ignore false positives) on value\n", 
#&gt;                     list("TRUE"), ".  For example, with\n", list(
#&gt;                       "globals = structure(TRUE, ignore = \"b\", add = \"a\")"), 
#&gt;                     " any globals\n", "automatically identified except ", 
#&gt;                     list("b"), " will be used in addition to\n", 
#&gt;                     "global ", list("a"), ".\n", "\n", "When using future assignments, globals can be specified analogously\n", 
#&gt;                     "using the ", list(list("%globals%")), " operator, e.g.\n", 
#&gt;                     list("\n", "  x &lt;- rnorm(1000)\n", "  y %&lt;-% { median(x) } %globals% list(x = x, median = stats::median)\n"), 
#&gt;                     "\n")), "\n", "\n", list("\n", "## Evaluate futures in parallel\n", 
#&gt;                   "plan(multisession)\n", "\n", "## Data\n", 
#&gt;                   "x &lt;- rnorm(100)\n", "y &lt;- 2 * x + 0.2 + rnorm(100)\n", 
#&gt;                   "w &lt;- 1 + x ^ 2\n", "\n", "\n", "## EXAMPLE: Regular assignments (evaluated sequentially)\n", 
#&gt;                   "fitA &lt;- lm(y ~ x, weights = w)      ## with offset\n", 
#&gt;                   "fitB &lt;- lm(y ~ x - 1, weights = w)  ## without offset\n", 
#&gt;                   "fitC &lt;- {\n", "  w &lt;- 1 + abs(x)  ## Different weights\n", 
#&gt;                   "  lm(y ~ x, weights = w)\n", "}\n", "print(fitA)\n", 
#&gt;                   "print(fitB)\n", "print(fitC)\n", "\n", "\n", 
#&gt;                   "## EXAMPLE: Future assignments (evaluated in parallel)\n", 
#&gt;                   "fitA %&lt;-% lm(y ~ x, weights = w)      ## with offset\n", 
#&gt;                   "fitB %&lt;-% lm(y ~ x - 1, weights = w)  ## without offset\n", 
#&gt;                   "fitC %&lt;-% {\n", "  w &lt;- 1 + abs(x)\n", "  lm(y ~ x, weights = w)\n", 
#&gt;                   "}\n", "print(fitA)\n", "print(fitB)\n", "print(fitC)\n", 
#&gt;                   "\n", "\n", "## EXAMPLE: Explicitly create futures (evaluated in parallel)\n", 
#&gt;                   "## and retrieve their values\n", "fA &lt;- future( lm(y ~ x, weights = w) )\n", 
#&gt;                   "fB &lt;- future( lm(y ~ x - 1, weights = w) )\n", 
#&gt;                   "fC &lt;- future({\n", "  w &lt;- 1 + abs(x)\n", 
#&gt;                   "  lm(y ~ x, weights = w)\n", "})\n", "fitA &lt;- value(fA)\n", 
#&gt;                   "fitB &lt;- value(fB)\n", "fitC &lt;- value(fC)\n", 
#&gt;                   "print(fitA)\n", "print(fitB)\n", "print(fitC)\n", 
#&gt;                   "\n", list("\n", "## Make sure to \"close\" an multisession workers on Windows\n", 
#&gt;                     "plan(sequential)\n"), "\n", "## EXAMPLE: futureCall() and do.call()\n", 
#&gt;                   "x &lt;- 1:100\n", "y0 &lt;- do.call(sum, args = list(x))\n", 
#&gt;                   "print(y0)\n", "\n", "f1 &lt;- futureCall(sum, args = list(x))\n", 
#&gt;                   "y1 &lt;- value(f1)\n", "print(y1)\n"), "\n", 
#&gt;                 list("\n", "How, when and where futures are resolved is given by the\n", 
#&gt;                   list("future strategy"), ", which can be set by the end user using the\n", 
#&gt;                   list(list("plan()")), " function.  The future strategy must not be\n", 
#&gt;                   "set by the developer, e.g. it must not be called within a package.\n"), 
#&gt;                 "\n", list("\n", "The future logo was designed by Dan LaBar and tweaked by Henrik Bengtsson.\n"), 
#&gt;                 "\n"), future.options.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/options.R", 
#&gt;                 "\n", list("future.options"), "\n", list("future.options"), 
#&gt;                 "\n", list("future.cmdargs"), "\n", list(".future.R"), 
#&gt;                 "\n", list("future.startup.script"), "\n", list(
#&gt;                   "R_FUTURE_STARTUP_SCRIPT"), "\n", list("future.debug"), 
#&gt;                 "\n", list("R_FUTURE_DEBUG"), "\n", list("future.demo.mandelbrot.region"), 
#&gt;                 "\n", list("R_FUTURE_DEMO_MANDELBROT_REGION"), 
#&gt;                 "\n", list("future.demo.mandelbrot.nrow"), "\n", 
#&gt;                 list("R_FUTURE_DEMO_MANDELBROT_NROW"), "\n", 
#&gt;                 list("future.fork.multithreading.enable"), "\n", 
#&gt;                 list("R_FUTURE_FORK_MULTITHREADING_ENABLE"), 
#&gt;                 "\n", list("future.globals.maxSize"), "\n", list(
#&gt;                   "R_FUTURE_GLOBALS_MAXSIZE"), "\n", list("future.globals.method"), 
#&gt;                 "\n", list("R_FUTURE_GLOBALS_METHOD"), "\n", 
#&gt;                 list("future.globals.onMissing"), "\n", list(
#&gt;                   "R_FUTURE_GLOBALS_ONMISSING"), "\n", list("future.globals.resolve"), 
#&gt;                 "\n", list("R_FUTURE_GLOBALS_RESOLVE"), "\n", 
#&gt;                 list("future.globals.onReference"), "\n", list(
#&gt;                   "R_FUTURE_GLOBALS_ONREFERENCE"), "\n", list(
#&gt;                   "future.plan"), "\n", list("R_FUTURE_PLAN"), 
#&gt;                 "\n", list("future.resolve.recursive"), "\n", 
#&gt;                 list("R_FUTURE_RNG_ONMISUSE"), "\n", list("future.wait.alpha"), 
#&gt;                 "\n", list("R_FUTURE_WAIT_ALPHA"), "\n", list(
#&gt;                   "future.wait.interval"), "\n", list("R_FUTURE_WAIT_INTERVAL"), 
#&gt;                 "\n", list("future.wait.timeout"), "\n", list(
#&gt;                   "R_FUTURE_WAIT_TIMEOUT"), "\n", list("R_FUTURE_RESOLVED_TIMEOUT"), 
#&gt;                 "\n", list("Options used for futures"), "\n", 
#&gt;                 list("\n", "Below are the ", list(), " options and environment variables that are used by the\n", 
#&gt;                   list("future"), " package and packages enhancing it.", 
#&gt;                   list(), "\n", list(), "\n", list("WARNING: Note that the names and the default values of these options may\n", 
#&gt;                     "change in future versions of the package.  Please use with care until\n", 
#&gt;                     "further notice."), "\n"), "\n", list(list(
#&gt;                   "Settings moved to the 'parallelly' package"), 
#&gt;                   list("\n", "\n", "Several functions have been moved to the ", 
#&gt;                     list("parallelly"), " package:\n", list("\n", 
#&gt;                       list(), " ", list(list("parallelly::availableCores()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::availableWorkers()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::makeClusterMPI()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::makeNodePSOCK()")), 
#&gt;                       "\n", list(), " ", list(list("parallelly::supportsMulticore()")), 
#&gt;                       "\n"), "\n", "\n", "The options and environment variables controlling those have been adjusted\n", 
#&gt;                     "accordingly to have different prefixes.\n", 
#&gt;                     "For example, option ", list("future.fork.enable"), 
#&gt;                     " has been renamed to\n", list("parallelly.fork.enable"), 
#&gt;                     " and the corresponding environment variable\n", 
#&gt;                     list("R_FUTURE_FORK_ENABLE"), " has been renamed to\n", 
#&gt;                     list("R_PARALLELLY_FORK_ENABLE"), ".\n", 
#&gt;                     "For backward compatibility reasons, the ", 
#&gt;                     list("parallelly"), " package will\n", "support both versions for a long foreseeable time.\n", 
#&gt;                     "See the ", list("parallelly::parallelly.options"), 
#&gt;                     " page for the settings.\n")), "\n", "\n", 
#&gt;                 list(list("Options for controlling futures"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.plan"), ":"), list("(character string or future function) Default future strategy plan used unless otherwise specified via ", 
#&gt;                     list(list("plan()")), ". This will also be the future plan set when calling ", 
#&gt;                     list("plan(\"default\")"), ".  If not specified, this option may be set when the ", 
#&gt;                     list("future"), " package is ", list("loaded"), 
#&gt;                     " if command-line option ", list("--parallel=ncores"), 
#&gt;                     " (short ", list("-p ncores"), ") is specified; if ", 
#&gt;                     list("ncores &gt; 1"), ", then option ", list(
#&gt;                       "future.plan"), " is set to ", list("multisession"), 
#&gt;                     " otherwise ", list("sequential"), " (in addition to option ", 
#&gt;                     list("mc.cores"), " being set to ", list(
#&gt;                       "ncores"), ", if ", list("ncores &gt;= 1"), 
#&gt;                     "). (Default: ", list("sequential"), ")")), 
#&gt;                     "\n", "\n", list(list(list("future.globals.maxSize"), 
#&gt;                       ":"), list("(numeric) Maximum allowed total size (in bytes) of global variables identified. Used to prevent too large exports. If set of ", 
#&gt;                       list("+Inf"), ", then the check for large globals is skipped. (Default: ", 
#&gt;                       list("500 * 1024 ^ 2"), " = 500 MiB)")), 
#&gt;                     "\n", "\n", list(list(list("future.globals.onReference"), 
#&gt;                       ": (", list("beta feature - may change"), 
#&gt;                       ")"), list("(character string) Controls whether the identified globals should be scanned for so called ", 
#&gt;                       list("references"), " (e.g. external pointers and connections) or not.  It is unlikely that another ", 
#&gt;                       list(), " process (\"worker\") can use a global that uses a internal reference of the master ", 
#&gt;                       list(), " process - we call such objects ", 
#&gt;                       list("non-exportable globals"), ".\n", 
#&gt;                       "If this option is ", list("\"error\""), 
#&gt;                       ", an informative error message is produced if a non-exportable global is detected.\n", 
#&gt;                       "If ", list("\"warning\""), ", a warning is produced, but the processing will continue; it is likely that the future will be resolved with a run-time error unless processed in the master ", 
#&gt;                       list(), " process (e.g. ", list("plan(sequential)"), 
#&gt;                       " and ", list("plan(multicore)"), ").\n", 
#&gt;                       "If ", list("\"ignore\""), ", no scan is performed.\n", 
#&gt;                       "(Default: ", list("\"ignore\""), " but may change)\n")), 
#&gt;                     "\n", "\n", list(list(list("future.resolve.recursive"), 
#&gt;                       ":"), list("(integer) An integer specifying the maximum recursive depth to which futures should be resolved. If negative, nothing is resolved.  If ", 
#&gt;                       list("0"), ", only the future itself is resolved.  If ", 
#&gt;                       list("1"), ", the future and any of its elements that are futures are resolved, and so on. If ", 
#&gt;                       list("+Inf"), ", infinite search depth is used. (Default: ", 
#&gt;                       list("0"), ")")), "\n", "\n", list(list(
#&gt;                       list("future.rng.onMisuse"), ": (", list(
#&gt;                         "beta feature - may change"), ")"), list(
#&gt;                       "(character string) If random numbers are used in futures, then parallel (L'Ecuyer-CMRG) RNG should be used in order to get statistical sound RNGs. The defaults in the future framework assume that ", 
#&gt;                       list("no"), " random number generation (RNG) is taken place in the future expression because L'Ecuyer-CMRG RNGs come with an unnecessary overhead if not needed.  To protect against mistakes, the future framework attempts to detect when random numbers are used despite L'Ecuyer-CMRG RNGs are not in place.  If this is detected, and ", 
#&gt;                       list("future.rng.onMisuse = \"error\""), 
#&gt;                       ", then an informative error message is produced.  If ", 
#&gt;                       list("\"warning\""), ", then a warning message is produced.  If ", 
#&gt;                       list("\"ignore\""), ", no check is performed. (Default: ", 
#&gt;                       list("\"warning\""), ")")), "\n", "\n", 
#&gt;                     list(list(list("future.wait.timeout"), ":"), 
#&gt;                       list("(numeric) Maximum waiting time (in seconds) for a free worker before a timeout error is generated. (Default: ", 
#&gt;                         list("30 * 24 * 60 * 60"), " (= 30 days))")), 
#&gt;                     "\n", "\n", list(list(list("future.wait.interval"), 
#&gt;                       ":"), list("(numeric) Initial interval (in seconds) between polls. (Default: ", 
#&gt;                       list("0.2"), " = 0.2 seconds)")), "\n", 
#&gt;                     "\n", list(list(list("future.wait.alpha"), 
#&gt;                       ":"), list("(numeric) Positive scale factor used to increase the interval after each poll. (Default: ", 
#&gt;                       list("1.01"), ")")), "\n"), "\n")), "\n", 
#&gt;                 "\n", list(list("Options for debugging futures"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.debug"), ":"), list("(logical) If ", 
#&gt;                     list("TRUE"), ", extensive debug messages are generated. (Default: ", 
#&gt;                     list("FALSE"), ")")), "\n"), "\n")), "\n", 
#&gt;                 "\n", list(list("Options for controlling package startup"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.startup.script"), ":"), list("(character vector or a logical) Specifies zero of more future startup scripts to be sourced when the ", 
#&gt;                     list("future"), " package is ", list("attached"), 
#&gt;                     ". It is only the first existing script that is sourced. If none of the specified files exist, nothing is sourced - there will be neither a warning nor an error.\n", 
#&gt;                     "If this option is not specified, environment variable ", 
#&gt;                     list("R_FUTURE_STARTUP_SCRIPT"), " is considered, where multiple scripts may be separated by either a colon (", 
#&gt;                     list(":"), ") or a semicolon (", list(";"), 
#&gt;                     "). If neither is set, or either is set to ", 
#&gt;                     list("TRUE"), ", the default is to look for a ", 
#&gt;                     list(".future.R"), " script in the current directory and then in the user's home directory.  To disable future startup scripts, set the option or the environment variable to ", 
#&gt;                     list("FALSE"), ".  ", list("Importantly"), 
#&gt;                     ", this option is ", list("always"), " set to ", 
#&gt;                     list("FALSE"), " if the ", list("future"), 
#&gt;                     " package is loaded as part of a future expression being evaluated, e.g. in a background process. In order words, they are sourced in the main ", 
#&gt;                     list(), " process but not in future processes. (Default: ", 
#&gt;                     list("TRUE"), " in main ", list(), " process and ", 
#&gt;                     list("FALSE"), " in future processes / during future evaluation)")), 
#&gt;                     "\n", "\n", list(list(list("future.cmdargs"), 
#&gt;                       ":"), list("(character vector) Overrides ", 
#&gt;                       list(list("commandArgs"), "()"), " when the ", 
#&gt;                       list("future"), " package is ", list("loaded"), 
#&gt;                       ".")), "\n"), "\n")), "\n", "\n", list(
#&gt;                   list("Options for configuring low-level system behaviors"), 
#&gt;                   list("\n", "\n", "\n", list("\n", list(list(
#&gt;                     list("future.fork.multithreading.enable"), 
#&gt;                     " (", list("beta feature - may change"), 
#&gt;                     "):"), list("(logical) Enable or disable ", 
#&gt;                     list("multi-threading"), " while using ", 
#&gt;                     list("forked"), " parallel processing.  If ", 
#&gt;                     list("FALSE"), ", different multi-thread library settings are overridden such that they run in single-thread mode. Specifically, multi-threading will be disabled for OpenMP (which requires the ", 
#&gt;                     list("RhpcBLASctl"), " package) and for ", 
#&gt;                     list("RcppParallel"), ". If ", list("TRUE"), 
#&gt;                     ", or not set (the default), multi-threading is allowed.  Parallelization via multi-threaded processing (done in native code by some packages and external libraries) while at the same time using forked (aka \"multicore\") parallel processing is known to unstable.  Note that this is not only true when using ", 
#&gt;                     list("plan(multicore)"), " but also when using, for instance, ", 
#&gt;                     list(list("mclapply"), "()"), " of the ", 
#&gt;                     list("parallel"), " package. (Default: not set)")), 
#&gt;                     "\n"), "\n", "\n", "See also ", list("parallelly::parallelly.options"), 
#&gt;                     ".\n")), "\n", "\n", list(list("Options for demos"), 
#&gt;                   list("\n", "\n", list("\n", list(list(list(
#&gt;                     "future.demo.mandelbrot.region"), ":"), list(
#&gt;                     "(integer) Either a named list of ", list(
#&gt;                       list("mandelbrot()")), " arguments or an integer in {1, 2, 3} specifying a predefined Mandelbrot region. (Default: ", 
#&gt;                     list("1L"), ")")), "\n", "\n", list(list(
#&gt;                     list("future.demo.mandelbrot.nrow"), ":"), 
#&gt;                     list("(integer) Number of rows and columns of tiles. (Default: ", 
#&gt;                       list("3L"), ")")), "\n"), "\n")), "\n", 
#&gt;                 "\n", list(list("Deprecated or for internal prototyping"), 
#&gt;                   list("\n", "\n", "\n", "The following options exists only for troubleshooting purposes and must not\n", 
#&gt;                     "be used in production.  If used, there is a risk that the results are\n", 
#&gt;                     "non-reproducible if processed elsewhere.  To lower the risk of them being\n", 
#&gt;                     "used by mistake, they are marked as deprecated and will produce warnings\n", 
#&gt;                     "if set.\n", "\n", list("\n", list(list(list(
#&gt;                       "future.globals.onMissing"), ":"), list(
#&gt;                       "(character string) Action to take when non-existing global variables (\"globals\" or \"unknowns\") are identified when the future is created.  If ", 
#&gt;                       list("\"error\""), ", an error is generated immediately.  If ", 
#&gt;                       list("\"ignore\""), ", no action is taken and an attempt to evaluate the future expression will be made.  The latter is useful when there is a risk for false-positive globals being identified, e.g. when future expression contains non-standard evaluation (NSE).  (Default: ", 
#&gt;                       list("\"ignore\""), ")")), "\n", "\n", 
#&gt;                       list(list(list("future.globals.method"), 
#&gt;                         ":"), list("(character string) Method used to identify globals. For details, see ", 
#&gt;                         list(list("globalsOf"), "()"), ". (Default: ", 
#&gt;                         list("\"ordered\""), ")")), "\n", "\n", 
#&gt;                       list(list(list("future.globals.resolve"), 
#&gt;                         ":"), list("(logical) If ", list("TRUE"), 
#&gt;                         ", globals that are ", list(list("Future")), 
#&gt;                         " objects (typically created as ", list(
#&gt;                           "explicit"), " futures) will be resolved and have their values (using ", 
#&gt;                         list("value()"), ") collected.  Because searching for unresolved futures among globals (including their content) can be expensive, the default is not to do it and instead leave it to the run-time checks that assert proper ownership when resolving futures and collecting their values. (Default: ", 
#&gt;                         list("FALSE"), ")")), "\n"), "\n")), 
#&gt;                 "\n", "\n", list(list("Environment variables that set R options"), 
#&gt;                   list("\n", "\n", "All of the above ", list(), 
#&gt;                     " ", list("future.*"), " options can be set by corresponding\n", 
#&gt;                     "environment variable ", list("R_FUTURE_*"), 
#&gt;                     " ", list("when the ", list("future"), " package is\n", 
#&gt;                       "loaded"), ".\n", "For example, if ", list(
#&gt;                       "R_FUTURE_RNG_ONMISUSE = \"ignore\""), 
#&gt;                     ", then option\n", list("future.rng.onMisuse"), 
#&gt;                     " is set to ", list("\"ignore\""), " (character string).\n", 
#&gt;                     "Similarly, if ", list("R_FUTURE_GLOBALS_MAXSIZE = \"50000000\""), 
#&gt;                     ", then option\n", list("future.globals.maxSize"), 
#&gt;                     " is set to ", list("50000000"), " (numeric).\n")), 
#&gt;                 "\n", "\n", list("\n", "# Allow at most 5 MB globals per futures\n", 
#&gt;                   "options(future.globals.maxSize = 5e6)\n", 
#&gt;                   "\n", "# Be strict; catch all RNG mistakes\n", 
#&gt;                   "options(future.rng.onMisuse = \"error\")\n", 
#&gt;                   "\n", "\n"), "\n", list("\n", "To set ", list(), 
#&gt;                   " options or environment variables when ", 
#&gt;                   list(), " starts (even before the ", list("future"), 
#&gt;                   " package is loaded), see the ", list("Startup"), 
#&gt;                   " help page.  The ", list(list("https://cran.r-project.org/package=startup"), 
#&gt;                     list(list("startup"))), " package provides a friendly mechanism for configurating ", 
#&gt;                   list(), "'s startup process.\n"), "\n", list(
#&gt;                   "internal"), "\n"), futureOf.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/futureOf.R", 
#&gt;                 "\n", list("futureOf"), "\n", list("futureOf"), 
#&gt;                 "\n", list("Get the future of a future variable"), 
#&gt;                 "\n", list("\n", "futureOf(\n", "  var = NULL,\n", 
#&gt;                   "  envir = parent.frame(),\n", "  mustExist = TRUE,\n", 
#&gt;                   "  default = NA,\n", "  drop = FALSE\n", ")\n"), 
#&gt;                 "\n", list("\n", list(list("var"), list("the variable.  If NULL, all futures in the\n", 
#&gt;                   "environment are returned.")), "\n", "\n", 
#&gt;                   list(list("envir"), list("the environment where to search from.")), 
#&gt;                   "\n", "\n", list(list("mustExist"), list("If TRUE and the variable does not exists, then\n", 
#&gt;                     "an informative error is thrown, otherwise NA is returned.")), 
#&gt;                   "\n", "\n", list(list("default"), list("the default value if future was not found.")), 
#&gt;                   "\n", "\n", list(list("drop"), list("if TRUE and ", 
#&gt;                     list("var"), " is NULL, then returned list\n", 
#&gt;                     "only contains futures, otherwise also ", 
#&gt;                     list("default"), " values.")), "\n"), "\n", 
#&gt;                 list("\n", "A ", list("Future"), " (or ", list(
#&gt;                   "default"), ").\n", "If ", list("var"), " is NULL, then a named list of Future:s are returned.\n"), 
#&gt;                 "\n", list("\n", "Get the future of a future variable that has been created directly\n", 
#&gt;                   "or indirectly via ", list(list("future()")), 
#&gt;                   ".\n"), "\n", list("\n", "a %&lt;-% { 1 }\n", 
#&gt;                   "\n", "f &lt;- futureOf(a)\n", "print(f)\n", "\n", 
#&gt;                   "b %&lt;-% { 2 }\n", "\n", "f &lt;- futureOf(b)\n", 
#&gt;                   "print(f)\n", "\n", "## All futures\n", "fs &lt;- futureOf()\n", 
#&gt;                   "print(fs)\n", "\n", "\n", "## Futures part of environment\n", 
#&gt;                   "env &lt;- new.env()\n", "env$c %&lt;-% { 3 }\n", 
#&gt;                   "\n", "f &lt;- futureOf(env$c)\n", "print(f)\n", 
#&gt;                   "\n", "f2 &lt;- futureOf(c, envir = env)\n", "print(f2)\n", 
#&gt;                   "\n", "f3 &lt;- futureOf(\"c\", envir = env)\n", 
#&gt;                   "print(f3)\n", "\n", "fs &lt;- futureOf(envir = env)\n", 
#&gt;                   "print(fs)\n"), "\n"), futureSessionInfo.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/futureSessionInfo.R", 
#&gt;                 "\n", list("futureSessionInfo"), "\n", list("futureSessionInfo"), 
#&gt;                 "\n", list("Get session information specific to the future framework"), 
#&gt;                 "\n", list("\n", "futureSessionInfo(test = TRUE)\n"), 
#&gt;                 "\n", list("\n", list(list("test"), list("If TRUE, one or more futures are created to query workers\n", 
#&gt;                   "and validate their information.")), "\n"), 
#&gt;                 "\n", list("\n", "Nothing.\n"), "\n", list("\n", 
#&gt;                   "Get session information specific to the future framework\n"), 
#&gt;                 "\n"), futures.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/futures.R", 
#&gt;                 "\n", list("futures"), "\n", list("futures"), 
#&gt;                 "\n", list("Get all futures in a container"), 
#&gt;                 "\n", list("\n", "futures(x, ...)\n"), "\n", 
#&gt;                 list("\n", list(list("x"), list("An environment, a list, or a list environment.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "An object of same type as ", 
#&gt;                   list("x"), " and with the same names\n", "and/or dimensions, if set.\n"), 
#&gt;                 "\n", list("\n", "Gets all futures in an environment, a list, or a list environment\n", 
#&gt;                   "and returns an object of the same class (and dimensions).\n", 
#&gt;                   "Non-future elements are returned as is.\n"), 
#&gt;                 "\n", list("\n", "This function is useful for retrieve futures that were created via\n", 
#&gt;                   "future assignments (", list("%&lt;-%"), ") and therefore stored as promises.\n", 
#&gt;                   "This function turns such promises into standard ", 
#&gt;                   list("Future"), "\n", "objects.\n"), "\n"), 
#&gt;             getExpression.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/Future-class.R", 
#&gt;                 "\n", list("getExpression"), "\n", list("getExpression"), 
#&gt;                 "\n", list("getExpression.Future"), "\n", list(
#&gt;                   "Inject code for the next type of future to use for nested futures"), 
#&gt;                 "\n", list("\n", "getExpression(future, ...)\n"), 
#&gt;                 "\n", list("\n", list(list("future"), list("Current future.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "A future expression with code injected to set what\n", 
#&gt;                   "type of future to use for nested futures, iff any.\n"), 
#&gt;                 "\n", list("\n", "Inject code for the next type of future to use for nested futures\n"), 
#&gt;                 "\n", list("\n", "If no next future strategy is specified, the default is to\n", 
#&gt;                   "use ", list("sequential"), " futures.  This conservative approach protects\n", 
#&gt;                   "against spawning off recursive futures by mistake, especially\n", 
#&gt;                   list("multicore"), " and ", list("multisession"), 
#&gt;                   " ones.\n", "The default will also set ", list(
#&gt;                     "options(mc.cores = 1L)"), " (*) so that\n", 
#&gt;                   "no parallel ", list(), " processes are spawned off by functions such as\n", 
#&gt;                   list("parallel::mclapply()"), " and friends.\n", 
#&gt;                   "\n", "Currently it is not possible to specify what type of nested\n", 
#&gt;                   "futures to be used, meaning the above default will always be\n", 
#&gt;                   "used.\n", "See ", list(list("https://github.com/HenrikBengtsson/future/issues/37"), 
#&gt;                     list("Issue #37")), "\n", "for plans on adding support for custom nested future types.\n", 
#&gt;                   "\n", "(*) Ideally we would set ", list("mc.cores = 0"), 
#&gt;                   " but that will unfortunately\n", "cause ", 
#&gt;                   list("mclapply()"), " and friends to generate an error saying\n", 
#&gt;                   "\"'mc.cores' must be &gt;= 1\".  Ideally those functions should\n", 
#&gt;                   "fall back to using the non-multicore alternative in this\n", 
#&gt;                   "case, e.g. ", list("mclapply(...)"), " =&gt; ", 
#&gt;                   list("lapply(...)"), ".\n", "See ", list("https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7"), 
#&gt;                   "\n", "for a discussion on this.\n"), "\n", 
#&gt;                 list("internal"), "\n"), getGlobalsAndPackages.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/globals.R", 
#&gt;                 "\n", list("getGlobalsAndPackages"), "\n", list(
#&gt;                   "getGlobalsAndPackages"), "\n", list("Retrieves global variables of an expression and their associated packages"), 
#&gt;                 "\n", list("\n", "getGlobalsAndPackages(\n", 
#&gt;                   "  expr,\n", "  envir = parent.frame(),\n", 
#&gt;                   "  tweak = tweakExpression,\n", "  globals = TRUE,\n", 
#&gt;                   "  resolve = getOption(\"future.globals.resolve\", NULL),\n", 
#&gt;                   "  persistent = FALSE,\n", "  maxSize = getOption(\"future.globals.maxSize\", 500 * 1024^2),\n", 
#&gt;                   "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                   "expr"), list("An ", list(), " expression whose globals should be found.")), 
#&gt;                   "\n", "\n", list(list("envir"), list("The environment from which globals should be searched.")), 
#&gt;                   "\n", "\n", list(list("tweak"), list("(optional) A function that takes an expression and returned a modified one.")), 
#&gt;                   "\n", "\n", list(list("globals"), list("(optional) a logical, a character vector, a named list, or a ", 
#&gt;                     list("Globals"), " object.  If TRUE, globals are identified by code inspection based on ", 
#&gt;                     list("expr"), " and ", list("tweak"), " searching from environment ", 
#&gt;                     list("envir"), ".  If FALSE, no globals are used.  If a character vector, then globals are identified by lookup based their names ", 
#&gt;                     list("globals"), " searching from environment ", 
#&gt;                     list("envir"), ".  If a named list or a Globals object, the globals are used as is.")), 
#&gt;                   "\n", "\n", list(list("resolve"), list("If TRUE, any future that is a global variables (or part of one) is resolved and replaced by a \"constant\" future.")), 
#&gt;                   "\n", "\n", list(list("persistent"), list("If TRUE, non-existing globals (= identified in expression but not found in memory) are always silently ignored and assumed to be existing in the evaluation environment.  If FALSE, non-existing globals are by default ignore, but may also trigger an informative error if option ", 
#&gt;                     list("future.globals.onMissing"), " in ", 
#&gt;                     list("\"error\""), " (should only be used for troubleshooting).")), 
#&gt;                   "\n", "\n", list(list("maxSize"), list("The maximum allowed total size (in bytes) of globals - for\n", 
#&gt;                     "the purpose of preventing too large exports / transfers happening by\n", 
#&gt;                     "mistake.  If the total size of the global objects are greater than this\n", 
#&gt;                     "limit, an informative error message is produced. If\n", 
#&gt;                     list("maxSize = +Inf"), ", then this assertion is skipped. (Default: 500 MiB).")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "A named list with elements ", 
#&gt;                   list("expr"), " (the tweaked expression), ", 
#&gt;                   list("globals"), " (a named list of class ", 
#&gt;                   list("FutureGlobals"), ") and ", list("packages"), 
#&gt;                   " (a character string).\n"), "\n", list("\n", 
#&gt;                   "Retrieves global variables of an expression and their associated packages\n"), 
#&gt;                 "\n", list("\n", "Internally, ", list(list("globalsOf"), 
#&gt;                   "()"), " is used to identify globals and associated packages from the expression.\n"), 
#&gt;                 "\n", list("internal"), "\n"), `grapes-conditions-grapes.Rd` = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/conditions_OP.R", 
#&gt;                 "\n", list("%conditions%"), "\n", list("%conditions%"), 
#&gt;                 "\n", list("Control whether standard output should be captured or not"), 
#&gt;                 "\n", list("\n", "fassignment %conditions% capture\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("capture"), list(
#&gt;                   "If TRUE, the standard output will be captured, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Control whether standard output should be captured or not\n"), 
#&gt;                 "\n"), `grapes-globals-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/globals_OP.R", 
#&gt;                 "\n", list("%globals%"), "\n", list("%globals%"), 
#&gt;                 "\n", list("%packages%"), "\n", list("Specify globals and packages for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %globals% globals\n", 
#&gt;                   "fassignment %packages% packages\n"), "\n", 
#&gt;                 list("\n", list(list("fassignment"), list("The future assignment, e.g.\n", 
#&gt;                   list("x %&lt;-% { expr }"), ".")), "\n", "\n", 
#&gt;                   list(list("globals"), list("(optional) a logical, a character vector, or a named list\n", 
#&gt;                     "to control how globals are handled.\n", 
#&gt;                     "For details, see section 'Globals used by future expressions'\n", 
#&gt;                     "in the help for ", list(list("future()")), 
#&gt;                     ".")), "\n", "\n", list(list("packages"), 
#&gt;                     list("(optional) a character vector specifying packages\n", 
#&gt;                       "to be attached in the ", list(), " environment evaluating the future.")), 
#&gt;                   "\n"), "\n", list("\n", "Specify globals and packages for a future assignment\n"), 
#&gt;                 "\n"), `grapes-label-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/label_OP.R", 
#&gt;                 "\n", list("%label%"), "\n", list("%label%"), 
#&gt;                 "\n", list("Specify label for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %label% label\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("label"), list(
#&gt;                   "An optional character string label attached to the future.")), 
#&gt;                   "\n"), "\n", list("\n", "Specify label for a future assignment\n"), 
#&gt;                 "\n"), `grapes-lazy-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/lazy_OP.R", 
#&gt;                 "\n", list("%lazy%"), "\n", list("%lazy%"), "\n", 
#&gt;                 list("Control lazy / eager evaluation for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %lazy% lazy\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("lazy"), list(
#&gt;                   "If FALSE (default), the future is resolved\n", 
#&gt;                   "eagerly (starting immediately), otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Control lazy / eager evaluation for a future assignment\n"), 
#&gt;                 "\n"), `grapes-plan-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/plan_OP.R", 
#&gt;                 "\n", list("%plan%"), "\n", list("%plan%"), "\n", 
#&gt;                 list("Use a specific plan for a future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %plan% strategy\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("strategy"), list(
#&gt;                   "The mechanism for how the future should be\n", 
#&gt;                   "resolved. See ", list(list("plan()")), " for further details.")), 
#&gt;                   "\n"), "\n", list("\n", "Use a specific plan for a future assignment\n"), 
#&gt;                 "\n", list("\n", "The ", list(list("plan()")), 
#&gt;                   " function sets the default plan for all futures.\n"), 
#&gt;                 "\n"), `grapes-seed-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/seed_OP.R", 
#&gt;                 "\n", list("%seed%"), "\n", list("%seed%"), "\n", 
#&gt;                 list("Set random seed for future assignment"), 
#&gt;                 "\n", list("\n", "fassignment %seed% seed\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("seed"), list(
#&gt;                   "(optional) If TRUE, the random seed, that is, the state of the\n", 
#&gt;                   "random number generator (RNG) will be set such that statistically sound\n", 
#&gt;                   "random numbers are produced (also during parallelization).\n", 
#&gt;                   "If FALSE (default), it is assumed that the future expression does neither\n", 
#&gt;                   "need nor use random numbers generation.\n", 
#&gt;                   "To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\n", 
#&gt;                   "or a regular RNG seed (a single integer).  If the latter, then a\n", 
#&gt;                   "L'Ecuyer-CMRG seed will be automatically created based on the given seed.\n", 
#&gt;                   "Furthermore, if FALSE, then the future will be monitored to make sure it\n", 
#&gt;                   "does not use random numbers.  If it does and depending on the value of\n", 
#&gt;                   "option ", list(list("future.rng.onMisuse")), 
#&gt;                   ", the check is\n", "ignored, an informative warning, or error will be produced.\n", 
#&gt;                   "If ", list("seed"), " is NULL, then the effect is as with ", 
#&gt;                   list("seed = FALSE"), "\n", "but without the RNG check being performed.")), 
#&gt;                   "\n"), "\n", list("\n", "Set random seed for future assignment\n"), 
#&gt;                 "\n"), `grapes-stdout-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/stdout_OP.R", 
#&gt;                 "\n", list("%stdout%"), "\n", list("%stdout%"), 
#&gt;                 "\n", list("Control whether standard output should be captured or not"), 
#&gt;                 "\n", list("\n", "fassignment %stdout% capture\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("capture"), list(
#&gt;                   "If TRUE, the standard output will be captured, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Control whether standard output should be captured or not\n"), 
#&gt;                 "\n"), `grapes-tweak-grapes.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/tweak_OP.R", 
#&gt;                 "\n", list("%tweak%"), "\n", list("%tweak%"), 
#&gt;                 "\n", list("Temporarily tweaks the arguments of the current strategy"), 
#&gt;                 "\n", list("\n", "fassignment %tweak% tweaks\n"), 
#&gt;                 "\n", list("\n", list(list("fassignment"), list(
#&gt;                   "The future assignment, e.g.\n", list("x %&lt;-% { expr }"), 
#&gt;                   ".")), "\n", "\n", list(list("tweaks"), list(
#&gt;                   "A named list (or vector) with arguments that\n", 
#&gt;                   "should be changed relative to the current strategy.")), 
#&gt;                   "\n"), "\n", list("\n", "Temporarily tweaks the arguments of the current strategy\n"), 
#&gt;                 "\n"), make_rng_seeds.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/rng.R", 
#&gt;                 "\n", list("make_rng_seeds"), "\n", list("make_rng_seeds"), 
#&gt;                 "\n", list("Produce Reproducible Seeds for Parallel Random Number Generation"), 
#&gt;                 "\n", list("\n", "make_rng_seeds(count, seed = FALSE, debug = getOption(\"future.debug\", FALSE))\n"), 
#&gt;                 "\n", list("\n", list(list("count"), list("The number of RNG seeds to produce.")), 
#&gt;                   "\n", "\n", list(list("seed"), list("A logical specifying whether RNG seeds should be generated\n", 
#&gt;                     "or not.  (", list("seed = NULL"), " corresponds to ", 
#&gt;                     list("seed = FALSE"), ").\n", "If a list, then it should be of length ", 
#&gt;                     list("count"), " and each element should\n", 
#&gt;                     "consist of a valid RNG seed.")), "\n", "\n", 
#&gt;                   list(list("debug"), list("If ", list("TRUE"), 
#&gt;                     ", debug output is produced, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", "Returns a non-named list of length ", 
#&gt;                   list("count"), ", or ", list("NULL"), ".\n", 
#&gt;                   "Any seed returned is a valid RNG seed.\n"), 
#&gt;                 "\n", list("\n", "Produce Reproducible Seeds for Parallel Random Number Generation\n"), 
#&gt;                 "\n", list("internal"), "\n"), mandelbrot.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/mandelbrot.R", 
#&gt;                 "\n", list("mandelbrot"), "\n", list("mandelbrot"), 
#&gt;                 "\n", list("as.raster.Mandelbrot"), "\n", list(
#&gt;                   "plot.Mandelbrot"), "\n", list("mandelbrot_tiles"), 
#&gt;                 "\n", list("Mandelbrot convergence counts"), 
#&gt;                 "\n", list("\n", "mandelbrot(...)\n"), "\n", 
#&gt;                 list("\n", list(list("Z"), list("A complex matrix for which convergence\n", 
#&gt;                   "counts should be calculated.")), "\n", "\n", 
#&gt;                   list(list("xmid, ymid, side, resolution"), 
#&gt;                     list("Alternative specification of\n", "the complex plane ", 
#&gt;                       list("Z"), ", where\n", list("mean(Re(Z)) == xmid"), 
#&gt;                       ",\n", list("mean(Im(Z)) == ymid"), ",\n", 
#&gt;                       list("diff(range(Re(Z))) == side"), ",\n", 
#&gt;                       list("diff(range(Im(Z))) == side"), ", and\n", 
#&gt;                       list("dim(Z) == c(resolution, resolution)"), 
#&gt;                       ".")), "\n", "\n", list(list("maxIter"), 
#&gt;                     list("Maximum number of iterations per bin.")), 
#&gt;                   "\n", "\n", list(list("tau"), list("A threshold; the radius when calling\n", 
#&gt;                     "divergence (Mod(z) &gt; tau).")), "\n"), "\n", 
#&gt;                 list("\n", "Returns an integer matrix (of class Mandelbrot) with\n", 
#&gt;                   "non-negative counts.\n"), "\n", list("\n", 
#&gt;                   "Mandelbrot convergence counts\n"), "\n", list(
#&gt;                   "\n", "counts &lt;- mandelbrot(xmid = -0.75, ymid = 0, side = 3)\n", 
#&gt;                   "str(counts)\n", list("\n", "plot(counts)\n"), 
#&gt;                   "\n", "\n", list("\n", "demo(\"mandelbrot\", package = \"future\", ask = FALSE)\n"), 
#&gt;                   "\n", "\n"), "\n", list("\n", "The internal Mandelbrot algorithm was inspired by and\n", 
#&gt;                   "adopted from similar GPL code of Martin Maechler available\n", 
#&gt;                   "from ftp://stat.ethz.ch/U/maechler/R/ on 2005-02-18 (sic!).\n"), 
#&gt;                 "\n", list("internal"), "\n"), multicore.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multicore.R", 
#&gt;                 "\n", list("multicore"), "\n", list("multicore"), 
#&gt;                 "\n", list("Create a multicore future whose value will be resolved asynchronously in a forked parallel process"), 
#&gt;                 "\n", list("\n", "multicore(\n", "  ...,\n", 
#&gt;                   "  workers = availableCores(constraints = \"multicore\"),\n", 
#&gt;                   "  envir = parent.frame()\n", ")\n"), "\n", 
#&gt;                 list("\n", list(list("..."), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A positive numeric scalar or a function specifying the\n", 
#&gt;                     "maximum number of parallel futures that can be active at the same time\n", 
#&gt;                     "before blocking.\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return a numeric scalar.")), 
#&gt;                   "\n", "\n", list(list("envir"), list("The ", 
#&gt;                     list("environment"), " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("MulticoreFuture"), "\n", "If ", 
#&gt;                   list("workers == 1"), ", then all processing using done in the\n", 
#&gt;                   "current/main ", list(), " session and we therefore fall back to using\n", 
#&gt;                   "an sequential future.  This is also the case whenever multicore\n", 
#&gt;                   "processing is not supported, e.g. on Windows.\n"), 
#&gt;                 "\n", list("\n", "A multicore future is a future that uses multicore evaluation,\n", 
#&gt;                   "which means that its ", list("value is computed and resolved in\n", 
#&gt;                     "parallel in another process"), ".\n"), "\n", 
#&gt;                 list("\n", "This function is ", list("not"), 
#&gt;                   " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures in parallel on the local machine via as many forked\n", 
#&gt;                     "# processes as available to the current R process\n", 
#&gt;                     "plan(multicore)\n", "\n", "# Evaluate futures in parallel on the local machine via two forked processes\n", 
#&gt;                     "plan(multicore, workers = 2)\n"), list(list(
#&gt;                     "html"), list(list("&lt;/div&gt;"))), "\n", "\n", 
#&gt;                   "For the total number of cores available including the current/main\n", 
#&gt;                   list(), " process, see ", list(list("parallelly::availableCores()")), 
#&gt;                   ".\n", "\n", "Not all operating systems support process forking and thereby not multicore\n", 
#&gt;                   "futures.  For instance, forking is not supported on Microsoft Windows.\n", 
#&gt;                   "Moreover, process forking may break some R environments such as RStudio.\n", 
#&gt;                   "Because of this, the future package disables process forking also in\n", 
#&gt;                   "such cases.  See ", list(list("supportsMulticore()")), 
#&gt;                   " for details.\n", "Trying to create multicore futures on non-supported systems or when\n", 
#&gt;                   "forking is disabled will result in multicore futures falling back to\n", 
#&gt;                   "becoming ", list("sequential"), " futures.\n"), 
#&gt;                 "\n", list("\n", "## Use multicore futures\n", 
#&gt;                   "plan(multicore)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## A multicore future is evaluated in a separate forked\n", 
#&gt;                   "## process.  Changing the value of a global variable\n", 
#&gt;                   "## will not affect the result of the future.\n", 
#&gt;                   "a &lt;- 7\n", "print(a)\n", "\n", "v &lt;- value(f)\n", 
#&gt;                   "print(v)\n", "stopifnot(v == 0)\n"), "\n", 
#&gt;                 list("\n", "For processing in multiple background ", 
#&gt;                   list(), " sessions, see\n", list("multisession"), 
#&gt;                   " futures.\n", "\n", "Use ", list(list("availableCores()")), 
#&gt;                   " to see the total number of\n", "cores that are available for the current ", 
#&gt;                   list(), " session.\n", "Use ", list(list("availableCores"), 
#&gt;                     "(\"multicore\") &gt; 1L"), " to check\n", "whether multicore futures are supported or not on the current\n", 
#&gt;                   "system.\n"), "\n"), multiprocess.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multiprocess.R", 
#&gt;                 "\n", list("multiprocess"), "\n", list("multiprocess"), 
#&gt;                 "\n", list("Create a multiprocess future whose value will be resolved asynchronously using multicore or a multisession evaluation"), 
#&gt;                 "\n", list("\n", "multiprocess(..., workers = availableCores(), envir = parent.frame())\n"), 
#&gt;                 "\n", list("\n", list(list(list()), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A positive numeric scalar or a function specifying the\n", 
#&gt;                     "maximum number of parallel futures that can be active at the same time\n", 
#&gt;                     "before blocking.\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return a numeric scalar.")), 
#&gt;                   "\n", "\n", list(list("envir"), list("The ", 
#&gt;                     list("environment"), " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("MultiprocessFuture"), " implemented as either a\n", 
#&gt;                   list("MulticoreFuture"), " or a ", list("MultisessionFuture"), 
#&gt;                   ".\n"), "\n", list("\n", "A multiprocess future is a future that uses ", 
#&gt;                   list("multicore"), " evaluation\n", "if supported, otherwise it uses ", 
#&gt;                   list("multisession"), " evaluation.\n", "Regardless, its ", 
#&gt;                   list("value is computed and resolved in\n", 
#&gt;                     "parallel in another process"), ".", list(), 
#&gt;                   "\n", list(), "\n", list("WARNING: Consider the 'multiprocess' future plan deprecated.\n", 
#&gt;                     "Instead, explicitly specify 'multisession' or 'multicore'.  The former works\n", 
#&gt;                     "everywhere and is the recommended one between the two. ", 
#&gt;                     list("Forked processing"), ",\n", "which 'multicore' uses, is unstable in various environment and setups.\n", 
#&gt;                     "The 'multiprocess' alias is therefore being phased out."), 
#&gt;                   "\n"), "\n", list("\n", list("\n", "\n", "## Use multiprocess futures\n", 
#&gt;                   "plan(multiprocess)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## A multiprocess future is evaluated in a separate R process.\n", 
#&gt;                   "## Changing the value of a global variable will not affect\n", 
#&gt;                   "## the result of the future.\n", "a &lt;- 7\n", 
#&gt;                   "print(a)\n", "\n", "v &lt;- value(f)\n", "print(v)\n", 
#&gt;                   "stopifnot(v == 0)\n", "\n", "## Explicitly close multisession workers, if they were used\n", 
#&gt;                   "plan(sequential)\n"), "\n"), "\n", list("\n", 
#&gt;                   "Internally ", list(list("multicore()")), " and ", 
#&gt;                   list(list("multisession()")), "\n", "are used.\n"), 
#&gt;                 "\n", list("internal"), "\n"), multisession.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multisession.R", 
#&gt;                 "\n", list("multisession"), "\n", list("multisession"), 
#&gt;                 "\n", list("Create a multisession future whose value will be resolved asynchronously in a parallel ", 
#&gt;                   list(), " session"), "\n", list("\n", "multisession(\n", 
#&gt;                   "  ...,\n", "  workers = availableCores(),\n", 
#&gt;                   "  lazy = FALSE,\n", "  rscript_libs = .libPaths(),\n", 
#&gt;                   "  envir = parent.frame()\n", ")\n"), "\n", 
#&gt;                 list("\n", list(list("..."), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A positive numeric scalar or a function specifying the\n", 
#&gt;                     "maximum number of parallel futures that can be active at the same time\n", 
#&gt;                     "before blocking.\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return a numeric scalar.")), 
#&gt;                   "\n", "\n", list(list("lazy"), list("If FALSE (default), the future is resolved\n", 
#&gt;                     "eagerly (starting immediately), otherwise not.")), 
#&gt;                   "\n", "\n", list(list("rscript_libs"), list(
#&gt;                     "A character vector of ", list(), " package library folders that\n", 
#&gt;                     "the workers should use.  The default is ", 
#&gt;                     list(".libPaths()"), " so that multisession\n", 
#&gt;                     "workers inherits the same library path as the main ", 
#&gt;                     list(), " session.\n", "To avoid this, use ", 
#&gt;                     list("plan(multisession, ..., rscript_libs = NULL)"), 
#&gt;                     ".\n", list("Important: Note that the library path is set on the workers when they are\n", 
#&gt;                       "created, i.e. when ", list("plan(multisession)"), 
#&gt;                       " is called.  Any changes to\n", list(".libPaths()"), 
#&gt;                       " in the main R session after the workers have been created\n", 
#&gt;                       "will have no effect."), "\n", "This is passed down as-is to ", 
#&gt;                     list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                     ".")), "\n", "\n", list(list("envir"), list(
#&gt;                     "The ", list("environment"), " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("MultisessionFuture"), ".\n", "If ", 
#&gt;                   list("workers == 1"), ", then all processing using done in the\n", 
#&gt;                   "current/main ", list(), " session and we therefore fall back to using\n", 
#&gt;                   "a lazy future.\n"), "\n", list("\n", "A multisession future is a future that uses multisession evaluation,\n", 
#&gt;                   "which means that its ", list("value is computed and resolved in\n", 
#&gt;                     "parallel in another ", list(), " session"), 
#&gt;                   ".\n"), "\n", list("\n", "This function is ", 
#&gt;                   list("not"), " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures in parallel on the local machine via as many background\n", 
#&gt;                     "# processes as available to the current R process\n", 
#&gt;                     "plan(multisession)\n", "\n", "# Evaluate futures in parallel on the local machine via two background\n", 
#&gt;                     "# processes\n", "plan(multisession, workers = 2)\n"), 
#&gt;                   list(list("html"), list(list("&lt;/div&gt;"))), "\n", 
#&gt;                   "\n", "The background ", list(), " sessions (the \"workers\") are created using\n", 
#&gt;                   list(list("makeClusterPSOCK()")), ".\n", "\n", 
#&gt;                   "For the total number of\n", list(), " sessions available including the current/main ", 
#&gt;                   list(), " process, see\n", list(list("parallelly::availableCores()")), 
#&gt;                   ".\n", "\n", "A multisession future is a special type of cluster future.\n"), 
#&gt;                 "\n", list("\n", list("\n", "\n", "## Use multisession futures\n", 
#&gt;                   "plan(multisession)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create future (explicitly)\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## A multisession future is evaluated in a separate R session.\n", 
#&gt;                   "## Changing the value of a global variable will not affect\n", 
#&gt;                   "## the result of the future.\n", "a &lt;- 7\n", 
#&gt;                   "print(a)\n", "\n", "v &lt;- value(f)\n", "print(v)\n", 
#&gt;                   "stopifnot(v == 0)\n", "\n", "## Explicitly close multisession workers by switching plan\n", 
#&gt;                   "plan(sequential)\n"), "\n"), "\n", list("\n", 
#&gt;                   "For processing in multiple forked ", list(), 
#&gt;                   " sessions, see\n", list("multicore"), " futures.\n", 
#&gt;                   "\n", "Use ", list(list("parallelly::availableCores()")), 
#&gt;                   " to see the total number of\n", "cores that are available for the current ", 
#&gt;                   list(), " session.\n"), "\n"), nbrOfWorkers.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/nbrOfWorkers.R", 
#&gt;                 "\n", list("nbrOfWorkers"), "\n", list("nbrOfWorkers"), 
#&gt;                 "\n", list("nbrOfFreeWorkers"), "\n", list("Get the number of workers available"), 
#&gt;                 "\n", list("\n", "nbrOfWorkers(evaluator = NULL)\n", 
#&gt;                   "\n", "nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)\n"), 
#&gt;                 "\n", list("\n", list(list("evaluator"), list(
#&gt;                   "A future evaluator function.\n", "If NULL (default), the current evaluator as returned\n", 
#&gt;                   "by ", list(list("plan()")), " is used.")), 
#&gt;                   "\n", "\n", list(list("background"), list("If TRUE, only workers that can process a future in the\n", 
#&gt;                     "background are considered.  If FALSE, also workers running in the main ", 
#&gt;                     list(), "\n", "process are considered, e.g. when using the 'sequential' backend.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used; reserved for future use.")), 
#&gt;                   "\n"), "\n", list("\n", list("nbrOfWorkers()"), 
#&gt;                   " returns a positive number in ", list(list(
#&gt;                     "{1, 2, 3, ...}")), ", which\n", "for some future backends may also be ", 
#&gt;                   list("+Inf"), ".\n", "\n", list("nbrOfFreeWorkers()"), 
#&gt;                   " returns a non-negative number in\n", list(
#&gt;                     list("{0, 1, 2, 3, ...}")), " which is less than or equal to ", 
#&gt;                   list("nbrOfWorkers()"), ".\n"), "\n", list(
#&gt;                   "\n", "Get the number of workers available\n"), 
#&gt;                 "\n", list("\n", "plan(multisession)\n", "nbrOfWorkers()  ## == availableCores()\n", 
#&gt;                   "\n", "plan(sequential)\n", "nbrOfWorkers()  ## == 1\n"), 
#&gt;                 "\n"), nullcon.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils.R", 
#&gt;                 "\n", list("nullcon"), "\n", list("nullcon"), 
#&gt;                 "\n", list("Creates a connection to the system null device"), 
#&gt;                 "\n", list("\n", "nullcon()\n"), "\n", list("\n", 
#&gt;                   "Returns a open, binary ", list(list("base::connection()")), 
#&gt;                   ".\n"), "\n", list("\n", "Creates a connection to the system null device\n"), 
#&gt;                 "\n", list("internal"), "\n"), pid_exists.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils.R", 
#&gt;                 "\n", list("pid_exists"), "\n", list("pid_exists"), 
#&gt;                 "\n", list("Check whether a process PID exists or not"), 
#&gt;                 "\n", list("\n", "pid_exists(pid, debug = getOption(\"future.debug\", FALSE))\n"), 
#&gt;                 "\n", list("\n", list(list("pid"), list("A positive integer.")), 
#&gt;                   "\n"), "\n", list("\n", "Returns ", list("TRUE"), 
#&gt;                   " if a process with the given PID exists,\n", 
#&gt;                   list("FALSE"), " if a process with the given PID does not exists, and\n", 
#&gt;                   list("NA"), " if it is not possible to check PIDs on the current system.\n"), 
#&gt;                 "\n", list("\n", "Check whether a process PID exists or not\n"), 
#&gt;                 "\n", list("\n", "There is no single go-to function in ", 
#&gt;                   list(), " for testing whether a PID exists\n", 
#&gt;                   "or not.  Instead, this function tries to identify a working one among\n", 
#&gt;                   "multiple possible alternatives.  A method is considered working if the\n", 
#&gt;                   "PID of the current process is successfully identified as being existing\n", 
#&gt;                   "such that ", list("pid_exists(Sys.getpid())"), 
#&gt;                   " is ", list("TRUE"), ".  If no working\n", 
#&gt;                   "approach is found, ", list("pid_exists()"), 
#&gt;                   " will always return ", list("NA"), "\n", "regardless of PID tested.\n", 
#&gt;                   "On Unix, including macOS, alternatives ", 
#&gt;                   list("tools::pskill(pid, signal = 0L)"), "\n", 
#&gt;                   "and ", list("system2(\"ps\", args = pid)"), 
#&gt;                   " are used.\n", "On Windows, various alternatives of ", 
#&gt;                   list("system2(\"tasklist\", ...)"), " are used.\n"), 
#&gt;                 "\n", list("\n", list("\n", list(), " The Open Group Base Specifications Issue 7, 2018 edition,\n", 
#&gt;                   "IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)\n", 
#&gt;                   list("https://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html"), 
#&gt;                   "\n", list(), " Microsoft, tasklist, 2018-08-30,\n", 
#&gt;                   list("https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist"), 
#&gt;                   "\n", list(), " R-devel thread 'Detecting whether a process exists or not by its PID?',\n", 
#&gt;                   "2018-08-30.\n", list("https://stat.ethz.ch/pipermail/r-devel/2018-August/076702.html"), 
#&gt;                   "\n"), "\n"), "\n", list("\n", list(list("pskill"), 
#&gt;                   "()"), " and ", list(list("system2"), "()"), 
#&gt;                   ".\n"), "\n", list("internal"), "\n"), plan.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/zzz.plan.R", 
#&gt;                 "\n", list("plan"), "\n", list("plan"), "\n", 
#&gt;                 list("Plan how to resolve a future"), "\n", list(
#&gt;                   "\n", "plan(\n", "  strategy = NULL,\n", "  ...,\n", 
#&gt;                   "  substitute = TRUE,\n", "  .skip = FALSE,\n", 
#&gt;                   "  .call = TRUE,\n", "  .cleanup = TRUE,\n", 
#&gt;                   "  .init = TRUE\n", ")\n"), "\n", list("\n", 
#&gt;                   list(list("strategy"), list("The evaluation function (or name of it) to use\n", 
#&gt;                     "for resolving a future.  If NULL, then the current strategy is returned.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Additional arguments overriding the default arguments\n", 
#&gt;                     "of the evaluation function.  Which additional arguments are supported\n", 
#&gt;                     "depends on what evaluation function is used, e.g. several support\n", 
#&gt;                     "argument ", list("workers"), " but not all.  For details, see the individual\n", 
#&gt;                     "functions of which some are linked to below.")), 
#&gt;                   "\n", "\n", list(list("substitute"), list("If TRUE, the ", 
#&gt;                     list("strategy"), " expression is\n", list(
#&gt;                       "substitute()"), ":d, otherwise not.")), 
#&gt;                   "\n", "\n", list(list(".skip"), list("(internal) If ", 
#&gt;                     list("TRUE"), ", then attempts to set a strategy\n", 
#&gt;                     "that is the same as what is currently in use, will skipped.")), 
#&gt;                   "\n", "\n", list(list(".call"), list("(internal) Used for recording the call to this function.")), 
#&gt;                   "\n", "\n", list(list(".cleanup"), list("(internal) Used to stop implicitly started clusters.")), 
#&gt;                   "\n", "\n", list(list(".init"), list("(internal) Used to initiate workers.")), 
#&gt;                   "\n"), "\n", list("\n", "If a new strategy is chosen, then the previous one is returned\n", 
#&gt;                   "(invisible), otherwise the current one is returned (visibly).\n"), 
#&gt;                 "\n", list("\n", "This function allows ", list(
#&gt;                   "the user"), " to plan the future, more specifically,\n", 
#&gt;                   "it specifies how ", list(list("future()")), 
#&gt;                   ":s are resolved,\n", "e.g. sequentially or in parallel.\n"), 
#&gt;                 "\n", list("\n", "The default strategy is ", 
#&gt;                   list(list("sequential")), ", but the default can be\n", 
#&gt;                   "configured by option ", list("future.plan"), 
#&gt;                   " and, if that is not set,\n", "system environment variable ", 
#&gt;                   list("R_FUTURE_PLAN"), ".\n", "To reset the strategy back to the default, use ", 
#&gt;                   list("plan(\"default\")"), ".\n"), "\n", list(
#&gt;                   list("Implemented evaluation strategies"), 
#&gt;                   list("\n", "\n", list("\n", list(), list(list(
#&gt;                     list("sequential")), ":"), list("\n", "Resolves futures sequentially in the current ", 
#&gt;                     list(), " process.\n"), "\n", list(), list(
#&gt;                     list(list("transparent")), ":"), list("\n", 
#&gt;                     "Resolves futures sequentially in the current ", 
#&gt;                     list(), " process and\n", "assignments will be done to the calling environment.\n", 
#&gt;                     "Early stopping is enabled by default.\n"), 
#&gt;                     "\n", list(), list(list(list("multisession")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously (in parallel) in separate\n", 
#&gt;                       list(), " sessions running in the background on the same machine.\n"), 
#&gt;                     "\n", list(), list(list(list("multicore")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously (in parallel) in separate\n", 
#&gt;                       list("forked"), " ", list(), " processes running in the background on\n", 
#&gt;                       "the same machine.  Not supported on Windows.\n"), 
#&gt;                     "\n", list(), list(list(list("multiprocess")), 
#&gt;                       ":"), list("(DEPRECATED)\n", "If multicore evaluation is supported, that will be used,\n", 
#&gt;                       "otherwise multisession evaluation will be used.\n"), 
#&gt;                     "\n", list(), list(list(list("cluster")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously (in parallel) in separate\n", 
#&gt;                       list(), " sessions running typically on one or more machines.\n"), 
#&gt;                     "\n", list(), list(list(list("remote")), 
#&gt;                       ":"), list("\n", "Resolves futures asynchronously in a separate ", 
#&gt;                       list(), " session\n", "running on a separate machine, typically on a different\n", 
#&gt;                       "network.\n"), "\n"), "\n", "\n", "Other package may provide additional evaluation strategies.\n", 
#&gt;                     "Notably, the ", list("future.batchtools"), 
#&gt;                     " package implements a\n", "type of futures that will be resolved via job schedulers\n", 
#&gt;                     "that are typically available on high-performance compute\n", 
#&gt;                     "(HPC) clusters, e.g. LSF, Slurm, TORQUE/PBS, Sun Grid Engine,\n", 
#&gt;                     "and OpenLava.\n", "\n", "To \"close\" any background workers (e.g. ", 
#&gt;                     list("multisession"), "), change\n", "the plan to something different; ", 
#&gt;                     list("plan(sequential)"), " is recommended\n", 
#&gt;                     "for this.\n")), "\n", "\n", list(list("For package developers"), 
#&gt;                   list("\n", "\n", "Please refrain from modifying the future strategy inside your packages /\n", 
#&gt;                     "functions, i.e. do not call ", list("plan()"), 
#&gt;                     " in your code.  Instead, leave\n", "the control on what backend to use to the end user.  This idea is part of\n", 
#&gt;                     "the core philosophy of the future framework - as a developer you can never\n", 
#&gt;                     "know what future backends the user have access to.  Moreover, by not making\n", 
#&gt;                     "any assumptions about what backends are available, your code will also work\n", 
#&gt;                     "automatically with any new backends developed after you wrote your code.\n", 
#&gt;                     "\n", "If you think it is necessary to modify the future strategy within a\n", 
#&gt;                     "function, then make sure to undo the changes when exiting the function.\n", 
#&gt;                     "This can be done using:\n", "\n", list("\n", 
#&gt;                       "  oplan &lt;- plan(new_set_of_strategies)\n", 
#&gt;                       "  on.exit(plan(oplan), add = TRUE)\n", 
#&gt;                       "  [...]\n"), "\n", "\n", "This is important because the end-user might have already set the future\n", 
#&gt;                     "strategy elsewhere for other purposes and will most likely not known that\n", 
#&gt;                     "calling your function will break their setup.\n", 
#&gt;                     list("Remember, your package and its functions might be used in a greater\n", 
#&gt;                       "context where multiple packages and functions are involved and those might\n", 
#&gt;                       "also rely on the future framework, so it is important to avoid stepping on\n", 
#&gt;                       "others' toes."), "\n")), "\n", "\n", list(
#&gt;                   list("Using plan() in scripts and vignettes"), 
#&gt;                   list("\n", "\n", "When writing scripts or vignettes that uses futures, try to place any\n", 
#&gt;                     "call to ", list("plan()"), " as far up (as early on) in the code as possible.\n", 
#&gt;                     "This will help users to quickly identify where the future plan is set up\n", 
#&gt;                     "and allow them to modify it to their computational resources.\n", 
#&gt;                     "Even better is to leave it to the user to set the ", 
#&gt;                     list("plan()"), " prior to\n", list("source()"), 
#&gt;                     ":ing the script or running the vignette.\n", 
#&gt;                     "If a ", list(list(".future.R")), " exists in the current directory and / or in\n", 
#&gt;                     "the user's home directory, it is sourced when the ", 
#&gt;                     list("future"), " package is\n", list("loaded"), 
#&gt;                     ".  Because of this, the ", list(".future.R"), 
#&gt;                     " file provides a\n", "convenient place for users to set the ", 
#&gt;                     list("plan()"), ".\n", "This behavior can be controlled via an ", 
#&gt;                     list(), " option - see\n", list("future options"), 
#&gt;                     " for more details.\n")), "\n", "\n", list(
#&gt;                   "\n", "a &lt;- b &lt;- c &lt;- NA_real_\n", "\n", "# An sequential future\n", 
#&gt;                   "plan(sequential)\n", "f &lt;- future({\n", "  a &lt;- 7\n", 
#&gt;                   "  b &lt;- 3\n", "  c &lt;- 2\n", "  a * b * c\n", 
#&gt;                   "})\n", "y &lt;- value(f)\n", "print(y)\n", "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                   "\n", "\n", "# A sequential future with lazy evaluation\n", 
#&gt;                   "plan(sequential)\n", "f &lt;- future({\n", "  a &lt;- 7\n", 
#&gt;                   "  b &lt;- 3\n", "  c &lt;- 2\n", "  a * b * c\n", 
#&gt;                   "}, lazy = TRUE)\n", "y &lt;- value(f)\n", "print(y)\n", 
#&gt;                   "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                   "\n", "\n", "# A multicore future (specified as a string)\n", 
#&gt;                   "plan(\"multicore\")\n", "f &lt;- future({\n", 
#&gt;                   "  a &lt;- 7\n", "  b &lt;- 3\n", "  c &lt;- 2\n", "  a * b * c\n", 
#&gt;                   "})\n", "y &lt;- value(f)\n", "print(y)\n", "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                   "\n", "\n", "## Multisession futures gives an error on R CMD check on\n", 
#&gt;                   "## Windows (but not Linux or macOS) for unknown reasons.\n", 
#&gt;                   "## The same code works in package tests.\n", 
#&gt;                   list("\n", "\n", "# A multisession future (specified via a string variable)\n", 
#&gt;                     "plan(\"future::multisession\")\n", "f &lt;- future({\n", 
#&gt;                     "  a &lt;- 7\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                     "  a * b * c\n", "})\n", "y &lt;- value(f)\n", 
#&gt;                     "print(y)\n", "str(list(a = a, b = b, c = c)) ## All NAs\n", 
#&gt;                     "\n"), "\n", "\n", "## Explicitly close multisession workers by switching plan\n", 
#&gt;                   "plan(sequential)\n"), "\n"), private_length.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils.R", 
#&gt;                 "\n", list(".length"), "\n", list(".length"), 
#&gt;                 "\n", list("Gets the length of an object without dispatching"), 
#&gt;                 "\n", list("\n", ".length(x)\n"), "\n", list(
#&gt;                   "\n", list(list("x"), list("Any ", list(), 
#&gt;                     " object.")), "\n"), "\n", list("\n", "A non-negative integer.\n"), 
#&gt;                 "\n", list("\n", "Gets the length of an object without dispatching\n"), 
#&gt;                 "\n", list("\n", "This function returns ", list(
#&gt;                   "length(unclass(x))"), ", but tries to avoid\n", 
#&gt;                   "calling ", list("unclass(x)"), " unless necessary.\n"), 
#&gt;                 "\n", list("\n", list(list(".subset"), "()"), 
#&gt;                   " and ", list(list(".subset2"), "()"), ".\n"), 
#&gt;                 "\n", list("internal"), "\n"), `re-exports.Rd` = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/000.re-exports.R", 
#&gt;                 "\n", list("re-exports"), "\n", list("re-exports"), 
#&gt;                 "\n", list("as.cluster"), "\n", list("autoStopCluster"), 
#&gt;                 "\n", list("availableCores"), "\n", list("availableWorkers"), 
#&gt;                 "\n", list("makeClusterMPI"), "\n", list("makeClusterPSOCK"), 
#&gt;                 "\n", list("makeNodePSOCK"), "\n", list("supportsMulticore"), 
#&gt;                 "\n", list("Functions Moved to 'parallelly'"), 
#&gt;                 "\n", list("\n", "The following function used to be part of ", 
#&gt;                   list("future"), " but has since\n", "been migrated to ", 
#&gt;                   list("parallelly"), ".  The migration started with\n", 
#&gt;                   list("future"), " 1.20.0 (November 2020).  They were moved because they\n", 
#&gt;                   "are also useful outside of the ", list("future"), 
#&gt;                   " framework.\n"), "\n", list("\n", list("\n", 
#&gt;                   list(), " ", list(list("parallelly::as.cluster()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::autoStopCluster()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::availableCores()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::availableWorkers()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::makeClusterMPI()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::makeNodePSOCK()")), 
#&gt;                   "\n", list(), " ", list(list("parallelly::supportsMulticore()")), 
#&gt;                   "\n"), "\n", "\n", "For backward-compatible reasons, these functions remain available as\n", 
#&gt;                   "exact copies also from this package (as re-exports).  For example,", 
#&gt;                   list(list("html"), list(list("&lt;div class=\"r\"&gt;"))), 
#&gt;                   list("cl &lt;- parallelly::makeClusterPSOCK(2)\n"), 
#&gt;                   list(list("html"), list(list("&lt;/div&gt;"))), "\n", 
#&gt;                   "\n", "can still be accessed as:", list(list(
#&gt;                     "html"), list(list("&lt;div class=\"r\"&gt;"))), 
#&gt;                   list("cl &lt;- future::makeClusterPSOCK(2)\n"), 
#&gt;                   list(list("html"), list(list("&lt;/div&gt;"))), "\n"), 
#&gt;                 "\n"), readImmediateConditions.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils-immediateCondition.R", 
#&gt;                 "\n", list("readImmediateConditions"), "\n", 
#&gt;                 list("readImmediateConditions"), "\n", list("Read All 'immediateCondition' RDS Files"), 
#&gt;                 "\n", list("\n", "readImmediateConditions(\n", 
#&gt;                   "  path = immediateConditionsPath(),\n", "  pattern = \"[.]rds$\",\n", 
#&gt;                   "  include = getOption(\"future.relay.immediate\", \"immediateCondition\"),\n", 
#&gt;                   "  signal = FALSE,\n", "  remove = TRUE\n", 
#&gt;                   ")\n"), "\n", list("\n", list(list("path"), 
#&gt;                   list("(character string) The folder where the RDS files are.")), 
#&gt;                   "\n", "\n", list(list("pattern"), list("(character string) A regular expression selecting\n", 
#&gt;                     "the RDS files to be read.")), "\n", "\n", 
#&gt;                   list(list("include"), list("(character vector) The class or classes of the objects\n", 
#&gt;                     "to be kept.")), "\n", "\n", list(list("signal"), 
#&gt;                     list("(logical) If TRUE, the condition read are signaled.")), 
#&gt;                   "\n", "\n", list(list("remove"), list("(logical) If TRUE, the RDS files used are removed on exit.")), 
#&gt;                   "\n"), "\n", list("\n", "Returns a ", list(
#&gt;                   "base::list"), " of immediateCondition objects.\n"), 
#&gt;                 "\n", list("\n", "Read All 'immediateCondition' RDS Files\n"), 
#&gt;                 "\n", list("internal"), "\n"), remote.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/remote.R", 
#&gt;                 "\n", list("remote"), "\n", list("remote"), "\n", 
#&gt;                 list("Create a remote future whose value will be resolved asynchronously in a remote process"), 
#&gt;                 "\n", list("\n", "remote(\n", "  ...,\n", "  workers = NULL,\n", 
#&gt;                   "  revtunnel = TRUE,\n", "  myip = NULL,\n", 
#&gt;                   "  persistent = TRUE,\n", "  homogeneous = TRUE,\n", 
#&gt;                   "  envir = parent.frame()\n", ")\n"), "\n", 
#&gt;                 list("\n", list(list("..."), list("Additional named elements passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("workers"), list("A ", list(list(
#&gt;                     "cluster")), " object,\n", "a character vector of host names, a positive numeric scalar,\n", 
#&gt;                     "or a function.\n", "If a character vector or a numeric scalar, a ", 
#&gt;                     list("cluster"), " object\n", "is created using ", 
#&gt;                     list(list("makeClusterPSOCK"), "(workers)"), 
#&gt;                     ".\n", "If a function, it is called without arguments ", 
#&gt;                     list("when the future\n", "is created"), 
#&gt;                     " and its value is used to configure the workers.\n", 
#&gt;                     "The function should return any of the above types.")), 
#&gt;                   "\n", "\n", list(list("revtunnel"), list("If TRUE, reverse SSH tunneling is used for the\n", 
#&gt;                     "PSOCK cluster nodes to connect back to the master ", 
#&gt;                     list(), " process.  This\n", "avoids the hassle of firewalls, port forwarding and having to know\n", 
#&gt;                     "the internal / public IP address of the master ", 
#&gt;                     list(), " session.")), "\n", "\n", list(list(
#&gt;                     "myip"), list("The external IP address of this machine.\n", 
#&gt;                     "If NULL, then it is inferred using an online service (default).")), 
#&gt;                   "\n", "\n", list(list("persistent"), list("If FALSE, the evaluation environment is cleared\n", 
#&gt;                     "from objects prior to the evaluation of the future.")), 
#&gt;                   "\n", "\n", list(list("homogeneous"), list(
#&gt;                     "If TRUE, all cluster nodes is assumed to use the\n", 
#&gt;                     "same path to ", list("Rscript"), " as the main ", 
#&gt;                     list(), " session.  If FALSE, the\n", "it is assumed to be on the PATH for each node.\n", 
#&gt;                     "If NULL, then ", list(list("parallelly::makeClusterPSOCK()")), 
#&gt;                     " will decide on TRUE\n", "or FALSE depending on ", 
#&gt;                     list("workers"), ".")), "\n", "\n", list(
#&gt;                     list("envir"), list("The ", list("environment"), 
#&gt;                       " from where global objects should be\n", 
#&gt;                       "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("ClusterFuture"), ".\n"), "\n", 
#&gt;                 list("\n", "A remote future is a future that uses remote cluster evaluation,\n", 
#&gt;                   "which means that its ", list("value is computed and resolved\n", 
#&gt;                     "remotely in another process"), ".\n"), "\n", 
#&gt;                 list("\n", "This function is ", list("not"), 
#&gt;                   " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures on remote machine 'server.example.org', and\n", 
#&gt;                     "# any nested ones sequentially (default) on that remote machine\n", 
#&gt;                     "plan(remote, workers = \"server.example.org\")\n", 
#&gt;                     "\n", "# Evaluate futures on remote machine 'server.example.org', and\n", 
#&gt;                     "# nested ones in parallel on that remote machine\n", 
#&gt;                     "plan(list(\n", "   tweak(remote, workers = \"server.example.org\"),\n", 
#&gt;                     "   multisession\n", "))\n", "\n", "# Evaluate futures on remote machine 'server.example.org', and\n", 
#&gt;                     "# nested ones in parallel on the remote machines n1, n2, and n3.\n", 
#&gt;                     "plan(list(\n", "  tweak(remote, workers = \"server.example.org\"),\n", 
#&gt;                     "  tweak(cluster, workers = c(\"n1\", \"n2\", \"n3\"))\n", 
#&gt;                     "))\n"), list(list("html"), list(list("&lt;/div&gt;"))), 
#&gt;                   "\n"), "\n", list(list("'remote' versus 'cluster'"), 
#&gt;                   list("\n", "\n", "The ", list("remote"), " plan is a very similar to the ", 
#&gt;                     list(list("cluster")), " plan, but provides\n", 
#&gt;                     "more convenient default argument values when connecting to remote machines.  #' Specifically, ", 
#&gt;                     list("remote"), " uses ", list("persistent = TRUE"), 
#&gt;                     " by default, and it sets\n", list("homogeneous"), 
#&gt;                     ", ", list("revtunnel"), ", and ", list("myip"), 
#&gt;                     " \"wisely\" depending on the value of\n", 
#&gt;                     list("workers"), ".\n", "' See below for example on how ", 
#&gt;                     list("remote"), " and ", list("cluster"), 
#&gt;                     " are related.\n")), "\n", "\n", list("\n", 
#&gt;                   list("\\donttest{\n", "\n", "## Use a remote machine\n", 
#&gt;                     "plan(remote, workers = \"remote.server.org\")\n", 
#&gt;                     "\n", "## Evaluate expression remotely\n", 
#&gt;                     "host %&lt;-% { Sys.info()[[\"nodename\"]] }\n", 
#&gt;                     "host\n", "[1] \"remote.server.org\"\n", 
#&gt;                     "\n", "\n", "## The following setups are equivalent:\n", 
#&gt;                     "plan(remote, workers = \"localhost\")\n", 
#&gt;                     "plan(cluster, workers = \"localhost\", persistent = TRUE)\n", 
#&gt;                     "plan(cluster, workers = 1, persistent = TRUE)\n", 
#&gt;                     "plan(multisession, workers = 1, persistent = TRUE)\n", 
#&gt;                     "\n", "## The following setups are equivalent:\n", 
#&gt;                     "plan(remote, workers = \"remote.server.org\")\n", 
#&gt;                     "plan(cluster, workers = \"remote.server.org\", persistent = TRUE, homogeneous = FALSE)\n", 
#&gt;                     "\n", "## The following setups are equivalent:\n", 
#&gt;                     "cl &lt;- makeClusterPSOCK(\"remote.server.org\")\n", 
#&gt;                     "plan(remote, workers = cl)\n", "plan(cluster, workers = cl, persistent = TRUE)\n", 
#&gt;                     "\n", "}"), "\n"), "\n"), requestCore.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multicore.R", 
#&gt;                 "\n", list("requestCore"), "\n", list("requestCore"), 
#&gt;                 "\n", list("Request a core for multicore processing"), 
#&gt;                 "\n", list("\n", "requestCore(\n", "  await,\n", 
#&gt;                   "  workers = availableCores(),\n", "  timeout = getOption(\"future.wait.timeout\", 30 * 24 * 60 * 60),\n", 
#&gt;                   "  delta = getOption(\"future.wait.interval\", 0.2),\n", 
#&gt;                   "  alpha = getOption(\"future.wait.alpha\", 1.01)\n", 
#&gt;                   ")\n"), "\n", list("\n", list(list("await"), 
#&gt;                   list("A function used to try to \"collect\"\n", 
#&gt;                     "finished multicore subprocesses.")), "\n", 
#&gt;                   "\n", list(list("workers"), list("Total number of workers available.")), 
#&gt;                   "\n", "\n", list(list("timeout"), list("Maximum waiting time (in seconds) allowed\n", 
#&gt;                     "before a timeout error is generated.")), 
#&gt;                   "\n", "\n", list(list("delta"), list("Then base interval (in seconds) to wait\n", 
#&gt;                     "between each try.")), "\n", "\n", list(list(
#&gt;                     "alpha"), list("A multiplicative factor used to increase\n", 
#&gt;                     "the wait interval after each try.")), "\n"), 
#&gt;                 "\n", list("\n", "Invisible TRUE. If no cores are available after\n", 
#&gt;                   "extensive waiting, then a timeout error is thrown.\n"), 
#&gt;                 "\n", list("\n", "If no cores are available, the current process\n", 
#&gt;                   "blocks until a core is available.\n"), "\n", 
#&gt;                 list("internal"), "\n"), resetWorkers.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/zzz.plan.R", 
#&gt;                 "\n", list("resetWorkers"), "\n", list("resetWorkers"), 
#&gt;                 "\n", list("Free up active background workers"), 
#&gt;                 "\n", list("\n", "resetWorkers(x, ...)\n"), "\n", 
#&gt;                 list("\n", list(list("x"), list("A FutureStrategy.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "Free up active background workers\n"), 
#&gt;                 "\n", list("\n", "This function will resolve any active futures that is currently\n", 
#&gt;                   "being evaluated on background workers.\n"), 
#&gt;                 "\n", list("\n", "resetWorkers(plan())\n", "\n"), 
#&gt;                 "\n", list("internal"), "\n"), resolve.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/resolve.R", 
#&gt;                 "\n", list("resolve"), "\n", list("resolve"), 
#&gt;                 "\n", list("Resolve one or more futures synchronously"), 
#&gt;                 "\n", list("\n", "resolve(\n", "  x,\n", "  idxs = NULL,\n", 
#&gt;                   "  recursive = 0,\n", "  result = FALSE,\n", 
#&gt;                   "  stdout = FALSE,\n", "  signal = FALSE,\n", 
#&gt;                   "  force = FALSE,\n", "  sleep = 1,\n", "  value = result,\n", 
#&gt;                   "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                   "x"), list("A ", list("Future"), " to be resolved, or a list, an environment, or a\n", 
#&gt;                   "list environment of futures to be resolved.")), 
#&gt;                   "\n", "\n", list(list("idxs"), list("(optional) integer or logical index specifying the subset of\n", 
#&gt;                     "elements to check.")), "\n", "\n", list(
#&gt;                     list("recursive"), list("A non-negative number specifying how deep of a recursion\n", 
#&gt;                       "should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\n", 
#&gt;                       "no recursion is performed.")), "\n", "\n", 
#&gt;                   list(list("result"), list("(internal) If TRUE, the results are retrieved, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("stdout"), list("(internal) If TRUE, captured standard output is relayed, otherwise note.")), 
#&gt;                   "\n", "\n", list(list("signal"), list("(internal) If TRUE, captured ", 
#&gt;                     list("conditions"), " are relayed,\n", "otherwise not.")), 
#&gt;                   "\n", "\n", list(list("force"), list("(internal) If TRUE, captured standard output and captured\n", 
#&gt;                     list("conditions"), " already relayed is relayed again, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("sleep"), list("Number of seconds to wait before checking if futures have been\n", 
#&gt;                     "resolved since last time.")), "\n", "\n", 
#&gt;                   list(list("value"), list("(DEPRECATED) Use argument ", 
#&gt;                     list("result"), " instead.")), "\n", "\n", 
#&gt;                   list(list(list()), list("Not used.")), "\n"), 
#&gt;                 "\n", list("\n", "Returns ", list("x"), " (regardless of subsetting or not).\n", 
#&gt;                   "If ", list("signal"), " is TRUE and one of the futures produces an error, then\n", 
#&gt;                   "that error is produced.\n"), "\n", list("\n", 
#&gt;                   "This function provides an efficient mechanism for waiting for multiple\n", 
#&gt;                   "futures in a container (e.g. list or environment) to be resolved while in\n", 
#&gt;                   "the meanwhile retrieving values of already resolved futures.\n"), 
#&gt;                 "\n", list("\n", "This function is resolves synchronously, i.e. it blocks until ", 
#&gt;                   list("x"), " and\n", "any containing futures are resolved.\n"), 
#&gt;                 "\n", list("\n", "To resolve a future ", list(
#&gt;                   "variable"), ", first retrieve its\n", list(
#&gt;                   "Future"), " object using ", list(list("futureOf()")), 
#&gt;                   ", e.g.\n", list("resolve(futureOf(x))"), ".\n"), 
#&gt;                 "\n"), resolved.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/resolved.R", 
#&gt;                 "\n", list("resolved"), "\n", list("resolved"), 
#&gt;                 "\n", list("Check whether a future is resolved or not"), 
#&gt;                 "\n", list("\n", "resolved(x, ...)\n"), "\n", 
#&gt;                 list("\n", list(list("x"), list("A ", list("Future"), 
#&gt;                   ", a list, or an environment (which also\n", 
#&gt;                   "includes ", list("list environment"), ".")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "A logical of the same length and dimensions as ", 
#&gt;                   list("x"), ".\n", "Each element is TRUE unless the corresponding element is a\n", 
#&gt;                   "non-resolved future in case it is FALSE.\n"), 
#&gt;                 "\n", list("\n", "Check whether a future is resolved or not\n"), 
#&gt;                 "\n", list("\n", "This method needs to be implemented by the class that implement\n", 
#&gt;                   "the Future API.  The implementation should return either TRUE or FALSE\n", 
#&gt;                   "and must never throw an error (except for ", 
#&gt;                   list("FutureError"), ":s which indicate\n", 
#&gt;                   "significant, often unrecoverable infrastructure problems).\n", 
#&gt;                   "It should also be possible to use the method for polling the\n", 
#&gt;                   "future until it is resolved (without having to wait infinitely long),\n", 
#&gt;                   "e.g. ", list("while (!resolved(future)) Sys.sleep(5)"), 
#&gt;                   ".\n"), "\n"), result.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/Future-class.R", 
#&gt;                 "\n", list("result.Future"), "\n", list("result.Future"), 
#&gt;                 "\n", list("result"), "\n", list("Get the results of a resolved future"), 
#&gt;                 "\n", list("\n", list(list("result"), list("Future")), 
#&gt;                   "(future, ...)\n"), "\n", list("\n", list(list(
#&gt;                   "future"), list("A ", list("Future"), ".")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "The ", list("FutureResult"), 
#&gt;                   " object.\n"), "\n", list("\n", "Get the results of a resolved future\n"), 
#&gt;                 "\n", list("\n", "This function is only part of the ", 
#&gt;                   list("backend"), " Future API.\n", "This function is ", 
#&gt;                   list("not"), " part of the frontend Future API.\n"), 
#&gt;                 "\n", list("internal"), "\n"), run.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/Future-class.R", 
#&gt;                 "\n", list("run.Future"), "\n", list("run.Future"), 
#&gt;                 "\n", list("run"), "\n", list("Run a future"), 
#&gt;                 "\n", list("\n", list(list("run"), list("Future")), 
#&gt;                   "(future, ...)\n"), "\n", list("\n", list(list(
#&gt;                   "future"), list("A ", list("Future"), ".")), 
#&gt;                   "\n", "\n", list(list(list()), list("Not used.")), 
#&gt;                   "\n"), "\n", list("\n", "The ", list("Future"), 
#&gt;                   " object.\n"), "\n", list("\n", "Run a future\n"), 
#&gt;                 "\n", list("\n", "This function can only be called once per future.\n", 
#&gt;                   "Further calls will result in an informative error.\n", 
#&gt;                   "If a future is not run when its value is queried,\n", 
#&gt;                   "then it is run at that point.\n"), "\n", list(
#&gt;                   "internal"), "\n"), save_rds.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/utils-immediateCondition.R", 
#&gt;                 "\n", list("save_rds"), "\n", list("save_rds"), 
#&gt;                 "\n", list("Robustly Saves an Object to RDS File Atomically"), 
#&gt;                 "\n", list("\n", "save_rds(object, pathname, ...)\n"), 
#&gt;                 "\n", list("\n", list(list("object"), list("The ", 
#&gt;                   list(), " object to be save.")), "\n", "\n", 
#&gt;                   list(list("pathname"), list("RDS file to written.")), 
#&gt;                   "\n", "\n", list(list(list()), list("(optional) Additional arguments passed to ", 
#&gt;                     list(list("base::saveRDS()")), ".")), "\n"), 
#&gt;                 "\n", list("\n", "(invisible) The pathname of the RDS written.\n"), 
#&gt;                 "\n", list("\n", "Robustly Saves an Object to RDS File Atomically\n"), 
#&gt;                 "\n", list("\n", "Uses ", list("base::saveRDS"), 
#&gt;                   " internally but writes the object atomically by first\n", 
#&gt;                   "writing to a temporary file which is then renamed.\n"), 
#&gt;                 "\n", list("internal"), "\n"), sequential.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/sequential.R", 
#&gt;                 "\n", list("sequential"), "\n", list("sequential"), 
#&gt;                 "\n", list("uniprocess"), "\n", list("transparent"), 
#&gt;                 "\n", list("Create a sequential future whose value will be in the current ", 
#&gt;                   list(), " session"), "\n", list("\n", "sequential(..., envir = parent.frame())\n", 
#&gt;                   "\n", "transparent(..., envir = parent.frame())\n"), 
#&gt;                 "\n", list("\n", list(list("..."), list("Additional arguments passed to ", 
#&gt;                   list(list("Future()")), ".")), "\n", "\n", 
#&gt;                   list(list("envir"), list("The ", list("environment"), 
#&gt;                     " from where global objects should be\n", 
#&gt;                     "identified.")), "\n"), "\n", list("\n", 
#&gt;                   "A ", list("SequentialFuture"), ".\n"), "\n", 
#&gt;                 list("\n", "A sequential future is a future that is evaluated sequentially in the\n", 
#&gt;                   "current ", list(), " session similarly to how ", 
#&gt;                   list(), " expressions are evaluated in ", list(), 
#&gt;                   ".\n", "The only difference to ", list(), " itself is that globals are validated\n", 
#&gt;                   "by default just as for all other types of futures in this package.\n"), 
#&gt;                 "\n", list("\n", "This function is ", list("not"), 
#&gt;                   " meant to be called directly.  Instead, the\n", 
#&gt;                   "typical usages are:", list(list("html"), list(
#&gt;                     list("&lt;div class=\"r\"&gt;"))), list("# Evaluate futures sequentially in the current R process\n", 
#&gt;                     "plan(sequential)\n"), list(list("html"), 
#&gt;                     list(list("&lt;/div&gt;"))), "\n", "\n", "\n"), 
#&gt;                 "\n", list(list("transparent futures (troubleshooting only)"), 
#&gt;                   list("\n", "\n", "Transparent futures are sequential futures configured to emulate how R\n", 
#&gt;                     "evaluates expressions as far as possible.  For instance, errors and\n", 
#&gt;                     "warnings are signaled immediately and assignments are done to the\n", 
#&gt;                     "calling environment (without ", list("local()"), 
#&gt;                     " as default for all other\n", "types of futures).  This makes transparent futures ideal for\n", 
#&gt;                     "troubleshooting, especially when there are errors.\n", 
#&gt;                     list("WARNING: Transparent futures should only be used for debugging and\n", 
#&gt;                       "troubleshooting.  They should not be used for production pipelines\n", 
#&gt;                       "and must not be set within another package.  This is especially\n", 
#&gt;                       "important since 'transparent' futures might be deprecated and replaced\n", 
#&gt;                       "by better means of debugging in future releases."), 
#&gt;                     "\n")), "\n", "\n", list("\n", "## Use sequential futures\n", 
#&gt;                   "plan(sequential)\n", "\n", "## A global variable\n", 
#&gt;                   "a &lt;- 0\n", "\n", "## Create a sequential future\n", 
#&gt;                   "f &lt;- future({\n", "  b &lt;- 3\n", "  c &lt;- 2\n", 
#&gt;                   "  a * b * c\n", "})\n", "\n", "## Since 'a' is a global variable in future 'f' which\n", 
#&gt;                   "## is eagerly resolved (default), this global has already\n", 
#&gt;                   "## been resolved / incorporated, and any changes to 'a'\n", 
#&gt;                   "## at this point will _not_ affect the value of 'f'.\n", 
#&gt;                   "a &lt;- 7\n", "print(a)\n", "\n", "v &lt;- value(f)\n", 
#&gt;                   "print(v)\n", "stopifnot(v == 0)\n"), "\n"), 
#&gt;             sessionDetails.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/sessionDetails.R", 
#&gt;                 "\n", list("sessionDetails"), "\n", list("sessionDetails"), 
#&gt;                 "\n", list("Outputs details on the current ", 
#&gt;                   list(), " session"), "\n", list("\n", "sessionDetails(env = FALSE)\n"), 
#&gt;                 "\n", list("\n", list(list("env"), list("If TRUE, ", 
#&gt;                   list("Sys.getenv()"), " information is returned.")), 
#&gt;                   "\n"), "\n", list("\n", "Invisibly a list of all details.\n"), 
#&gt;                 "\n", list("\n", "Outputs details on the current ", 
#&gt;                   list(), " session\n"), "\n", list("\n", "Note that remote futures use ", 
#&gt;                   list("persistent = TRUE"), " by default.\n"), 
#&gt;                 "\n", list("internal"), "\n"), signalConditions.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/signalConditions.R", 
#&gt;                 "\n", list("signalConditions"), "\n", list("signalConditions"), 
#&gt;                 "\n", list("Signals Captured Conditions"), "\n", 
#&gt;                 list("\n", "signalConditions(\n", "  future,\n", 
#&gt;                   "  include = \"condition\",\n", "  exclude = NULL,\n", 
#&gt;                   "  resignal = TRUE,\n", "  ...\n", ")\n"), 
#&gt;                 "\n", list("\n", list(list("future"), list("A resolved ", 
#&gt;                   list("Future"), ".")), "\n", "\n", list(list(
#&gt;                   "include"), list("A character string of ", 
#&gt;                   list("condition"), "\n", "classes to signal.")), 
#&gt;                   "\n", "\n", list(list("exclude"), list("A character string of ", 
#&gt;                     list("condition"), "\n", "classes ", list(
#&gt;                       "not"), " to signal.")), "\n", "\n", list(
#&gt;                     list("resignal"), list("If TRUE, then already signaled conditions are signaled\n", 
#&gt;                       "again, otherwise not.")), "\n", "\n", 
#&gt;                   list(list(list()), list("Not used.")), "\n"), 
#&gt;                 "\n", list("\n", "Returns the ", list("Future"), 
#&gt;                   " where conditioned that were signaled\n", 
#&gt;                   "have been flagged to have been signaled.\n"), 
#&gt;                 "\n", list("\n", "Captured conditions that meet the ", 
#&gt;                   list("include"), " and ", list("exclude"), 
#&gt;                   "\n", "requirements are signaled ", list("in the order as they were captured"), 
#&gt;                   ".\n"), "\n", list("\n", "Conditions are signaled by\n", 
#&gt;                   list(list("signalCondition"), "()"), ".\n"), 
#&gt;                 "\n"), sticky_globals.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/sticky_globals.R", 
#&gt;                 "\n", list("sticky_globals"), "\n", list("sticky_globals"), 
#&gt;                 "\n", list("Place a sticky-globals environment immediately after the global environment"), 
#&gt;                 "\n", list("\n", "sticky_globals(erase = FALSE, name = \"future:sticky_globals\", pos = 2L)\n"), 
#&gt;                 "\n", list("\n", list(list("erase"), list("(logical) If TRUE, the environment is erased, otherwise not.")), 
#&gt;                   "\n", "\n", list(list("name"), list("(character) The name of the environment on the ", 
#&gt;                     list("base::search"), "\n", "path.")), "\n", 
#&gt;                   "\n", list(list("pos"), list("(integer) The position on the search path where the\n", 
#&gt;                     "environment should be positioned.  If ", 
#&gt;                     list("pos == 0L"), ", then the environment\n", 
#&gt;                     "is detached, if it exists.")), "\n"), "\n", 
#&gt;                 list("\n", "(invisible; environment) The environment.\n"), 
#&gt;                 "\n", list("\n", "Place a sticky-globals environment immediately after the global environment\n"), 
#&gt;                 "\n", list("internal"), "\n"), tweak.Rd = list(
#&gt;                 "% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/tweak.R", 
#&gt;                 "\n", list("tweak"), "\n", list("tweak"), "\n", 
#&gt;                 list("Tweak a future function by adjusting its default arguments"), 
#&gt;                 "\n", list("\n", "tweak(strategy, ..., penvir = parent.frame())\n"), 
#&gt;                 "\n", list("\n", list(list("strategy"), list(
#&gt;                   "An existing future function or the name of one.")), 
#&gt;                   "\n", "\n", list(list(list()), list("Named arguments to replace the defaults of existing\n", 
#&gt;                     "arguments.")), "\n", "\n", list(list("penvir"), 
#&gt;                     list("The environment used when searching for a future\n", 
#&gt;                       "function by its name.")), "\n"), "\n", 
#&gt;                 list("\n", "a future function.\n"), "\n", list(
#&gt;                   "\n", "Tweak a future function by adjusting its default arguments\n"), 
#&gt;                 "\n", list("\n", "Use ", list(list("plan()")), 
#&gt;                   " to set a future to become the\n", "new default strategy.\n"), 
#&gt;                 "\n"), usedCores.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/multicore.R", 
#&gt;                 "\n", list("usedCores"), "\n", list("usedCores"), 
#&gt;                 "\n", list("Get number of cores currently used"), 
#&gt;                 "\n", list("\n", "usedCores()\n"), "\n", list(
#&gt;                   "\n", "A non-negative integer.\n"), "\n", list(
#&gt;                   "\n", "Get number of children (and don't count the current process)\n", 
#&gt;                   "used by the current ", list(), " session.  The number of children\n", 
#&gt;                   "is the total number of subprocesses launched by this\n", 
#&gt;                   "process that are still running and whose values have yet\n", 
#&gt;                   "not been collected.\n"), "\n", list("internal"), 
#&gt;                 "\n"), value.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;                 "\n", "% Please edit documentation in R/value.R", 
#&gt;                 "\n", list("value"), "\n", list("value"), "\n", 
#&gt;                 list("values"), "\n", list("value.Future"), "\n", 
#&gt;                 list("value.list"), "\n", list("value.listenv"), 
#&gt;                 "\n", list("value.environment"), "\n", list("The value of a future or the values of all elements in a container"), 
#&gt;                 "\n", list("\n", "value(...)\n", "\n", list(list(
#&gt;                   "value"), list("Future")), "(future, stdout = TRUE, signal = TRUE, ...)\n", 
#&gt;                   "\n", list(list("value"), list("list")), "(x, stdout = TRUE, signal = TRUE, ...)\n", 
#&gt;                   "\n", list(list("value"), list("listenv")), 
#&gt;                   "(x, stdout = TRUE, signal = TRUE, ...)\n", 
#&gt;                   "\n", list(list("value"), list("environment")), 
#&gt;                   "(x, stdout = TRUE, signal = TRUE, ...)\n"), 
#&gt;                 "\n", list("\n", list(list(list()), list("All arguments used by the S3 methods.")), 
#&gt;                   "\n", "\n", list(list("future, x"), list("A ", 
#&gt;                     list("Future"), ", an environment, a list, or a list environment.")), 
#&gt;                   "\n", "\n", list(list("stdout"), list("If TRUE, standard output captured while resolving futures\n", 
#&gt;                     "is relayed, otherwise not.")), "\n", "\n", 
#&gt;                   list(list("signal"), list("If TRUE, ", list(
#&gt;                     "conditions"), " captured while resolving\n", 
#&gt;                     "futures are relayed, otherwise not.")), 
#&gt;                   "\n"), "\n", list("\n", list("value()"), " of a Future object returns the value of the future, which can\n", 
#&gt;                   "be any type of ", list(), " object.\n", "\n", 
#&gt;                   list("value()"), " of a list, an environment, or a list environment returns an\n", 
#&gt;                   "object with the same number of elements and of the same class.\n", 
#&gt;                   "Names and dimension attributes are preserved, if available.\n", 
#&gt;                   "All future elements are replaced by their corresponding ", 
#&gt;                   list("value()"), " values.\n", "For all other elements, the existing object is kept as-is.\n", 
#&gt;                   "\n", "If ", list("signal"), " is TRUE and one of the futures produces an error, then\n", 
#&gt;                   "that error is produced.\n"), "\n", list("\n", 
#&gt;                   "Gets the value of a future or the values of all elements (including futures)\n", 
#&gt;                   "in a container such as a list, an environment, or a list environment.\n", 
#&gt;                   "If one or more futures is unresolved, then this function blocks until all\n", 
#&gt;                   "queried futures are resolved.\n"), "\n")), 
#&gt;         source = list(`ClusterFuture-class.Rd` = c("R/ClusterFuture-class.R", 
#&gt;         "R/MultisessionFuture-class.R"), `ConstantFuture-class.Rd` = "R/ConstantFuture-class.R", 
#&gt;             `Future-class.Rd` = "R/Future-class.R", FutureCondition.Rd = "R/FutureCondition-class.R", 
#&gt;             FutureGlobals.Rd = "R/FutureGlobals-class.R", FutureResult.Rd = "R/FutureResult-class.R", 
#&gt;             `MulticoreFuture-class.Rd` = "R/MulticoreFuture-class.R", 
#&gt;             `MultiprocessFuture-class.Rd` = "R/MultiprocessFuture-class.R", 
#&gt;             `UniprocessFuture-class.Rd` = "R/UniprocessFuture-class.R", 
#&gt;             as_lecyer_cmrg_seed.Rd = "R/rng.R", backtrace.Rd = "R/backtrace.R", 
#&gt;             cluster.Rd = "R/cluster.R", clusterExportSticky.Rd = "R/sticky_globals.R", 
#&gt;             find_references.Rd = "R/utils-marshalling.R", future.Rd = c("R/future.R", 
#&gt;             "R/futureAssign.R", "R/futureAssign_OP.R", "R/futureCall.R"
#&gt;             ), future.options.Rd = "R/options.R", futureOf.Rd = "R/futureOf.R", 
#&gt;             futureSessionInfo.Rd = "R/futureSessionInfo.R", futures.Rd = "R/futures.R", 
#&gt;             getExpression.Rd = "R/Future-class.R", getGlobalsAndPackages.Rd = "R/globals.R", 
#&gt;             `grapes-conditions-grapes.Rd` = "R/conditions_OP.R", 
#&gt;             `grapes-globals-grapes.Rd` = "R/globals_OP.R", `grapes-label-grapes.Rd` = "R/label_OP.R", 
#&gt;             `grapes-lazy-grapes.Rd` = "R/lazy_OP.R", `grapes-plan-grapes.Rd` = "R/plan_OP.R", 
#&gt;             `grapes-seed-grapes.Rd` = "R/seed_OP.R", `grapes-stdout-grapes.Rd` = "R/stdout_OP.R", 
#&gt;             `grapes-tweak-grapes.Rd` = "R/tweak_OP.R", make_rng_seeds.Rd = "R/rng.R", 
#&gt;             mandelbrot.Rd = "R/mandelbrot.R", multicore.Rd = "R/multicore.R", 
#&gt;             multiprocess.Rd = "R/multiprocess.R", multisession.Rd = "R/multisession.R", 
#&gt;             nbrOfWorkers.Rd = "R/nbrOfWorkers.R", nullcon.Rd = "R/utils.R", 
#&gt;             pid_exists.Rd = "R/utils.R", plan.Rd = "R/zzz.plan.R", 
#&gt;             private_length.Rd = "R/utils.R", `re-exports.Rd` = "R/000.re-exports.R", 
#&gt;             readImmediateConditions.Rd = "R/utils-immediateCondition.R", 
#&gt;             remote.Rd = "R/remote.R", requestCore.Rd = "R/multicore.R", 
#&gt;             resetWorkers.Rd = "R/zzz.plan.R", resolve.Rd = "R/resolve.R", 
#&gt;             resolved.Rd = "R/resolved.R", result.Rd = "R/Future-class.R", 
#&gt;             run.Rd = "R/Future-class.R", save_rds.Rd = "R/utils-immediateCondition.R", 
#&gt;             sequential.Rd = "R/sequential.R", sessionDetails.Rd = "R/sessionDetails.R", 
#&gt;             signalConditions.Rd = "R/signalConditions.R", sticky_globals.Rd = "R/sticky_globals.R", 
#&gt;             tweak.Rd = "R/tweak.R", usedCores.Rd = "R/multicore.R", 
#&gt;             value.Rd = "R/value.R"), keywords = list("internal", 
#&gt;             "internal", "internal", "internal", "internal", "internal", 
#&gt;             "internal", "internal", "internal", "internal", character(0), 
#&gt;             character(0), "internals", "internal", character(0), 
#&gt;             "internal", character(0), character(0), character(0), 
#&gt;             "internal", "internal", character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), "internal", "internal", 
#&gt;             character(0), "internal", character(0), character(0), 
#&gt;             "internal", "internal", character(0), "internal", 
#&gt;             character(0), "internal", character(0), "internal", 
#&gt;             "internal", character(0), character(0), "internal", 
#&gt;             "internal", "internal", character(0), "internal", 
#&gt;             character(0), "internal", character(0), "internal", 
#&gt;             character(0)), concepts = list(character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0)), internal = c(TRUE, TRUE, 
#&gt;         TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, 
#&gt;         FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;         TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, 
#&gt;         TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, 
#&gt;         FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;         FALSE, TRUE, FALSE)), tutorials = list(name = character(0), 
#&gt;         file_out = character(0), title = character(0), pagetitle = character(0), 
#&gt;         url = character(0)), vignettes = list(name = c("future-1-overview", 
#&gt;     "future-2-output", "future-3-topologies", "future-4-issues", 
#&gt;     "future-4-non-exportable-objects", "future-5-startup", "future-6-future-api-backend-specification", 
#&gt;     "future-7-for-package-developers", "future-8-how-future-is-validated"
#&gt;     ), file_in = c("vignettes/future-1-overview.Rmd", "vignettes/future-2-output.Rmd", 
#&gt;     "vignettes/future-3-topologies.Rmd", "vignettes/future-4-issues.Rmd", 
#&gt;     "vignettes/future-4-non-exportable-objects.Rmd", "vignettes/future-5-startup.Rmd", 
#&gt;     "vignettes/future-6-future-api-backend-specification.Rmd", 
#&gt;     "vignettes/future-7-for-package-developers.Rmd", "vignettes/future-8-how-future-is-validated.Rmd"
#&gt;     ), file_out = c("articles/future-1-overview.html", "articles/future-2-output.html", 
#&gt;     "articles/future-3-topologies.html", "articles/future-4-issues.html", 
#&gt;     "articles/future-4-non-exportable-objects.html", "articles/future-5-startup.html", 
#&gt;     "articles/future-6-future-api-backend-specification.html", 
#&gt;     "articles/future-7-for-package-developers.html", "articles/future-8-how-future-is-validated.html"
#&gt;     ), title = c("A Future for R: A Comprehensive Overview", 
#&gt;     "A Future for R: Text and Message Output", "A Future for R: Future Topologies", 
#&gt;     "A Future for R: Common Issues with Solutions", "A Future for R: Non-Exportable Objects", 
#&gt;     "A Future for R: Controlling Default Future Strategy", "A Future for R: Future API Backend Specification", 
#&gt;     "A Future for R: Best Practices for Package Developers", 
#&gt;     "A Future for R: How the Future Framework is Validated"), 
#&gt;         description = c(NA_character_, NA_character_, NA_character_, 
#&gt;         NA_character_, NA_character_, NA_character_, NA_character_, 
#&gt;         NA_character_, NA_character_)))), examples = base::quote(TRUE), 
#&gt;     run_dont_run = base::quote(FALSE), seed = base::quote(1014), 
#&gt;     lazy = base::quote(FALSE), override = base::quote(list()), 
#&gt;     install = base::quote(FALSE), preview = base::quote(FALSE), 
#&gt;     new_process = base::quote(FALSE), devel = base::quote(FALSE), 
#&gt;     crayon_enabled = base::quote(TRUE), crayon_colors = base::quote(256), 
#&gt;     pkgdown_internet = base::quote(TRUE))
#&gt; 
#&gt; [[13]]
#&gt; pkgdown::build_site(...)
#&gt; 
#&gt; [[14]]
#&gt; build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, lazy = lazy, override = override, preview = preview, 
#&gt;     devel = devel)
#&gt; 
#&gt; [[15]]
#&gt; build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, override = override, preview = FALSE, devel = devel)
#&gt; 
#&gt; [[16]]
#&gt; purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, 
#&gt;     examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[17]]
#&gt; .f(.x[[i]], ...)
#&gt; 
#&gt; [[18]]
#&gt; withCallingHandlers(data_reference_topic(topic, pkg, examples = examples, 
#&gt;     run_dont_run = run_dont_run), error = function(err) {
#&gt;     msg &lt;- c(paste0("Failed to parse Rd in ", topic$file_in), 
#&gt;         i = err$message)
#&gt;     abort(msg, parent = err)
#&gt; })
#&gt; 
#&gt; [[19]]
#&gt; data_reference_topic(topic, pkg, examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[20]]
#&gt; run_examples(tags$tag_examples[[1]], env = new.env(parent = globalenv()), 
#&gt;     topic = tools::file_path_sans_ext(topic$file_in), run_examples = examples, 
#&gt;     run_dont_run = run_dont_run)
#&gt; 
#&gt; [[21]]
#&gt; highlight_examples(code, topic, env = env)
#&gt; 
#&gt; [[22]]
#&gt; downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, 
#&gt;     env = child_env(env))
#&gt; 
#&gt; [[23]]
#&gt; evaluate::evaluate(code, child_env(env), new_device = TRUE)
#&gt; 
#&gt; [[24]]
#&gt; evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
#&gt;     debug = debug, last = i == length(out), use_try = stop_on_error != 
#&gt;         2L, keep_warning = keep_warning, keep_message = keep_message, 
#&gt;     output_handler = output_handler, include_timing = include_timing)
#&gt; 
#&gt; [[25]]
#&gt; timing_fn(handle(ev &lt;- withCallingHandlers(withVisible(eval(expr, 
#&gt;     envir, enclos)), warning = wHandler, error = eHandler, message = mHandler)))
#&gt; 
#&gt; [[26]]
#&gt; handle(ev &lt;- withCallingHandlers(withVisible(eval(expr, envir, 
#&gt;     enclos)), warning = wHandler, error = eHandler, message = mHandler))
#&gt; 
#&gt; [[27]]
#&gt; try(f, silent = TRUE)
#&gt; 
#&gt; [[28]]
#&gt; tryCatch(expr, error = function(e) {
#&gt;     call &lt;- conditionCall(e)
#&gt;     if (!is.null(call)) {
#&gt;         if (identical(call[[1L]], quote(doTryCatch))) 
#&gt;             call &lt;- sys.call(-4L)
#&gt;         dcall &lt;- deparse(call)[1L]
#&gt;         prefix &lt;- paste("Error in", dcall, ": ")
#&gt;         LONG &lt;- 75L
#&gt;         sm &lt;- strsplit(conditionMessage(e), "\n")[[1L]]
#&gt;         w &lt;- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
#&gt;         if (is.na(w)) 
#&gt;             w &lt;- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
#&gt;                 type = "b")
#&gt;         if (w &gt; LONG) 
#&gt;             prefix &lt;- paste0(prefix, "\n  ")
#&gt;     }
#&gt;     else prefix &lt;- "Error : "
#&gt;     msg &lt;- paste0(prefix, conditionMessage(e), "\n")
#&gt;     .Internal(seterrmessage(msg[1L]))
#&gt;     if (!silent &amp;&amp; isTRUE(getOption("show.error.messages"))) {
#&gt;         cat(msg, file = outFile)
#&gt;         .Internal(printDeferredWarnings())
#&gt;     }
#&gt;     invisible(structure(msg, class = "try-error", condition = e))
#&gt; })
#&gt; 
#&gt; [[29]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[30]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[31]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[32]]
#&gt; withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, 
#&gt;     error = eHandler, message = mHandler)
#&gt; 
#&gt; [[33]]
#&gt; withVisible(eval(expr, envir, enclos))
#&gt; 
#&gt; [[34]]
#&gt; eval(expr, envir, enclos)
#&gt; 
#&gt; [[35]]
#&gt; eval(expr, envir, enclos)
#&gt; 
#&gt; [[36]]
#&gt; future({
#&gt;     foo("a")
#&gt; })
#&gt; 
#&gt; [[37]]
#&gt; Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
#&gt;     seed = seed, globals = globals, packages = packages, stdout = stdout, 
#&gt;     conditions = conditions, earlySignal = earlySignal, label = label, 
#&gt;     gc = gc, ...)
#&gt; 
#&gt; [[38]]
#&gt; eval(quote({
#&gt;     foo("a")
#&gt; }), new.env())
#&gt; 
#&gt; [[39]]
#&gt; foo("a")
#&gt; 
#&gt; [[40]]
#&gt; function(...) my_log(...)
#&gt; 
#&gt; [[41]]
#&gt; log(x)
#&gt; </div><div class='input'><span class='co'># \dontshow{</span>
<span class='co'>## R CMD check: make sure any open connections are closed afterward</span>
<span class='kw'>if</span> <span class='op'>(</span><span class='op'>!</span><span class='fu'><a href='https://rdrr.io/r/base/class.html'>inherits</a></span><span class='op'>(</span><span class='fu'><a href='plan.html'>plan</a></span><span class='op'>(</span><span class='st'>"next"</span><span class='op'>)</span>, <span class='st'>"sequential"</span><span class='op'>)</span><span class='op'>)</span> <span class='fu'><a href='plan.html'>plan</a></span><span class='op'>(</span><span class='va'>sequential</span><span class='op'>)</span>
<span class='co'># }</span>

</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Henrik Bengtsson.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1 and <a href="https://github.com/HenrikBengtsson/pkgdown.extras/">pkgdown.extras</a> 0.0.0.9002.</p>
</div>

      </footer>
   </div>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.js" integrity="sha256-GKvGqXDznoRYHCwKXGnuchvKSwmx9SRMrZOTh2g4Sb0=" crossorigin="anonymous"></script>
<script>
  docsearch({
    
    
    apiKey: 'aa6e02fc501886fb0f7c91ac4e300456',
    indexName: 'futureverse',
    algoliaOptions: { 'facetFilters': ['project:future'] },
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script>



  </body>
</html>


